'From Pharo6.0 of 13 May 2016 [Latest update: #60493] on 17 May 2017 at 1:01:41.053846 pm'!----QUIT----2017-05-17T13:02:17.571196+02:00 Pharo-60493.image priorSource: 0!----QUIT----2017-05-17T13:02:52.052925+02:00 Pharo-60493.image priorSource: 92!----QUIT/NOSAVE----2017-05-17T13:03:08.259387+02:00 Pharo-60493.image priorSource: 172!----QUIT----2017-05-17T13:03:42.089076+02:00 Pharo-60493.image priorSource: 172!----QUIT----2017-05-17T13:09:56.388095+02:00 Pharo-60493.image priorSource: 342!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/17/2017 15:15' prior: 59349094!commentForCurrentUpdate ^ '20064 ClassTest>>#testMethodsReferencingClass uses non-existing BehaviorTests	https://pharo.fogbugz.com/f/cases/20064'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/17/2017 15:15'!script60494	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.144.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.52.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.15.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.192.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.101.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.6.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2510.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.173.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.615.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.49.mczPharoBootstrap-Initialization-TheIntegrator.4.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.71.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/17/2017 15:15'!update60494	"self new update60494"	self withUpdateLog: '20064 ClassTest>>#testMethodsReferencingClass uses non-existing BehaviorTests	https://pharo.fogbugz.com/f/cases/20064'.	self loadTogether: self script60494 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60493!ScriptLoader removeSelector: #script60493!"ScriptLoader60"!!ClassTest methodsFor: 'testing - navigation' stamp: 'PavelKrivanek 5/16/2017 14:47' prior: 19489936!testMethodsReferencingClass	self assert: (ClassTest methodsReferencingClass: (Smalltalk classNamed: #ExampleForTest111)) equals: {(ClassTest >> #testOrdersACollectionOfClassesBySuperclass)}.	self		assert: ((ClassTest methodsReferencingClass: (Smalltalk classNamed: #ExampleForTest1)) sort: [ :a :b | a name <= b name]) asArray		equals:			{ClassTest>>#referencingMethod1. 			ClassTest>>#referencingMethod2. 			ClassTest>>#testOrdersACollectionOfClassesBySuperclass}.	self assert: (ClassTest methodsReferencingClass: (Smalltalk classNamed: #BehaviorTest)) isEmpty! !"Kernel-Tests"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.568.mcz') load.ScriptLoader new update60494.!----End fileIn----!----QUIT----2017-05-18T09:47:15.580373+02:00 Pharo.image priorSource: 424!----QUIT----2017-05-18T09:47:26.423036+02:00 Pharo.image priorSource: 20220!----QUIT----2017-05-19T09:35:29.483671+02:00 Pharo.image priorSource: 20296!----QUIT----2017-05-19T09:35:36.656906+02:00 Pharo.image priorSource: 20374!----QUIT----2017-05-19T14:15:05.912563+02:00 Pharo.image priorSource: 20452!----QUIT----2017-05-19T14:15:13.143532+02:00 Pharo.image priorSource: 20530!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/22/2017 09:50' prior: 33555030!commentForCurrentUpdate ^ '20064 ClassTest>>#testMethodsReferencingClass uses non-existing BehaviorTests	https://pharo.fogbugz.com/f/cases/2006420074 Red-pane-of-death when sources file missing	https://pharo.fogbugz.com/f/cases/20074'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/22/2017 09:50'!script60495	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.144.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.52.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.15.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.192.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.101.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.6.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2510.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.173.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.615.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.49.mczPharoBootstrap-Initialization-TheIntegrator.4.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/22/2017 09:50'!update60495	"self new update60495"	self withUpdateLog: '20064 ClassTest>>#testMethodsReferencingClass uses non-existing BehaviorTests	https://pharo.fogbugz.com/f/cases/2006420074 Red-pane-of-death when sources file missing	https://pharo.fogbugz.com/f/cases/20074'.	self loadTogether: self script60495 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60494!ScriptLoader removeSelector: #script60494!"ScriptLoader60"!!SourceFileArray methodsFor: 'private' stamp: 'BenComan 5/21/2017 23:27' prior: 61198173!createReadOnlyFiles	| readOnly failed |		failed := false.	readOnly := files collect: [ :file | 		file 			ifNil: [  failed := true. nil ]			ifNotNil: [ [ file readOnlyCopy ]         		on: FileDoesNotExistException        		do: [ failed := true. nil ] ]	].	^ failed ifFalse: [ readOnly ] ifTrue: [ self closeFileArray: readOnly. nil ]! !"System-Sources"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.571.mcz') load.ScriptLoader new update60495.!----End fileIn----!----QUIT----2017-05-22T09:53:26.771406+02:00 Pharo.image priorSource: 20608!----QUIT----2017-05-22T09:53:36.987945+02:00 Pharo.image priorSource: 40350!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/23/2017 11:30' prior: 33575210!commentForCurrentUpdate ^ '20068 Change sources file name for bootstrapped image	https://pharo.fogbugz.com/f/cases/20068'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/23/2017 11:30'!script60496	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.144.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.52.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.15.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.192.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.101.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.6.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2510.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.173.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.615.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.49.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/23/2017 11:30'!update60496	"self new update60496"	self withUpdateLog: '20068 Change sources file name for bootstrapped image	https://pharo.fogbugz.com/f/cases/20068'.	self loadTogether: self script60496 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60495!ScriptLoader removeSelector: #script60495!"ScriptLoader60"!!PharoBootstrapInitialization class methodsFor: 'public api' stamp: 'PavelKrivanek 5/18/2017 15:54' prior: 54387033!initializeCommandLineHandlerAndErrorHandling	"This method is run before the new bootstrapped image is saved!!"	ProcessorScheduler initialize.		Delay initialize.	SmallInteger initialize.		ProcessorScheduler startUp.		OSPlatform startUp: true.		"2 following lines are used to initialize Unicode tag constants.	Must be replaced by an uptodate version of Unicode class>>#initializeTagConstants and a call to it"	#(#Cc #Cf #Co #Cs #Ll #Lm #Lo #Lt #Lu #Mc #Me #Mn #Nd #Nl #No #Pc #Pd #Pe #Pf #Pi #Po #Ps #Sc #Sk #Sm #So #Zl #Zp #Zs)			doWithIndex: [ :each :index | Unicode classPool at: each put: index ].Unicode classPool at: #Cn put: 0.	UnicodeDefinitions initializeUnicodeClass.	EncodedCharSet initialize.	String initialize.	ByteString initialize. "needed by TextConverter to install LineEnd convention (called by Smalltalk openLog)"	ZnUTF8Encoder initialize.			"Weak array class initialization 2 lines"	Smalltalk specialObjectsArray at: 42 put: Semaphore new."to put in EPObjectSpace>>#createSpecialObjectsArray?"	WeakArray restartFinalizationProcess.		DiskStore useFilePlugin "initialize".	FileStream initialize.	FileStream classVarNamed: 'TheStdioHandles' put: FileStream stdioHandles. "FileStream startup"	ByteTextConverter initialize.	MultiByteFileStream initialize.	ASTCache default: ASTCache new. "ASTCache initialize, neeeded to print stack on error"	FileLocator startUp: true. "FileLocator initialize"	Smalltalk globals 		at: #Transcript		put: (NonInteractiveTranscript stdout install).	CompilationContext initialize.	Float initialize.	ZipConstants initialize.	ZipWriteStream initialize.	"Initialize classes related to compiler"	InflateStream initialize.	ByteTextConverter initialize.	ZipWriteStream initialize.	SetElement initialize.	ExternalSemaphoreTable initialize.	MacRomanTextConverter initialize.	Collection initialize.	ISOLanguageDefinition initialize.	CompiledMethod initialize.	MD5NonPrimitive initialize.	DangerousClassNotifier initialize.	Categorizer initialize.	Slot initialize.	CP1252TextConverter initialize.	SHA1 initialize.	TraitBehavior initialize.	RPackage initialize.	CompilationContext initialize.	OCASTTranslator initialize.	UIManager classVarNamed: 'Default' put: NonInteractiveUIManager new.	UIManager default activate.	Smalltalk sourceFileVersionString: 'PharoV60'.	(Smalltalk class classVariableNamed: 'LastImagePath') value: Smalltalk imagePath. "set the default value"	SourceFiles := SourceFileArray new ensureOpen. "needed to get source from a compiled method, used to log an error."	Smalltalk openSourceFiles.		BasicCommandLineHandler new activate. "BasicCommandLineHandler startUp:"	Processor terminateActive.! !"PharoBootstrap-Initialization"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.572.mcz') load.ScriptLoader new update60496.!----End fileIn----!----QUIT----2017-05-23T11:33:20.381382+02:00 Pharo.image priorSource: 40428!----QUIT----2017-05-23T11:33:30.825145+02:00 Pharo.image priorSource: 62354!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/23/2017 15:34' prior: 33595030!commentForCurrentUpdate ^ '20084 Highlight Message Send is not enabled by default in bootstrapped/reloaded image	https://pharo.fogbugz.com/f/cases/2008420072 Importing Resource Help needs improvement	https://pharo.fogbugz.com/f/cases/2007219809 Failing test: WeakAnnouncerTest>>#testNoDeadWeakSubscriptions	https://pharo.fogbugz.com/f/cases/19809'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/23/2017 15:34'!script60497	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.144.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.15.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.192.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.101.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2510.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.173.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.615.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.49.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/23/2017 15:34'!update60497	"self new update60497"	self withUpdateLog: '20084 Highlight Message Send is not enabled by default in bootstrapped/reloaded image	https://pharo.fogbugz.com/f/cases/2008420072 Importing Resource Help needs improvement	https://pharo.fogbugz.com/f/cases/2007219809 Failing test: WeakAnnouncerTest>>#testNoDeadWeakSubscriptions	https://pharo.fogbugz.com/f/cases/19809'.	self loadTogether: self script60497 merge: false.	(SystemAnnouncer uniqueInstance subscriptions glmSubscriptions select: [:sub | sub subscriber isNil]) do: #finalize. 3 timesRepeat: [Smalltalk garbageCollect ].	self flushCaches.! !ScriptLoader removeSelector: #update60496!ScriptLoader removeSelector: #script60496!"ScriptLoader60"!!ImportingResourceHelp class methodsFor: 'documentation' stamp: 'AlexandreBergel 5/19/2017 15:40' prior: 29378986!encodingAndDecoding	^ HelpTopic 		title: 'Encoding and Decoding'		contents: (self heading: 'Encoding and Decoding'),'The basic mechanism to encode and decode data is provided by the class Base64MimeConverter. Consider the following example:mimeEncoded := ''Hello World'' asByteArray base64Encoded.(Base64MimeConverter mimeDecodeToBytes: mimeEncoded readStream) contents asStringThe variable mimeEncoded contains an encoding of the Hello World string using the mime64 encoding. The method #mimeDecodeToBytes: reads mime64 strings from a stream. The example uses a string, but it could refers to any objects. You essentially need a ReadStream. '! !!ImportingResourceHelp class methodsFor: 'documentation' stamp: 'AlexandreBergel 5/19/2017 15:48'!encodingAndDecodingImage	^ HelpTopic 		title: 'Encoding and Decoding Image'		contents: (self heading: 'Encoding and Decoding Image'),'Embedding pictures in plan source code is often the reason why one need to encode resources. The following script loads an image located in the filesystem, create a string-friendly representation, and store it in a method. You probably want to keep the image in a class variable or a hash table.',(self bold: 'form := PNGReadWriter formFromStream: ''/Users/alexandrebergel/Dropbox/Screenshots/Screenshot 2017-05-19 15.25.44.png'' asFileReference readStream."Write the stream on a stream"w := WriteStream on: ByteArray new.PNGReadWriter putForm: form onStream: w.w contents."Convert the byteArray into mime 64. It takes less space in the image"encodedContent := w contents base64Encoded."The following code converts the stream content "PNGReadWriter formFromStream: (Base64MimeConverter mimeDecodeToBytes: encodedContent readStream)."We encode the image as a method"Object compile: ''imageSource  ^ '''',  encodedContent, ''''.Object compile: ''image ^ PNGReadWriter formFromStream: (Base64MimeConverter mimeDecodeToBytes: self imageSource readStream). ''."A better implementation is to cache the image in an instance or class variable""The following expression return the image initially encoded"Object new image '),''! !!ImportingResourceHelp class methodsFor: 'documentation' stamp: 'AlexandreBergel 5/19/2017 15:39' prior: 29378243!overview	^ HelpTopic 		title: 'Overview'		contents: (self heading: 'Overview'),'Non trivial applications often rely on resources that may be externally provided such as icons, pictures, sounds. Such resources are typically defined as external files. Naturally, you can make your application depends on external files, however, importing resource files within the Pharo image and make it integrally part of you code has a number of advantages:- you can simply deploy your application by downloading it from smalltalkhub. - having less dependencies on external files is always good to avoid technical subtilities such as file path containing weird characters. '! !!ImportingResourceHelp class methodsFor: 'accessing' stamp: 'AlexandreBergel 5/19/2017 15:40' prior: 29380828!pages	^#(overview encodingAndDecoding encodingAndDecodingImage)! !!BaselineOfIDE methodsFor: 'actions' stamp: 'PavelKrivanek 5/23/2017 12:47' prior: 18109028!additionalInitialization	self class environment at: #GTGenericStackDebugger ifPresent: [	  Smalltalk tools register: GTGenericStackDebugger as: #debugger.	  Smalltalk tools registeredDebuggersWithRanks.	  Smalltalk tools debuggers add: ((self class environment at: #GTGenericStackDebugger)->3).	  Smalltalk tools debuggers add: ((self class environment at: #GTSUnitDebugger)->70).	  Smalltalk tools debuggers add: ((self class environment at: #GTBytecodeDebugger)->5).].	  	self class environment at: #GTPlayground ifPresent: [:playground | 	  Smalltalk tools register: playground as: #workspace.].	self class environment at: #GTInspector ifPresent: [:inspector | 	  Smalltalk tools register: inspector as: #inspector.].	  Smalltalk tools register: ExternalChangesBrowser as: #changeList.	Smalltalk tools register: FileList as: #fileList.	Smalltalk tools register: Finder as: #finder.	Smalltalk tools register: ProcessBrowser as: #processBrowser.	Smalltalk tools register: RecentMessageList as: #recentMessageList.	Smalltalk tools register: SyntaxErrorDebugger as: #syntaxErrorDebugger.	Smalltalk tools register: TimeProfiler as: #timeProfiler.	(MorphicCoreUIManager classPool at: #UIProcess) ifNotNil: [ :proc | proc terminate ].	MorphicCoreUIManager classPool at: #UIProcess put: nil.	PolymorphSystemSettings desktopColor:  Color veryVeryLightGray lighter.	SourceCodeFonts setSourceCodeFonts: 10.	FreeTypeSystemSettings loadFt2Library: true.	FreeTypeSettings current monitorType: #LCD.	FreeTypeSettings current glyphContrast: 55.		CatalogSettings displayCatalogProjectsInSpotter: false.	RealEstateAgent usedStrategy: #cascadeFor:initialExtent:world:.	GrowlMorph position: #bottomLeft.	ShortcutReminder enabled: true.	self class environment at: #QASettings ifPresent: [:qaSettings |	  qaSettings nautilusPlugin: true].	KMRepository reset.	Morph shortcutsHandler: KMShortcutHandler new.	"because of Komitter"	MCSaveVersionDialog previousMessages add: String new.	RBProgramNode formatterClass: BIConfigurableFormatter.	Color flushCache.	ASTTransformExamplePluginActive recompile.	PharoCommandLineHandler recompile.	SmalltalkImage recompile.		RubCharacterScanner initialize.		RubAbstractTextArea highlightMessageSend: true.		Pharo3DarkTheme beCurrent.		Smalltalk ui theme settings secondarySelectionColor: (Color r: 0.31 g: 0.31 b: 0.36 alpha: 1.0).		3 timesRepeat: [		Smalltalk garbageCollect.		Undeclared removeUnreferencedKeys.].		self loadIceberg.! !"BaselineOfIDE"!"ImportingResource-Help"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.573.mcz') load.ScriptLoader new update60497.!----End fileIn----!----QUIT----2017-05-23T15:38:14.333294+02:00 Pharo.image priorSource: 62432!----QUIT----2017-05-23T15:38:24.907147+02:00 Pharo.image priorSource: 87995!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/1/2017 15:55' prior: 33617034!commentForCurrentUpdate ^ '20095 SystemProgressMorph should call doOneCycleNow on refresh only when active process is UIProcess	https://pharo.fogbugz.com/f/cases/2009520099 Cairo fonts crashing on 64bits	https://pharo.fogbugz.com/f/cases/20099'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/1/2017 15:55'!script60498	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.15.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.192.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.101.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2510.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.173.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.49.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.181.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/1/2017 15:55'!update60498	"self new update60498"	self withUpdateLog: '20095 SystemProgressMorph should call doOneCycleNow on refresh only when active process is UIProcess	https://pharo.fogbugz.com/f/cases/2009520099 Cairo fonts crashing on 64bits	https://pharo.fogbugz.com/f/cases/20099'.	self loadTogether: self script60498 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60497!ScriptLoader removeSelector: #script60497!"ScriptLoader60"!!SystemProgressMorph methodsFor: 'updating' stamp: 'DenisKudryashov 5/30/2017 18:12' prior: 63149702!refresh	"We may be blocking the UI thread, and thus have to draw the world ourselves when necessary"	lastRefresh := Time millisecondClockValue.	UIManager default uiProcess == Processor activeProcess		ifTrue: [ self currentWorld doOneCycleNow]! !!CairoFontFace class methodsFor: 'instance creation' stamp: 'EstebanLorenzano 6/1/2017 12:10' prior: 18768599!fromFreetypeFace: aFace	| handle cairoFace |		handle := aFace handle pointerAt: 1. 	cairoFace := self primFtFace: handle loadFlags: ( LoadNoHinting | LoadTargetLCD | LoadNoAutohint | LoadNoBitmap). 		^ cairoFace initializeWithFreetypeFace: aFace! !!CairoFontFace class methodsFor: 'instance creation' stamp: 'EstebanLorenzano 6/1/2017 12:10' prior: 18768082!primFtFace: aFace loadFlags: flags"cairo_font_face_t * cairo_ft_font_face_create_for_ft_face                                                        (FT_Face face,                                                         int load_flags);"	<primitive: #primitiveNativeCall module: #NativeBoostPlugin error: errorCode>		^ self nbCall: #( CairoFontFace cairo_ft_font_face_create_for_ft_face(void * aFace , int flags )) ! !!CairoScaledFont class methodsFor: 'instance creation' stamp: 'EstebanLorenzano 6/1/2017 12:09' prior: 18799108!fromFreetypeFont: aFont	| ftFace face |	^ CairoBackendCache soleInstance at: aFont ifAbsentPut: [ | emphasis |			emphasis := aFont simulatedEmphasis.			ftFace := aFont face.			face := CairoBackendCache soleInstance 				at: {ftFace.	emphasis} 				ifAbsentPut: [ | cff |					cff := CairoFontFace fromFreetypeFace: ftFace.					emphasis ifNotNil: [ cff synthesizeEmphasis: emphasis ].					cff ].			self fromFreetypeFont: aFont cairoFace: face ]! !!AthensCairoMatrix class methodsFor: 'field definition' stamp: 'EstebanLorenzano 6/1/2017 15:34' prior: 17537657!fieldsDesc	"self rebuildFieldAccessors"	^ #(   double sx; double shx;   double shy; double sy;   double x; double y;	)! !!SystemProgressItemMorph methodsFor: 'private' stamp: 'DenisKudryashov 5/30/2017 18:12' prior: 63145033!refresh	lastRefresh := Time millisecondClockValue.	UIManager default uiProcess == Processor activeProcess		ifTrue: [ self currentWorld doOneCycleNow ]! !"Athens-Cairo"!"Morphic-Base"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.574.mcz') load.ScriptLoader new update60498.!----End fileIn----!----QUIT----2017-06-01T15:57:07.284048+02:00 Pharo.image priorSource: 88073!----QUIT----2017-06-01T15:57:17.746509+02:00 Pharo.image priorSource: 109737!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/6/2017 15:11' prior: 33642674!commentForCurrentUpdate ^ '20102 SmallInteger>>#digitAt: not ready for 64-bit - Some Kernel-Tests-Numbers fail to take 64-bit into account	https://pharo.fogbugz.com/f/cases/2010220070 terminal color not reset after a error message	https://pharo.fogbugz.com/f/cases/2007019949 ensureEndsWith: does not handle start of stream case	https://pharo.fogbugz.com/f/cases/1994920101 Typos and general writing of release welcome text	https://pharo.fogbugz.com/f/cases/20101'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/6/2017 15:11'!script60499	^ 'AST-Core-TheIntegrator.494.mczAST-Tests-Core-TheIntegrator.134.mczAlien-RonieSalgado.40.mczAnnouncements-Core-TheIntegrator.84.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.39.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-TheIntegrator.147.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-AliakseiSyrel.57.mczAthens-Examples-TheIntegrator.47.mczAthens-Morphic-TheIntegrator.69.mczAthens-Text-HenrikNergaard.17.mczBalloon-TheIntegrator.139.mczBalloon-Tests-TheIntegrator.2.mczBaselineOfBasicTools-TheIntegrator.8.mczBaselineOfDisplay-TheIntegrator.4.mczBaselineOfIDE-TheIntegrator.55.mczBaselineOfIceberg-cypress.1.mczBaselineOfLibGit-cypress.1.mczBaselineOfMetacello-EstebanLorenzano.89.mczBaselineOfMorphic-TheIntegrator.34.mczBaselineOfMorphicCore-TheIntegrator.7.mczBaselineOfPharoBootstrap-TheIntegrator.4.mczBaselineOfSUnit-TheIntegrator.4.mczBaselineOfUI-TheIntegrator.11.mczBaselineOfUnifiedFFI-TheIntegrator.4.mczBlueInk-Core-TheIntegrator.29.mczBlueInk-Extras-TheIntegrator.12.mczBlueInk-Tests-TheIntegrator.12.mczCodeExport-TheIntegrator.21.mczCodeImport-TheIntegrator.90.mczCodeImportCommandLineHandlers-TheIntegrator.17.mczCollections-Abstract-TheIntegrator.345.mczCollections-Arithmetic-TheIntegrator.22.mczCollections-Atomic-TheIntegrator.16.mczCollections-DoubleLinkedList-TheIntegrator.2.mczCollections-DoubleLinkedListTests-TheIntegrator.2.mczCollections-Native-TheIntegrator.19.mczCollections-Sequenceable-TheIntegrator.261.mczCollections-Stack-TheIntegrator.10.mczCollections-Streams-TheIntegrator.194.mczCollections-Strings-TheIntegrator.449.mczCollections-Support-TheIntegrator.67.mczCollections-Tests-TheIntegrator.103.mczCollections-Unordered-TheIntegrator.248.mczCollections-Weak-TheIntegrator.108.mczColors-TheIntegrator.3.mczCompiler-TheIntegrator.608.mczCompression-TheIntegrator.182.mczCompression-Tests-TheIntegrator.7.mczConfigurationCommandLineHandler-Core-TheIntegrator.29.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczContributingToTheCatalogHelp-TheIntegrator.9.mczDebugger-Tests-TheIntegrator.6.mczDebuggerActions-TheIntegrator.92.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.130.mczDeprecated60-TheIntegrator.22.mczEmbeddedFreeType-TheIntegrator.30.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-TheIntegrator.35.mczEpicea-TheIntegrator.858.mczEpiceaBrowsers-MartinDias.180.mczEpiceaBrowsersTests-MartinDias.32.mczEpiceaTests-MartinDias.25.mczFFI-Kernel-EstebanLorenzano.45.mczFFI-Pools-TheIntegrator.5.mczFileSystem-Core-TheIntegrator.222.mczFileSystem-Disk-TheIntegrator.110.mczFileSystem-Memory-TheIntegrator.63.mczFileSystem-Tests-Core-TheIntegrator.103.mczFileSystem-Tests-Disk-StephaneDucasse.25.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.19.mczFiles-TheIntegrator.428.mczFiles-Tests-TheIntegrator.12.mczFlashback-Decompiler-EstebanLorenzano.21.mczFlashback-Decompiler-Tests-TheIntegrator.97.mczFontChooser-TheIntegrator.24.mczFontInfrastructure-TheIntegrator.18.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.756.mczFreeType-Tests-TheIntegrator.2.mczFuel-MartinDias.826.mczFuelCommandLineHandler-TheIntegrator.25.mczFuelPlatform-Core-MaxLeske.2.mczFuelPlatform-Pharo-06-MaxLeske.2.mczFuelPlatform-Pharo-Core-MaxLeske.1.mczFuelSystem-FileRegistry-TheIntegrator.4.mczFuelTests-MaxLeske.415.mczFuelTools-Debugger-MaxLeske.14.mczFuzzyMatcher-TheIntegrator.20.mczFuzzyMatcher-Tests-TheIntegrator.8.mczGT-BytecodeDebugger-AndreiChis.36.mczGT-Debugger-TheIntegrator.383.mczGT-EventRecorder-TheIntegrator.81.mczGT-EventRecorder-Tests-TheIntegrator.42.mczGT-Inspector-TheIntegrator.468.mczGT-InspectorExtensions-Core-AndreiChis.259.mczGT-Playground-TheIntegrator.148.mczGT-SUnitDebugger-TudorGirba.39.mczGT-Spotter-AliakseiSyrel.412.mczGT-Spotter-EventRecorder-AndreiChis.114.mczGT-SpotterExtensions-Core-TheIntegrator.224.mczGT-Tests-Debugger-AndreiChis.14.mczGT-Tests-Inspector-AndreiChis.60.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-AndreiChis.31.mczGeneralRules-TheIntegrator.11.mczGlamour-Announcements-AndreiChis.11.mczGlamour-Browsers-AndreiChis.112.mczGlamour-Core-AndreiChis.338.mczGlamour-Examples-TheIntegrator.321.mczGlamour-FastTable-TheIntegrator.85.mczGlamour-Helpers-TudorGirba.40.mczGlamour-Morphic-Brick-TheIntegrator.448.mczGlamour-Morphic-Brick-Tests-TheIntegrator.16.mczGlamour-Morphic-Pager-AndreiChis.114.mczGlamour-Morphic-Renderer-AndreiChis.361.mczGlamour-Morphic-Theme-TheIntegrator.233.mczGlamour-Morphic-Widgets-TheIntegrator.209.mczGlamour-Presentations-AndreiChis.190.mczGlamour-Rubric-Presentations-AndreiChis.61.mczGlamour-SpecIntegration-TheIntegrator.6.mczGlamour-Tests-Core-TheIntegrator.115.mczGlamour-Tests-Morphic-TheIntegrator.140.mczGlamour-Tests-Resources-AndreiChis.5.mczGlamour-Tests-Rubric-AndreiChis.36.mczGofer-Core-TheIntegrator.237.mczGofer-Tests-TheIntegrator.164.mczGofer-UI-TheIntegrator.2.mczGraphics-Canvas-TheIntegrator.14.mczGraphics-Display Objects-TheIntegrator.188.mczGraphics-Files-TheIntegrator.78.mczGraphics-Fonts-TheIntegrator.109.mczGraphics-Primitives-TheIntegrator.203.mczGraphics-Shapes-TheIntegrator.4.mczGraphics-Tests-TheIntegrator.85.mczGraphics-Transformations-TheIntegrator.17.mczGrowl-TheIntegrator.47.mczHelpSystem-Core-TheIntegrator.178.mczHelpSystem-Tests-TheIntegrator.32.mczHiedra-MartinDias.146.mczHiedraTests-MartinDias.2.mczHowToContributeHelp-TheIntegrator.4.mczHudsonBuildTools20-TheIntegrator.100.mczIceberg-cypress.1.mczIceberg-Libgit-cypress.1.mczIceberg-Metacello-Integration-cypress.1.mczIceberg-Plugin-cypress.1.mczIceberg-UI-cypress.1.mczImportingResource-Help-TheIntegrator.8.mczIssueTracking-TheIntegrator.6.mczIssueTracking-Tests-TheIntegrator.3.mczJobs-TheIntegrator.30.mczJobsTests-TheIntegrator.2.mczKernel-TheIntegrator.2513.mczKernel-Rules-TheIntegrator.13.mczKernel-Tests-TheIntegrator.175.mczKernel-Tests-Rules-TheIntegrator.5.mczKeymapping-Core-TheIntegrator.204.mczKeymapping-KeyCombinations-TheIntegrator.66.mczKeymapping-Pragmas-TheIntegrator.62.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.111.mczKeymapping-Tools-Spec-TheIntegrator.32.mczKomitter-TheIntegrator.192.mczLibGit-Core-cypress.1.mczManifest-Core-TheIntegrator.252.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.55.mczMenuRegistration-TheIntegrator.93.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.126.mczMetacello-Bitbucket-EstebanLorenzano.8.mczMetacello-Core-TheIntegrator.838.mczMetacello-FileTree-EstebanLorenzano.38.mczMetacello-GitBasedRepository-TheIntegrator.24.mczMetacello-GitHub-TheIntegrator.56.mczMetacello-MC-TheIntegrator.741.mczMetacello-PharoCommonPlatform-TheIntegrator.26.mczMetacello-Platform-TheIntegrator.5.mczMetacello-ProfStef-TheIntegrator.22.mczMetacello-Reference-EstebanLorenzano.38.mczMetacello-TestsCommonMC-TheIntegrator.9.mczMetacello-TestsCore-EstebanLorenzano.41.mczMetacello-TestsMC-EstebanLorenzano.405.mczMetacello-TestsMCCore-EstebanLorenzano.8.mczMetacello-TestsMCResources-EstebanLorenzano.33.mczMetacello-TestsPlatform-TheIntegrator.25.mczMetacello-TestsReference-EstebanLorenzano.22.mczMetacello-ToolBox-TheIntegrator.154.mczMetacello-Tutorial-EstebanLorenzano.28.mczMonticello-TheIntegrator.1178.mczMonticello-OldDataStreamCompatibility-TheIntegrator.11.mczMonticello-Tests-TheIntegrator.43.mczMonticelloConfigurations-TheIntegrator.75.mczMonticelloFileServices-TheIntegrator.9.mczMonticelloFileTree-Core-TheIntegrator.152.mczMonticelloFileTree-FileSystem-Utilities-TheIntegrator.34.mczMonticelloGUI-TheIntegrator.437.mczMonticelloMocks-TheIntegrator.9.mczMonticelloRemoteRepositories-TheIntegrator.19.mczMoose-Algos-Graph-VincentBlondeau.33.mczMorphic-Base-TheIntegrator.618.mczMorphic-Core-TheIntegrator.313.mczMorphic-Examples-TheIntegrator.64.mczMorphic-Tests-TheIntegrator.13.mczMorphic-Widgets-Basic-TheIntegrator.110.mczMorphic-Widgets-ColorPicker-TheIntegrator.23.mczMorphic-Widgets-Extra-TheIntegrator.30.mczMorphic-Widgets-FastTable-TheIntegrator.222.mczMorphic-Widgets-List-TheIntegrator.23.mczMorphic-Widgets-Pluggable-TheIntegrator.79.mczMorphic-Widgets-PolyTabs-TheIntegrator.8.mczMorphic-Widgets-Scrolling-TheIntegrator.37.mczMorphic-Widgets-Tabs-TheIntegrator.54.mczMorphic-Widgets-Taskbar-TheIntegrator.27.mczMorphic-Widgets-TickList-TheIntegrator.2.mczMorphic-Widgets-Tree-TheIntegrator.66.mczMorphic-Widgets-Windows-TheIntegrator.117.mczMultilingual-Encodings-TheIntegrator.63.mczMultilingual-Languages-TheIntegrator.59.mczMultilingual-OtherLanguages-TheIntegrator.22.mczMultilingual-Tests-TheIntegrator.46.mczMultilingual-TextConversion-TheIntegrator.83.mczMultilingual-TextConverterOtherLanguages-TheIntegrator.4.mczNECompletion-TheIntegrator.257.mczNECompletion-Tests-TheIntegrator.10.mczNautilus-TheIntegrator.1366.mczNautilus-GroupManager-TheIntegrator.24.mczNautilus-GroupManagerUI-TheIntegrator.44.mczNautilus-Tests-TheIntegrator.52.mczNautilusCommon-TheIntegrator.327.mczNautilusGroupAutoBuilder-TheIntegrator.20.mczNautilusRefactoring-TheIntegrator.315.mczNetwork-Kernel-TheIntegrator.138.mczNetwork-MIME-TheIntegrator.75.mczNetwork-Mail-TheIntegrator.52.mczNetwork-Protocols-TheIntegrator.105.mczNetwork-Tests-TheIntegrator.28.mczNetwork-UUID-TheIntegrator.64.mczNetwork-Url-TheIntegrator.103.mczNewValueHolder-TheIntegrator.35.mczNodeNavigation-TheIntegrator.57.mczNodeNavigation-Tests-TheIntegrator.3.mczNonInteractiveTranscript-TheIntegrator.25.mczOSWindow-Core-TheIntegrator.125.mczOSWindow-SDL2-TheIntegrator.110.mczOSWindow-SDL2-Examples-TheIntegrator.16.mczOSWindow-Tests-RonieSalgado.3.mczOSWindow-VM-MerwanOuddane.4.mczOmbu-MartinDias.277.mczOmbuTests-MartinDias.33.mczOpalCompiler-Core-TheIntegrator.890.mczOpalCompiler-Tests-TheIntegrator.380.mczOpalTools-TheIntegrator.24.mczPharo-Help-TheIntegrator.52.mczPharoBootstrap-Initialization-TheIntegrator.7.mczPharoDocComment-StephaneDucasse.6.mczPolymorph-Widgets-TheIntegrator.1435.mczPolymorph-Widgets-Rules-TheIntegrator.11.mczPragmaCollector-TheIntegrator.18.mczProfStef-Core-TheIntegrator.85.mczProfStef-Help-TheIntegrator.18.mczProfStef-Tests-TheIntegrator.27.mczQualityAssistant-YuriyTymchuk.117.mczQualityAssistant-Test-YuriyTymchuk.2.mczQualityAssistantRecording-Uko.28.mczRPackage-Core-TheIntegrator.470.mczRPackage-Tests-TheIntegrator.199.mczRandom-Core-TheIntegrator.10.mczRandom-Tests-TheIntegrator.6.mczRecentSubmissions-TheIntegrator.246.mczRefactoring-Changes-TheIntegrator.70.mczRefactoring-Core-TheIntegrator.345.mczRefactoring-Critics-TheIntegrator.300.mczRefactoring-Environment-TheIntegrator.88.mczRefactoring-Help-TheIntegrator.7.mczRefactoring-Tests-Changes-TheIntegrator.40.mczRefactoring-Tests-Core-TheIntegrator.147.mczRefactoring-Tests-Critics-TheIntegrator.54.mczRefactoring-Tests-Environment-TheIntegrator.30.mczReflectionMirrors-Primitives-TheIntegrator.9.mczReflectionMirrors-Primitives-Tests-TheIntegrator.6.mczReflectivity-TheIntegrator.339.mczReflectivity-Examples-TheIntegrator.51.mczReflectivity-Tests-TheIntegrator.228.mczReflectivity-Tools-TheIntegrator.79.mczReflectivity-Tools-Tests-TheIntegrator.32.mczRegex-Core-TheIntegrator.40.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-TheIntegrator.11.mczReleaseTests-TheIntegrator.33.mczRenraku-YuriyTymchuk.150.mczRenraku-Help-YuriyTymchuk.3.mczRenraku-Test-YuriyTymchuk.23.mczRing-Core-Containers-TheIntegrator.45.mczRing-Core-Kernel-TheIntegrator.248.mczRing-Monticello-TheIntegrator.43.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.95.mczRing-Tests-Monticello-MarcusDenker.19.mczRingChunkImporter-TheIntegrator.8.mczRubric-TheIntegrator.448.mczRubric-Rules-TheIntegrator.6.mczRubric-Styling-TheIntegrator.11.mczRubric-Tests-TheIntegrator.10.mczSTON-Core-TheIntegrator.86.mczSTON-Tests-TheIntegrator.77.mczSTON-Text support-TheIntegrator.2.mczSUnit-Core-TheIntegrator.221.mczSUnit-Help-MarcusDenker.9.mczSUnit-Rules-TheIntegrator.5.mczSUnit-Tests-TheIntegrator.68.mczSUnit-UI-TheIntegrator.153.mczSUnit-UITesting-TheIntegrator.36.mczScriptLoader-Tests-TheIntegrator.4.mczScriptingExtensions-TheIntegrator.6.mczScriptingExtensions-Tests-TheIntegrator.3.mczSettings-Graphics-TheIntegrator.34.mczSettings-Polymorph-TheIntegrator.98.mczSettings-System-TheIntegrator.43.mczShoreLine-Report-Core-TommasoDalSasso.11.mczShoreLine-Report-Settings-TheIntegrator.7.mczShoreLine-Report-UI-TheIntegrator.19.mczShout-TheIntegrator.313.mczShout-Tests-TheIntegrator.2.mczSlot-TheIntegrator.790.mczSlot-Tests-TheIntegrator.105.mczSmartSuggestions-TheIntegrator.269.mczSmartSuggestions-Tests-TheIntegrator.39.mczSortFunctions-Core-TheIntegrator.7.mczSortFunctions-Tests-TheIntegrator.6.mczSpec-Core-TheIntegrator.541.mczSpec-Debugger-TheIntegrator.284.mczSpec-Examples-TheIntegrator.133.mczSpec-Help-TheIntegrator.13.mczSpec-Inspector-TheIntegrator.289.mczSpec-Layout-TheIntegrator.75.mczSpec-MorphicAdapters-TheIntegrator.292.mczSpec-PolyWidgets-TheIntegrator.93.mczSpec-Tests-TheIntegrator.107.mczSpec-Tools-TheIntegrator.386.mczStartupPreferences-TheIntegrator.153.mczSystem-Announcements-TheIntegrator.138.mczSystem-BasicCommandLineHandler-TheIntegrator.21.mczSystem-Caching-TheIntegrator.29.mczSystem-CachingTests-TheIntegrator.19.mczSystem-Changes-TheIntegrator.309.mczSystem-Changes-FileServices-TheIntegrator.4.mczSystem-Clipboard-TheIntegrator.42.mczSystem-CommandLine-TheIntegrator.183.mczSystem-CommandLine-TextSupport-TheIntegrator.6.mczSystem-CommandLineHandler-TheIntegrator.26.mczSystem-FileRegistry-TheIntegrator.53.mczSystem-Finalization-TheIntegrator.44.mczSystem-Hashing-TheIntegrator.52.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Identification-TheIntegrator.9.mczSystem-Identification-Tests-TheIntegrator.2.mczSystem-Installers-TheIntegrator.44.mczSystem-Localization-TheIntegrator.108.mczSystem-Localization-Tests-TheIntegrator.8.mczSystem-Model-TheIntegrator.13.mczSystem-OSEnvironments-TheIntegrator.40.mczSystem-Object Events-TheIntegrator.28.mczSystem-Platforms-TheIntegrator.85.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-SessionManager-TheIntegrator.43.mczSystem-SessionManager-Tests-ChristopheDemarey.9.mczSystem-Settings-TheIntegrator.374.mczSystem-Settings-Rules-TheIntegrator.2.mczSystem-Settings-Tests-TheIntegrator.15.mczSystem-Sound-TheIntegrator.20.mczSystem-Sources-TheIntegrator.73.mczSystem-Support-TheIntegrator.1276.mczSystem-Support-Rules-TheIntegrator.2.mczSystem-SupportTests-TheIntegrator.7.mczSystem-VMEvents-TheIntegrator.19.mczTests-TheIntegrator.794.mczText-Core-TheIntegrator.66.mczText-Diff-TheIntegrator.6.mczText-Edition-TheIntegrator.128.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.33.mczText-Tests-TheIntegrator.10.mczTool-Base-TheIntegrator.195.mczTool-Catalog-TheIntegrator.61.mczTool-CriticBrowser-TheIntegrator.67.mczTool-DependencyAnalyser-ChristopheDemarey.31.mczTool-DependencyAnalyser-Test-TheIntegrator.18.mczTool-DependencyAnalyser-Test-Data-ChristopheDemarey.2.mczTool-DependencyAnalyser-UI-ChristopheDemarey.54.mczTool-Diff-TheIntegrator.52.mczTool-ExternalBrowser-TheIntegrator.59.mczTool-FileList-TheIntegrator.99.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-Finder-TheIntegrator.78.mczTool-ImageCleaner-TheIntegrator.19.mczTool-ProcessBrowser-TheIntegrator.27.mczTool-Profilers-TheIntegrator.37.mczTool-SystemReporter-TheIntegrator.19.mczTool-Transcript-TheIntegrator.25.mczTool-Workspace-TheIntegrator.48.mczTools-TheIntegrator.1532.mczTools-Test-TheIntegrator.26.mczTraits-TheIntegrator.988.mczTranscript-TheIntegrator.56.mczTravisIntegrationHelp-TheIntegrator.8.mczTxText-Athens-EstebanLorenzano.58.mczTxText-AthensTests-HenrikNergaard.13.mczTxText-Model-MarcusDenker.67.mczTxText-Styler-HenrikNergaard.18.mczTxTextTests-Model-SeanDeNigris.29.mczUIManager-TheIntegrator.195.mczUnicode-Initialization-TheIntegrator.17.mczUnifiedFFI-TheIntegrator.109.mczUnifiedFFI-Legacy-TheIntegrator.4.mczUnifiedFFI-Tests-TheIntegrator.42.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczVersionner-Commit-TheIntegrator.34.mczVersionner-Core-Announcements-ChristopheDemarey.6.mczVersionner-Core-Commands-MarcusDenker.65.mczVersionner-Core-DependenciesModel-MarcusDenker.106.mczVersionner-Core-Model-PabloTesone.57.mczVersionner-Nautilus-PavelKrivanek.1.mczVersionner-Spec-Browser-PabloTesone.212.mczVersionner-Tests-Core-Commands-MarcusDenker.21.mczVersionner-Tests-Core-DependenciesModel-ChristopheDemarey.46.mczVersionner-Tests-Core-Model-TheIntegrator.36.mczVersionner-Tests-Resources-MarcusDenker.18.mczWorldMenuHelp-TheIntegrator.2.mczWriteBarrierTests-TheIntegrator.20.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.46.mczZinc-Character-Encoding-Tests-TheIntegrator.31.mczZinc-FileSystem-TheIntegrator.15.mczZinc-HTTP-TheIntegrator.459.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.61.mczZinc-Resource-Meta-FileSystem-SvenVanCaekenberghe.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.37.mczZinc-Tests-SvenVanCaekenberghe.238.mczZinc-Zodiac-TheIntegrator.38.mczZodiac-Core-TheIntegrator.46.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-TheIntegrator.17.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/6/2017 15:11'!update60499	"self new update60499"	self withUpdateLog: '20102 SmallInteger>>#digitAt: not ready for 64-bit - Some Kernel-Tests-Numbers fail to take 64-bit into account	https://pharo.fogbugz.com/f/cases/2010220070 terminal color not reset after a error message	https://pharo.fogbugz.com/f/cases/2007019949 ensureEndsWith: does not handle start of stream case	https://pharo.fogbugz.com/f/cases/1994920101 Typos and general writing of release welcome text	https://pharo.fogbugz.com/f/cases/20101'.	self loadTogether: self script60499 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update60498!ScriptLoader removeSelector: #script60498!"ScriptLoader60"!!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 18:10' prior: 84508630!changeLog	^ HelpTopic 		title: 'ChangeLog'		contents: (self heading: 'Highlights (aka New Stuff) in Pharo 6.0'),'- The PharoVM and image are also provided in a 64-bit version in Linux and macOS/OSX and bring even better performance and stability- A new code changes management system named Epicea for reviewing and recovering of your code easily- Integrated support for Git through an easy-to-use tool for repositories and commits management named Iceberg (as a preview in Pharo 6, it will be the default in Pharo 7)- The unified foreign function interface (UnifiedFFI) for interfacing with the outside world is significantly improved- The PharoVM is now part of OpenSmalltalk initiative- Introduction of object immutability, alternative bytecode sets and block closures independent of outer context- Pharo can now be bootstrapped from source code managed by Git- Pharo modularity is improved- Pharo is faster- The Dark Theme was improved and set as default color theme of Pharo', (self heading: 'All Issues'), 'Over 1400 fixes and enhancements were integrated in this release.As the complete list of fixed issues is too large to be placed here, you can review it on the FogBugz issue tracker (', (self url: 'https://pharo.fogbugz.com'), ') (requires account).', (self subheading: 'Tools'),'- Epicea provides a code changes manager- Iceberg provides a Git repositories manager- GTInspector, GTDebugger and other tools are now based on FastTable (long lists of items are rendered much faster)- GToolkit and GTools have been updated- Quality Assistant has been improved- Interrupt key (Cmd+ /, Ctrl+.) has been made more reliable- Playground variables are now visible from debugger- Debugger temp names mapping is fixed- There is a "Close all debuggers"  in the taskbar context menu- GTDebugger has a "Run to here" feature- Results and critiques can be filtered in the MessageBrowser- Dependency Analyzer has been improved- Nautilus enhancements        - Splitting of large variable entries in the Variables menu        - Deprecated methods are shown with strikethrough emphasis        - Abstract classes are shown in italics with a slight color adjustment', (self subheading: 'VM related'), '- 64-bits support- Improvement of host platforms management (32-bit/64-bit)- Improved UnifiedFFI- The PharoVM is now part of OpenSmalltalk initiative- Introduction of object immutability- Introduction of FullBlockClosure which will help in future evolutions of Pharo- Ephemerons support, introduction of the EphemeronRegistry- Support of alternative bytecode sets and introduction of Sista Encoder, the encoder for the SistaV1 bytecode set. This will be the bedrock on which Pharo will improve',(self subheading: 'Reflectivity'), '- General improvements- haltOnce is active by default per method. It does not require global turning on (enable haltOnce) and it is managed from the source code area in Nautilus- Execution counter for message nodes in the source code area in Nautilus- API for Metalinks on AST nodes- Mirror primitives (Those are reflection primitives which access object state without messaging them, see MirrorPrimitives class)- Inlined method const can be implemented by Metalinks', (self subheading: 'Other'), '- Dark Theme improvements- Improvement of theme change while windows are open- Support of two double quotes inside comments- Standalone Morphic worlds in separate windows- Fix of several memory leaks- Improvement of working directory structure (introduction of a ''pharo-local'' directory to include Pharo directories such as ''package-cache'')- Better autocategorization of methods- Introduction of a FuzzyMatcher for approximate string matching- Glamour integration in Spec- Renaming (Cmd+R / Ctrl+R) in Nautilus supports more AST nodes- anObject asMethodConst to cache expressions dynamically- GlobalIdentifier for computer identification- NeoUUIDGenerator replaces the old UUIDGenerator- STON was improved and is now used by Monticello FileTree- Storage of suspended announcements- Improved newAnonymousSubclass- Inheritable process specific variables- Fuel improvements- Enablement of <example> methods so that they can be executed easily- Support for <sampleInstance>- New class and method API for tags as replacement for categories and protocols- TabMorph improvements- Unification of Dictionary APIs (including an OrderedDictionary)- Package manifests improvements- Improvement of RadioButton groups', (self subheading: 'Cleanups'), '- Object>>#name is now deprecated and will be removed in Pharo 7- Better system modularization- Ability for the system to be fully bootstrapped from source code- Turn off of catalog search in Spotter by default (This improves the stability of Pharo when used with poor Internet connections)- Removal of Chroma-CubeHelix and TxWorkspace- Rename of Pragma>>#selector to Pragma>>#methodSelector- Improvement of icons management (#iconNamed: introduced in order to replace DNU-based icons)- Limit use of #asClass in order to rely on an environment- It is now possible to give a rewrite rule when deprecating a method to automatically rewrite code with deprecation (#deprecated:transformWith:)- Deprecation of the following:        Object>>name        ShortRunArray class        Object>>confirm:orCancel:        Object>>ifNil:ifNotNilDo:        Object>>ifNotNilDo:        Object>>ifNotNilDo:ifNil:        Collection>>ifEmpty:ifNotEmptyDo:        Collection>>ifNotEmptyDo:        Collection>>ifNotEmptyDo:ifEmpty:        SequenceableCollection>>copyLast:        Integer>>asBytesDescription        Pragma>>method:', (self subheading: 'Unit testing/Documentation'), '- RecursionStopper provides an easy way to check if we are in a recursion and execute code just once in a recursion- New process specific variable ''CurrentExecutionEnvironment'' with value DefaultExecutionEnvironment by default and TestExecutionEnvironment during a test run- SUnit is improved by introducing a time limit for tests, preventing "forked debuggers"- New assert extension to compare floats with #closeTo:- More class comments and documentation', (self subheading: 'Network'), '- Support Server Name Indication (SNI) in Zodiac/SSLPlugin- Zinc/Zodiac updateYou can see the Pharo 6.0 changelog at: ', (self url: 'https://github.com/pharo-project/pharo-changelogs/blob/master/Pharo60ChangeLogs.md')! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 17:54' prior: 84516114!documentation	^ HelpTopic 		title: 'More Documentation'		contents: (self heading: 'More Documentation'), 			'The most important documentation is the one you can get by exploring the system, reading class comments and looking for examples. You can find "in image" help by clicking on the following expression:', (self doItFrom: 'HelpBrowser open.'), 'This browser is also accessible from the World>Help>Help Browser menu (just click the desktop, select Help, and then Help Browser).A compendium of Pharo documentation can be found at: ', (self url: 'http://pharo.org/documentation'), 'There you can find:- Pharo books: ', (self url: 'http://books.pharo.org'), '- Screencasts: ', (self url: 'https://www.youtube.com/channel/UCp3mNigANqkesFzdm058bvw'), '- Presentations: ', (self url: 'http://www.slideshare.net/pharoproject/')! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 17:54' prior: 84519806!exploreEnvironment	^ HelpTopic 		title: 'Explore the Pharo Environment'		contents: (self heading: 'Explore the Pharo Environment'), 				'The best way to learn Pharo is to explore it by yourself. This is live objects all the way down: they can be inspected, browsed, changed... everything in the environment you have in your hands.But sometimes it can be hard to get started with the tools and capabilities the environment provides.The most complete and updated guide for the Pharo environment can be found in the "Updated Pharo by Example" free book. It is still a work in progress, but most of it is already done. You can find the book here: ', (self url: 'https://github.com/SquareBracketAssociates/UpdatedPharoByExample'), 'One chapter of particular interest is the one that provides a quick tour of the environment: ', (self url: 'https://ci.inria.fr/pharo-contribution/job/UpdatedPharoByExample/lastSuccessfulBuild/artifact/book-result/PharoTour/PharoTour.pdf')! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 17:55' prior: 84515442!gettingHelp	^ HelpTopic 		title: 'Getting Help'		contents: (self heading: 'Getting Help'),		'Pharo has a vibrant community that shares knowledge in different ways: - The "Pharo Users" mailing list: 	', (self url: 'http://lists.pharo.org/mailman/listinfo/pharo-users_lists.pharo.org'), '- The "Pharo Discord channel": 	', 	(self url: 'http://discord.gg/Sj2rhxn'), '- The "Pharo IRC Channel": 	', (self url: 'irc.freenode.net, #pharo channel '), 'You can find more information, lists to browse/suscribe and places to share code at: ', (self url: 'http://pharo.org/community')! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 18:11' prior: 84518270!learn	^ HelpTopic 		title: 'Learn Pharo'		contents: (self heading: 'Learn Pharo'), 		'You can learn Pharo by clicking on the following expression: 	', (self doItFrom: 'ProfStef go.'), (self subheading: 'MOOC'), 'Pharo has an excellent MOOC (Massive Open Online Course). You can find more information here: ', (self url: 'http://mooc.pharo.org'), (self subheading: 'Books'), 'There are several free Pharo books that can be download here: ', (self url: 'http://books.pharo.org'), 'A very interesting starting point would be looking into the "Updated Pharo by Example" free book. It is still a work in progress, but most of it is already done. You can find the book here: ', (self url: 'https://github.com/SquareBracketAssociates/UpdatedPharoByExample'), ''! !!WelcomeHelp class methodsFor: 'showing' stamp: 'PhilippeBack 6/1/2017 17:23' prior: 84517046!open	<script>	^ (HelpBrowser openOn: self) next! !!WelcomeHelp class methodsFor: 'showing' stamp: 'PhilippeBack 6/1/2017 17:24' prior: 84515001!openForRelease	<script>	| browser window findBlock |		findBlock := [ :each | (each isKindOf: SystemWindow) and: [ each label = self bookName ] ]. 	World submorphs 		detect: findBlock 		ifFound: [ :oldWindow | oldWindow delete ].	browser := self open.	window := browser dependents detect: findBlock.	window extent: 700@400.	window center: Display extent / 2! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 18:13' prior: 84517171!useExternalPackages	^ HelpTopic 		title: 'Using Eternal Packages'		contents: (self heading: 'Using External Packages'), 'Pharo already comes pre-loaded with a rich set of packages that you can use to explore the system and develop your own applications. However there is also a huge library of user contributed projects that you can also load using the "Catalog Browser". To open it click on the following expression:		', (self doItFrom: 'CatalogBrowser open.'), 'This browser is also accessible from the World>Tools>Catalog Browser menu (just click the desktop, select Tools, and then Catalog Browser).Catalog projects can be browsed online: ', (self url: 'http://catalog.pharo.org'), 'You can also a rough list (not very friendly) of many packages available stored in smalltalkhub repository:', (self url: 'http://smalltalkhub.com/list'), '(this list is not a compendium of packages for Pharo but is a good place to start looking for something in particular and which happens to not be present in the catalog).The catalog can be enabled in Spotter by enabling the "Display catalog projects in Spotter" system preference.'! !!WelcomeHelp class methodsFor: 'pages' stamp: 'PhilippeBack 6/1/2017 17:58' prior: 84519159!welcome	^ HelpTopic 		title: 'Welcome to Pharo 6.0'		contents: (self heading: 'Pharo 6.0'), 		'Welcome to Pharo, an immersive live programming environment.Pharo is a pure object-oriented programming language and a powerful environment, focused on simplicity and immediate feedback (think IDE and OS rolled into one).For more information, please visit here: ', (self url: 'http://pharo.org'),(self subheading: 'Color themes'),'White theme: ', (self doItFrom: 'Pharo3Theme beCurrent. '), ' Dark theme: ', (self doItFrom: 'Pharo3DarkTheme beCurrent. ').! !!WriteStreamTest methodsFor: 'tests' stamp: 'KKSubbu 6/2/2017 21:03' prior: 84725775!testEnsureEndsWith	"self debug: #testEnsureEndsWith"	| stream |	stream := self newStream.	stream nextPutAll: 'this is a test'.	stream ensureEndsWith: Character cr.	stream nextPutAll: 'for WriteStreamTest'.	self assert: stream contents equals: (('this is a test' copyWith: Character cr), 'for WriteStreamTest').		"Manually put a new line and verify there are no 2 new lines"	stream := self newStream.	stream nextPutAll: ('this is a test' copyWith: Character cr).	stream ensureEndsWith: Character cr.	stream nextPutAll: 'for WriteStreamTest'.	self assert: stream contents equals: (('this is a test' copyWith: Character cr), 'for WriteStreamTest').		"Test with a empty stream"	stream := self newStream.	stream ensureEndsWith: Character cr.	self assert: stream contents equals: ''.! !!IntegerTest methodsFor: 'tests - bitLogic' stamp: 'SvenVanCaekenberghe 6/1/2017 20:45' prior: 29635981!testBitString	"self debug: #testBitString"		Smalltalk vm wordSize = 4		ifTrue: [			self assert: 2 bitString equals: '0000000000000000000000000000010'.			self assert: -1 bitString equals: '1111111111111111111111111111111'.			self assert: -2 bitString equals: '1111111111111111111111111111110'.			self assert: 2 bitStringLength equals: 31 ]. 	Smalltalk vm wordSize = 8		ifTrue: [			self assert: 2 bitString equals: '0000000000000000000000000000000000000000000000000000000000010'.			self assert: -1 bitString equals: '1111111111111111111111111111111111111111111111111111111111111'.			self assert: -2 bitString equals: '1111111111111111111111111111111111111111111111111111111111110'.			self assert: 2 bitStringLength equals: 61 ]. 	"32 minus 1 for immediate encoding = 31 = 30 for number + 1 for sign"	"64 minus 3 for immediate encoding = 61 = 60 for number + 1 for sign"	self assert: 2 bitStringLength equals: (SmallInteger maxVal highBit + 1).! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'SvenVanCaekenberghe 6/1/2017 21:07' prior: 29639619!testCreationFromBytes1	"self run: #testCreationFromBytes1"	"it is illegal for a LargeInteger to be less than SmallInteger maxVal." 	"here we test that Integer>>byte!!byte2:byte3:byte4: resconstructs SmallInteger maxVal as an instance of SmallInteger. "  	| maxSmallInt hexString byte1 byte2 byte3 byte4 builtInteger |	Smalltalk vm wordSize = 4 ifFalse: [ ^ self skip ].	maxSmallInt := SmallInteger maxVal.	hexString := maxSmallInt printStringHex.	self assert: hexString size = 8.	byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.	byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.	byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.	byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.	builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.	self assert: builtInteger = maxSmallInt.	self assert: builtInteger class = SmallInteger! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'SvenVanCaekenberghe 6/1/2017 21:07' prior: 29640579!testCreationFromBytes2 	"self run: #testCreationFromBytes2"	"it is illegal for a LargeInteger to be less than SmallInteger maxVal." 	"here we test that Integer>>byte!!byte2:byte3:byte4: resconstructs (SmallInteger maxVal + 1) as an instance of LargePositiveInteger. "	| maxSmallInt hexString byte1 byte2 byte3 byte4 builtInteger |	Smalltalk vm wordSize = 4 ifFalse: [ ^ self skip ].	maxSmallInt := SmallInteger maxVal.	hexString := (maxSmallInt + 1) printStringHex.	self assert: hexString size = 8.	byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.	byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.	byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.	byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.	builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.	self assert: builtInteger = (maxSmallInt + 1).	self deny: builtInteger class = SmallInteger! !!IntegerTest methodsFor: 'tests - instance creation' stamp: 'SvenVanCaekenberghe 6/1/2017 21:07' prior: 29625524!testCreationFromBytes3	"self run: #testCreationFromBytes3"	"it is illegal for a LargeInteger to be less than SmallInteger maxVal." 	"here we test that Integer>>byte!!byte2:byte3:byte4: resconstructs (SmallInteger maxVal - 1) as an instance of SmallInteger. "	| maxSmallInt hexString byte1 byte2 byte3 byte4 builtInteger |	Smalltalk vm wordSize = 4 ifFalse: [ ^ self skip ].	maxSmallInt := SmallInteger maxVal.	hexString := (maxSmallInt - 1) printStringHex.	self assert: hexString size = 8.	byte4 := Number readFrom: (hexString copyFrom: 1 to: 2) base: 16.	byte3 := Number readFrom: (hexString copyFrom: 3 to: 4) base: 16.	byte2 := Number readFrom: (hexString copyFrom: 5 to: 6) base: 16.	byte1 := Number readFrom: (hexString copyFrom: 7 to: 8) base: 16.	builtInteger := Integer byte1: byte1 byte2: byte2 byte3: byte3 byte4: byte4.	self assert: builtInteger = (maxSmallInt - 1).	self assert: builtInteger class = SmallInteger! !!VTermOutputDriver methodsFor: 'coloring' stamp: 'kks 5/19/2017 19:58' prior: 84236066!errorColor 	self red! !!STCommandLineHandler class methodsFor: 'printing' stamp: 'kks 5/19/2017 20:01' prior: 59101401!printCompilerWarning: aSyntaxErrorNotification	| stderr position contents errorLine errorMessage maxLineNumberSize lineNumber |		"format the error"	position := aSyntaxErrorNotification location.	contents := aSyntaxErrorNotification errorCode.	errorLine := contents lineNumberCorrespondingToIndex: position.	stderr := VTermOutputDriver stderr.			"first gather the error title to be able to underline it properly"	errorMessage := String streamContents: [ :s|		s nextPutAll: 'Syntax Error on line '; 			print: errorLine; nextPutAll: ': '; 			print: aSyntaxErrorNotification errorMessage].		 stderr red;		nextPutAll: errorMessage; lf;		nextPutAll: ('' padLeftTo: errorMessage size with: $=); lf;		clear.		"print each source line and mark the found syntax error"	maxLineNumberSize := contents lines size asString size.	lineNumber := 0.	contents lineIndicesDo: [:start :endWithoutDelimiters :end |		lineNumber := lineNumber + 1.		lineNumber == errorLine ifTrue: [ stderr errorColor ].		"0 pad the line numbers to the same size"		stderr 			nextPutAll: (lineNumber asString padLeftTo: maxLineNumberSize with: $0);			nextPutAll: ': ';			nextPutAll: (contents copyFrom: start to: endWithoutDelimiters);			lf.			"print the marker under the error line"		(lineNumber == errorLine)			ifTrue: [					stderr nextPutAll:( '_^_' padLeftTo: position - start + maxLineNumberSize + 4);							 lf;							 clear]	]! !!PharoWelcomePage class methodsFor: 'opening' stamp: 'PhilippeBack 6/1/2017 17:22' prior: 54501828!open	<script>	| group welcome help zen about window |	welcome := WelcomeHelp open.	help := HelpBrowser open.	zen := TextModel new			text: ProfStef pharoZenValuesContents;			title: 'Pharo Zen';			aboutText: ProfStef aboutPharoZen;			beForText;			openWithSpec.				about := TextModel new			text: Smalltalk systemInformationString withCRs;			title: 'About Pharo';			beForText;			openWithSpec.	group := GroupWindowMorph new.	group addWindow: welcome window.	group addWindow: help window.	group addWindow: SettingBrowser open.	group addWindow: KeymapBrowser new openWithSpec window.	group addWindow: zen window.	group addWindow: about window.	window := (group openInWindowLabeled: self title translated)		extent: welcome window extent;		yourself.			group tabGroup selectedPageIndex: 1.	^ window! !!PharoWelcomePage class methodsFor: 'opening' stamp: 'PhilippeBack 6/1/2017 17:22' prior: 54502733!openForRelease	<script>	| window |		World submorphs 		detect: [ :each | (each isKindOf: SystemWindow) and: [ each label = self title ] ] 		ifFound: [ :oldWindow | oldWindow delete ].	window := self open.	window extent: 750@400.	window center: Display extent / 2! !!SmallIntegerTest methodsFor: 'tests - Class Methods' stamp: 'SvenVanCaekenberghe 6/1/2017 20:03' prior: 60216021!testMaxVal	Smalltalk vm wordSize = 4		ifTrue: [ self assert: SmallInteger maxVal = 16r3FFFFFFF ].	Smalltalk vm wordSize = 8		ifTrue: [ self assert: SmallInteger maxVal = 16rFFFFFFFFFFFFFFF ]! !!SmallIntegerTest methodsFor: 'tests - Class Methods' stamp: 'SvenVanCaekenberghe 6/1/2017 20:04' prior: 60215871!testMinVal	Smalltalk vm wordSize = 4		ifTrue: [ self assert: SmallInteger minVal = -16r40000000 ].	Smalltalk vm wordSize = 8		ifTrue: [ self assert: SmallInteger minVal = -16r1000000000000000 ]! !!SmallIntegerTest methodsFor: 'tests - printing' stamp: 'SvenVanCaekenberghe 6/1/2017 20:08' prior: 60217483!testPrintString	self assert: 1 printString equals: '1'.	self assert: -1 printString equals: '-1'.	Smalltalk vm wordSize = 4		ifTrue: [ 			self assert: SmallInteger minVal printString equals: '-1073741824'.			self assert: SmallInteger maxVal printString equals: '1073741823' ].	Smalltalk vm wordSize = 8		ifTrue: [ 			self assert: SmallInteger minVal printString equals: '-1152921504606846976'.			self assert: SmallInteger maxVal printString equals: '1152921504606846975' ].	self assert: 12345 printString equals: '12345'.	self assert: -54321 printString equals: '-54321'.		self assert: 0 decimalDigitLength equals: 1.	self assert: 4 decimalDigitLength equals: 1.	self assert: 12 decimalDigitLength equals: 2.	self assert: 123 decimalDigitLength equals: 3.	self assert: 1234 decimalDigitLength equals: 4.	self assert: 56789 decimalDigitLength equals: 5.	self assert: 657483 decimalDigitLength equals: 6.	self assert: 6571483 decimalDigitLength equals: 7.	self assert: 65174383 decimalDigitLength equals: 8.	self assert: 625744831 decimalDigitLength equals: 9.	self assert: 1000001111 decimalDigitLength equals: 10.	Smalltalk vm wordSize = 4		ifTrue: [ self assert: SmallInteger maxVal decimalDigitLength equals: 10 ].	Smalltalk vm wordSize = 8		ifTrue: [ self assert: SmallInteger maxVal decimalDigitLength equals: 19 ].! !!SmallInteger methodsFor: 'system primitives' stamp: 'SvenVanCaekenberghe 6/2/2017 09:42' prior: 60213036!digitAt: n	"Answer the value of an apparent byte-indexable field in the receiver,	 analogous to the large integers, which are organized as bytes."	n = 1		ifTrue: [ 			"Negate carefully in case the receiver is SmallInteger minVal"			^ self < 0				ifTrue: [ -256 - self bitAnd: 255 ]				ifFalse: [ self bitAnd: 255 ] ].	^ self < 0		ifTrue: [ (-256 - self bitShift: -8) + 1 digitAt: n - 1 ]		ifFalse: [ (self bitShift: 8 - (n bitShift: 3)) bitAnd: 255 ]! !!WriteStream methodsFor: 'accessing' stamp: 'kks 4/18/2017 22:42' prior: 84716398!ensureEndsWith: anObject	"Append anObject to the receiver IFF it is non-empty and there is not one on the end."	(position == 0 or: [(collection at: position) = anObject]) ifTrue: [^self].	self nextPut: anObject! !"CodeImportCommandLineHandlers"!"Collections-Streams"!"Collections-Tests"!"Kernel"!"Kernel-Tests"!"Pharo-Help"!"System-CommandLine"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo60/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader60-TheIntegrator.575.mcz') load.ScriptLoader new update60499.!----End fileIn----!----QUIT----2017-06-06T15:14:03.768117+02:00 Pharo.image priorSource: 109815!----QUIT----2017-06-06T15:14:14.551317+02:00 Pharo.image priorSource: 153371!----SNAPSHOT----2017-06-19T16:58:38.510576+02:00 Pharo6.1.image priorSource: 153450!----SNAPSHOT----2017-06-19T16:58:42.728576+02:00 Pharo6.1.image priorSource: 153529!Object subclass: #TicTacToeCell	instanceVariableNames: 'container model'	classVariableNames: ''	package: 'tictactoe'!Object subclass: #TicTacToe	instanceVariableNames: 'container model'	classVariableNames: ''	package: 'tictactoe'!Object subclass: #TicTacToeCell	instanceVariableNames: ''	classVariableNames: ''	package: 'tictactoe'!Object subclass: #TicTacToeModel	instanceVariableNames: ''	classVariableNames: ''	package: 'tictactoe'!!TicTacToe methodsFor: 'initialize' stamp: 'Patrick 6/19/2017 17:04'!initialize	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	model := TicTacToeModel new: 3.	self addRows.	self addControls.! !!TicTacToe methodsFor: 'initialize' stamp: 'Patrick 6/19/2017 17:04' prior: 33708659!initialize	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	model := TicTacToeModel new: 3.	self addRows.	self addControls.	^self.! !----SNAPSHOT----2017-06-19T17:04:20.215576+02:00 Pharo6.1.image priorSource: 153615!!TicTacToe methodsFor: 'initialize' stamp: 'Patrick 6/19/2017 17:08'!addRows	| rowMorph cell columns |	1 to: 3 do: [ :row |		rowMorph := Morph new layoutPolicy: RowLayout new.		1 to: 3 do: [ :col |			cell := TicTacToeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!TicTacToe methodsFor: 'initialize' stamp: 'Patrick 6/19/2017 17:09' prior: 33709241!addRows	| rowMorph cell |	1 to: 3 do: [ :row |		rowMorph := Morph new layoutPolicy: RowLayout new.		1 to: 3 do: [ :col |			cell := TicTacToeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!TicTacToe methodsFor: 'initialize' stamp: 'Patrick 6/19/2017 17:12'!addControls	| rowMorph newGameBtn exitBtn |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	newGameBtn := self createButton: 'New' onClickExecutes: [ self restart ].	exitBtn := self createButton: 'Exit' onClickExecutes: [ container delete ].	rowMorph ! !!TicTacToe methodsFor: 'initialize' stamp: 'Patrick 6/19/2017 17:13' prior: 33709951!addControls	| rowMorph newGameBtn exitBtn |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	newGameBtn := self createButton: 'New' onClickExecutes: [ self restart ].	exitBtn := self createButton: 'Exit' onClickExecutes: [ container delete ].	rowMorph addMorph: newGameBtn.	rowMorph addMorph: exitBtn.	container addMorph: rowMorph.! !!TicTacToe methodsFor: 'initialize' stamp: 'Patrick 6/19/2017 17:15'!createButton: string onClickExecutes: function	| newButton |	newButton := SimpleButtonMorph new label: string.	newButton color: (Color black alpha: 0.2).	newButton extent: 120@50.	newButton on: #click send: #value to: function.	^newButton! !!TicTacToe methodsFor: 'open' stamp: 'Patrick 6/19/2017 17:17'!open	container openInWindow.! !!TicTacToe methodsFor: 'starting' stamp: 'Patrick 6/19/2017 17:18'!restart	container delete.	Smalltalk garbageCollect.	TicTacToe new open.! !----SNAPSHOT----2017-06-19T17:18:48.232576+02:00 Pharo6.1.image priorSource: 154652!SimpleButtonMorph subclass: #TicTacToeCell	instanceVariableNames: ''	classVariableNames: ''	package: 'tictactoe'!SimpleButtonMorph subclass: #TicTacToeCell	instanceVariableNames: 'parent row column'	classVariableNames: ''	package: 'tictactoe'!----SNAPSHOT----2017-06-19T17:19:15.604576+02:00 Pharo6.1.image priorSource: 156834!!TicTacToeCell methodsFor: 'initialize' stamp: 'Patrick 6/19/2017 18:20'!initialize	super initialize.	self label: ''.	self extent: 80@80.	self color: Color yellow.	self on: #click send: #value to: (self onClickExecution).	^self.! !!TicTacToeCell methodsFor: 'accessing' stamp: 'Patrick 6/19/2017 18:22'!setModel: model row: rownum col: colnum	| col |	parent := model.	row := rownum.	col := colnum.	! !!TicTacToeCell methodsFor: 'accessing' stamp: 'Patrick 6/19/2017 18:22' prior: 33712004!setModel: model row: rownum col: colnum	parent := model.	row := rownum.	column := colnum.	! !!TicTacToeCell methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:28'!onClickExecution	^[		(self label size) == 0			ifTrue: [  				self label: 	(parent updateAtRow: row Col: column).				parent checkWinCondition.				self extent: 80@80.			]	]! !!TicTacToeCell methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:28' prior: 33712368!onClickExecution	^[		(self label size) == 0			ifTrue: [  				self label: 	(parent updateAtRow: row Col: column).				parent checkWinCondition.				self extent: 80@80.			].	]! !!TicTacToeCell methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:28' prior: 33712639!onClickExecution	^[		(self label isEmpty)			ifTrue: [  				self label: 	(parent updateAtRow: row Col: column).				parent checkWinCondition.				self extent: 80@80.			].	]! !!TicTacToeCell methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:28' prior: 33712911!onClickExecution	^[		(self label isEmpty)			ifTrue: [  				self label: 	(parent updateAtRow: row col: column).				parent checkWinCondition.				self extent: 80@80.			].	]! !Matrix subclass: #TicTacToeModel	instanceVariableNames: 'filledCells current winner'	classVariableNames: ''	package: 'tictactoe'!!TicTacToeModel methodsFor: 'initialize' stamp: 'Patrick 6/19/2017 18:30'!initialize	super initialize.	filledCells := 0.	current := nil.	winner := nil.! !!TicTacToeModel methodsFor: 'accessing' stamp: 'Patrick 6/19/2017 18:34'!updateAtRow: row col: col	current == nil		ifTrue: [ current := 'X' ]		ifFalse: [ 			current == 'X'			ifTrue: [ current := 'O' ]			ifFalse: [ current := 'X' ]			].	self at: row at: col put: current.	filledCells := filledCells + 1.	^current.! !!TicTacToeModel methodsFor: 'accessing' stamp: 'Patrick 6/19/2017 18:34' prior: 33713730!updateAtRow: row col: col	current isNil		ifTrue: [ current := 'X' ]		ifFalse: [ 			current == 'X'			ifTrue: [ current := 'O' ]			ifFalse: [ current := 'X' ]			].	self at: row at: col put: current.	filledCells := filledCells + 1.	^current.! !!Manifesttictactoe commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!Manifesttictactoe class methodsFor: 'code-critics' stamp: 'Patrick 6/19/2017 18:35'!ruleRBAssignmentInIfTrueRuleV1FalsePositive	^ #()! !!Manifesttictactoe class methodsFor: 'code-critics' stamp: 'Patrick 6/19/2017 18:35' prior: 33714606!ruleRBAssignmentInIfTrueRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#TicTacToeModel)) #'2017-06-19T18:35:00.108092+02:00') )! !----SNAPSHOT----2017-06-19T18:35:06.766092+02:00 Pharo6.1.image priorSource: 157173!!TicTacToeModel methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:38'!checkWinCondition	filledCells >= 5	ifTrue: [ 		Transcript show: 'yes'.		1 to: 3 do: [ :idx |			self checkWinConditionInRow: idx.			self checkWinConditionInColumn: idx.					].			self checkWinConditionInDiagonals.	].	! !!TicTacToeModel methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:40'!checkWinConditionInRow: row	| set |	winner isNil	ifTrue: [ 		set := (self atRow: row) asSet.		self checkWinConditionInSet: set		].	^winner.! !!TicTacToeModel methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:40'!checkWinConditionInColumn: col	| set |	winner isNil	ifTrue: [ 		set := (self atCol: col) asSet.		self checkWinConditionInSet: set		].	^winner.! !!TicTacToeModel methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:41' prior: 33715583!checkWinConditionInColumn: col	| set |	winner isNil	ifTrue: [ 		set := (self atColumn: col) asSet.		self checkWinConditionInSet: set		].	^winner.! !!TicTacToeModel methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:43'!checkWinConditionInDiagonals	| set1 set2 |	winner isNil	ifTrue: [ 		set1 := (self diagonal) asSet.		set2 := Set newFrom: {			(self at: 1 at: 3).			(self at: 2 at: 2).			(self at: 3 at: 1).		} asOrderedCollection.		self checkWinConditionInSet: set1.		self checkWinConditionInSet: set2.	].	^winner.! !!TicTacToeModel methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:46'!setWinConditionInSet: set	set size == 1	ifTrue: [ 		(set includes: 'X')		ifTrue: [ 			winner := 'P1'.			Transcript open.			Transcript show: 'Player 1 won!!'.		].		(set includes: 'O')		ifTrue: [ 			winner := 'P2'.			Transcript open.			Transcript show: 'Player 2 won!!'.		].	].! !!Manifesttictactoe class methodsFor: 'code-critics' stamp: 'Patrick 6/19/2017 18:47'!ruleRBGuardingClauseRuleV1FalsePositive	^ #()! !!Manifesttictactoe class methodsFor: 'code-critics' stamp: 'Patrick 6/19/2017 18:47' prior: 33716823!ruleRBGuardingClauseRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#TicTacToeModel)) #'2017-06-19T18:47:19.683092+02:00') )! !!TicTacToeModel methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:47' prior: 33716443!setWinConditionInSet: set	set size == 1		ifTrue: [ (set includes: 'X')				ifTrue: [ winner := 'P1'.					Transcript show: 'Player 1 won!!' ].			(set includes: 'O')				ifTrue: [ winner := 'P2'.					Transcript show: 'Player 2 won!!' ] ]! !!TicTacToeModel methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:49' prior: 33717195!setWinConditionInSet: set	set size == 1	ifTrue: [		(set includes: 'X')		ifTrue: [			winner := 'P1'.			Transcript open.			Transcript show: 'Player 1 won!!'		].		(set includes: 'O')		ifTrue: [			winner := 'P2'.			Transcript open.			Transcript show: 'Player 2 won!!'		].	].! !!Manifesttictactoe class methodsFor: 'code-critics' stamp: 'Patrick 6/19/2017 18:49'!ruleGRGuradGuardClauseRuleV1FalsePositive	^ #()! !!Manifesttictactoe class methodsFor: 'code-critics' stamp: 'Patrick 6/19/2017 18:49' prior: 33717904!ruleGRGuradGuardClauseRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#TicTacToeModel)) #'2017-06-19T18:49:09.229092+02:00') )! !!TicTacToeModel methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:49' prior: 33717529!setWinConditionInSet: set "runs? pharo cries"	set size == 1	ifTrue: [		(set includes: 'X')		ifTrue: [			winner := 'P1'.			Transcript open.			Transcript show: 'Player 1 won!!'		].		(set includes: 'O')		ifTrue: [			winner := 'P2'.			Transcript open.			Transcript show: 'Player 2 won!!'		].	].! !!TicTacToeModel methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:49' prior: 33718280!setWinConditionInSet: set "runs? pharo cries"	set size == 1	ifTrue: [		set includes: 'X'		ifTrue: [			winner := 'P1'.			Transcript open.			Transcript show: 'Player 1 won!!'		].		(set includes: 'O')		ifTrue: [			winner := 'P2'.			Transcript open.			Transcript show: 'Player 2 won!!'		].	].! !!TicTacToeModel methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:50' prior: 33718679!setWinConditionInSet: set "runs? pharo cries"	set size == 1	ifTrue: [		(set includes: 'X')		ifTrue: [			winner := 'P1'.			Transcript open.			Transcript show: 'Player 1 won!!'		].		(set includes: 'O')		ifTrue: [			winner := 'P2'.			Transcript open.			Transcript show: 'Player 2 won!!'		].	].! !----SNAPSHOT----2017-06-19T18:50:04.904092+02:00 Pharo6.1.image priorSource: 160463!!TicTacToeModel methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:51' prior: 33719076!setWinConditionInSet: set "runs? pharo cries"	set size == 1	ifTrue: [		(set includes: 'X')		ifTrue: [			winner := 'P1'.			Transcript show: 'Player 1 won!!'		].		(set includes: 'O')		ifTrue: [			winner := 'P2'.			Transcript show: 'Player 2 won!!'		].	].! !!TicTacToeModel methodsFor: 'execution' stamp: 'Patrick 6/19/2017 18:52'!checkWinConditionInSet: set "runs? pharo cries"	set size == 1	ifTrue: [		(set includes: 'X')		ifTrue: [			winner := 'P1'.			Transcript show: 'Player 1 won!!'		].		(set includes: 'O')		ifTrue: [			winner := 'P2'.			Transcript show: 'Player 2 won!!'		].	].! !TicTacToeModel removeSelector: #setWinConditionInSet:!----SNAPSHOT----2017-06-19T18:52:58.420092+02:00 Pharo6.1.image priorSource: 164952!Smalltalk globals removeClassNamed: #AnObsoleteManifesttictactoe!(Smalltalk globals at: #TicTacToe) rename: #Snake!!Snake methodsFor: 'starting' stamp: 'Patrick 6/21/2017 17:05' prior: 33711189!restart	container delete.	Smalltalk garbageCollect.	Snake new open.! !(Smalltalk globals at: #TicTacToeCell) rename: #SnakeCell!!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:06' prior: 33709608!addRows	| rowMorph cell |	1 to: 3 do: [ :row |		rowMorph := Morph new layoutPolicy: RowLayout new.		1 to: 3 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !(Smalltalk globals at: #TicTacToeModel) rename: #SnakeModel!!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:06' prior: 33708911!initialize	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	model := SnakeModel new: 3.	self addRows.	self addControls.	^self.! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:06' prior: 33721145!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	model := SnakeModel new: 3.	self addRows.	self addControls.	^self.! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:07' prior: 33721397!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	model := SnakeModel new: 4.	self addRows.	self addControls.	^self.! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:08' prior: 33721696!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	"no clue what the 3 does"	model := SnakeModel new: 3.	self addRows.	self addControls.	^self.! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:10' prior: 33721995!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	"no clue what the 3 does"	model := SnakeModel new.	self addRows.	self addControls.	^self.! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:11' prior: 33722321!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	"no clue what the 20 does, maybe number of cells later on"	model := SnakeModel new: 20.	self addRows.	self addControls.	^self.! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:11' prior: 33722644!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	"no clue what the 20 does, maybe number of cells later on?"	model := SnakeModel new: 20.	self addRows.	self addControls.	^self.! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:12' prior: 33710331!addControls	| rowMorph newGameBtn exitBtn |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	newGameBtn := self createButton: 'Start' onClickExecutes: [ self restart ].	exitBtn := self createButton: 'Exit' onClickExecutes: [ container delete ].	rowMorph addMorph: newGameBtn.	rowMorph addMorph: exitBtn.	container addMorph: rowMorph.! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:12' prior: 33723365!addControls	| rowMorph startBtn exitBtn |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self restart ].	exitBtn := self createButton: 'Exit' onClickExecutes: [ container delete ].	rowMorph addMorph: startBtn.	rowMorph addMorph: exitBtn.	container addMorph: rowMorph.! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:12' prior: 33723866!addControls	| rowMorph startBtn exitBtn |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	exitBtn := self createButton: 'Exit' onClickExecutes: [ container delete ].	rowMorph addMorph: startBtn.	rowMorph addMorph: exitBtn.	container addMorph: rowMorph.! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:13' prior: 33724361!addControls	| rowMorph startBtn exitBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	exitBtn := self createButton: 'Exit' onClickExecutes: [ container delete ].	messageArea := self createTextArea: 'Welcome'.	rowMorph addMorph: startBtn.	rowMorph addMorph: exitBtn.	container addMorph: rowMorph.! !!Snake methodsFor: 'as yet unclassified' stamp: 'Patrick 6/21/2017 17:14'!createTextArea	"TODO implement"! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:15' prior: 33724854!addControls	| rowMorph startBtn exitBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	exitBtn := self createButton: 'Exit' onClickExecutes: [ container delete ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	rowMorph addMorph: exitBtn.	container addMorph: rowMorph.! !!Snake methodsFor: 'starting' stamp: 'Patrick 6/21/2017 17:16' prior: 33711088!open	"opens game, but does not start it!!"	container openInWindow.! !Snake removeSelector: #restart!!Snake methodsFor: 'starting' stamp: 'Patrick 6/21/2017 17:16'!start	"start game loop later on"! !!Snake methodsFor: 'starting' stamp: 'Patrick 6/21/2017 17:16' prior: 33726240!start	"TODO start game loop later on"! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:19' prior: 33725518!addControls	| rowMorph startBtn exitBtn messageArea window |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	exitBtn := self createButton: 'Exit' onClickExecutes: [ container delete ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	rowMorph addMorph: exitBtn.	container addMorph: rowMorph.! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:21' prior: 33726481!addControls	| rowMorph startBtn exitBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	exitBtn := self createButton: 'Exit' onClickExecutes: [ container delete. container parent close ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	rowMorph addMorph: exitBtn.	container addMorph: rowMorph.! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:21' prior: 33727043!addControls	| rowMorph startBtn exitBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	exitBtn := self createButton: 'Exit' onClickExecutes: [ container delete. container window close ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	rowMorph addMorph: exitBtn.	container addMorph: rowMorph.! !!Snake methodsFor: 'execution' stamp: 'Patrick 6/21/2017 17:22'!onClickExecution	^[		(self label isEmpty)			ifTrue: [  				self label: 	(parent updateAtRow: row col: column).				parent checkWinCondition.				self extent: 80@80.			].	]! !SnakeCell removeSelector: #onClickExecution!!Snake methodsFor: 'closing' stamp: 'Patrick 6/21/2017 17:23'!close	container close.	! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:23' prior: 33727622!addControls	| rowMorph startBtn exitBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	exitBtn := self createButton: 'Exit' onClickExecutes: [ self close ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	rowMorph addMorph: exitBtn.	container addMorph: rowMorph.! !!Snake methodsFor: 'closing' stamp: 'Patrick 6/21/2017 17:24' prior: 33728474!close	container close.	self delete.	! !!Snake methodsFor: 'closing' stamp: 'Patrick 6/21/2017 17:24' prior: 33729131!close	container close.	World removeMorph: self.	! !!Snake methodsFor: 'closing' stamp: 'Patrick 6/21/2017 17:25' prior: 33729253!close	container close.		! !!SnakeCell methodsFor: 'as yet unclassified' stamp: 'Patrick 6/21/2017 17:29' prior: 33711766!initialize	super initialize.	self label: ''.	self extent: 80@80.	self color: Color yellow.	self on: #click send: #value to: (self onClickExecution).	^self.! !!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 17:31'!onClickExecution	^[		(self label size) == 0			ifTrue:[				self label: (parent updateAtRow: row col: col).				parent checkWinCondition.				self extent: 80@80.			]. 	]! !SimpleButtonMorph subclass: #SnakeCell	instanceVariableNames: 'parent row column'	classVariableNames: ''	package: 'snake_game'!!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 17:31' prior: 33729752!onClickExecution	^[		(self label size) == 0			ifTrue:[				self label: (parent updateAtRow: row col: column).				parent checkWinCondition.				self extent: 80@80.			]. 	]! !!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 17:31' prior: 33730151!onClickExecution	^[		(self label isEmpty)			ifTrue:[				self label: (parent updateAtRow: row col: column).				parent checkWinCondition.				self extent: 80@80.			]. 	]! !!Snake methodsFor: 'starting' stamp: 'Patrick 6/21/2017 17:34' prior: 33726071!open	|window|	window := SystemWindow new		label: 'Hello';	open: container in: window.! !!Snake methodsFor: 'starting' stamp: 'Patrick 6/21/2017 17:35' prior: 33730679!open	|window|	window := SystemWindow new		label: 'Hello'.	window open: container.! !!Snake methodsFor: 'starting' stamp: 'Patrick 6/21/2017 17:36' prior: 33730852!open	container openInWindowLabeled: 'Snake'.! !!Snake methodsFor: 'closing' stamp: 'Patrick 6/21/2017 17:36' prior: 33729387!close	container close.	(SystemWindow allInstances detect: [ :w  | w label = '<title>' ] ifNone: [ ^ nil ]) delete		! !!Snake methodsFor: 'closing' stamp: 'Patrick 6/21/2017 17:36' prior: 33731149!close	container close.	(SystemWindow allInstances detect: [ :w  | w label = 'Snake' ] ifNone: [ ^ nil ]) delete		! !!Snake methodsFor: 'closing' stamp: 'Patrick 6/21/2017 17:37' prior: 33731351!close	container close.	(Morph allInstances detect: [ :w  | w label = 'Snake' ] ifNone: [ ^ nil ]) delete		! !!Snake methodsFor: 'closing' stamp: 'Patrick 6/21/2017 17:38' prior: 33731551!close	container close.		! !!Snake methodsFor: 'closing' stamp: 'Patrick 6/21/2017 17:41' prior: 33731744!close	container close.	container dismissMorph.		! !!Snake methodsFor: 'closing' stamp: 'Patrick 6/21/2017 17:43' prior: 33731854!close	"container close."	container dismissMorph.		! !!Snake methodsFor: 'closing' stamp: 'Patrick 6/21/2017 17:43' prior: 33731989!close	container dismissMorph.		! !!Snake methodsFor: 'closing' stamp: 'Patrick 6/21/2017 17:43' prior: 33732126!close	container dismissMorph.		! !Snake removeSelector: #close!!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:45' prior: 33728585!addControls	| rowMorph startBtn exitBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	rowMorph addMorph: exitBtn.	container addMorph: rowMorph.! !!Snake methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:45' prior: 33732394!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !(Smalltalk globals at: #Snake) rename: #SnakeGame!!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:47' prior: 33732872!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:47' prior: 33733369!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:48' prior: 33733783!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: FixedLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:48' prior: 33734228!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:49' prior: 33734675!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:52' prior: 33735120!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:53' prior: 33735565!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	self layout: rowMorph in: #center.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:53' prior: 33736010!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO rework new button to start button"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:54' prior: 33736491!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:54' prior: 33736936!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO add start functionality"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	"messageArea := self createTextArea: 'Welcome'."	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:54' prior: 33737339!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO add start functionality"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome'.	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 17:54' prior: 33737774!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO add start functionality"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake'.	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 17:55'!createTextArea: string	| newButton |	newButton := SimpleButtonMorph new label: string.	newButton color: (Color black alpha: 0.2).	newButton extent: 120@50.	newButton on: #click send: #value to: newButton.	^newButton! !SnakeGame removeSelector: #createTextArea!!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 17:56' prior: 33738631!createTextArea: string	| newTextArea |	newTextArea := SimpleButtonMorph new label: string.	newTextArea color: (Color black alpha: 0.2).	newTextArea extent: 120@50.	"newTextArea on: #click send: #value to: newTextArea."	^newTextArea! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 17:56' prior: 33738984!createTextArea: string	| newTextArea |	newTextArea := SimpleButtonMorph new label: string.	newTextArea color: (Color black alpha: 0.2).	newTextArea extent: 300@50.	"newTextArea on: #click send: #value to: newTextArea."	^newTextArea! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:00' prior: 33739309!createTextArea: string	| newTextArea |	newTextArea := TextMorph new.	newTextArea help: string.	newTextArea color: (Color black alpha: 0.2).	newTextArea extent: 300@50.	"newTextArea on: #click send: #value to: newTextArea."	^newTextArea! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:00' prior: 33739634!createTextArea: string	| newTextArea |	newTextArea := TextMorph new.	newTextArea  	newTextArea color: (Color black alpha: 0.2).	newTextArea extent: 300@50.	"newTextArea on: #click send: #value to: newTextArea."	^newTextArea! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:01' prior: 33739964!createTextArea: string	| newTextArea |	newTextArea := TextMorph new.	newTextArea contents: string. 	newTextArea color: (Color black alpha: 0.2).	newTextArea extent: 300@50.	"newTextArea on: #click send: #value to: newTextArea."	^newTextArea! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:01' prior: 33740282!createTextArea: string	| newTextArea |	newTextArea := TextMorph new.	newTextArea contents: string. 	newTextArea color: (Color white).	newTextArea extent: 300@50.	"newTextArea on: #click send: #value to: newTextArea."	^newTextArea! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:02' prior: 33740617!createTextArea: string	| newTextArea |	newTextArea := TextMorph new.	newTextArea contents: string. 	newTextArea color: (Color white).	newTextArea extent: 150@50.	"newTextArea on: #click send: #value to: newTextArea."	^newTextArea! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:02' prior: 33740941!createTextArea: string	| newTextArea |	newTextArea := TextMorph new.	newTextArea contents: string. 	newTextArea color: (Color white).	newTextArea extent: 120@50.	"newTextArea on: #click send: #value to: newTextArea."	^newTextArea! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:02' prior: 33738207!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO add start functionality"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake'.	rowMorph addMorph: startBtn.	rowMorph addMorph: messageArea.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:02' prior: 33741591!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO add start functionality"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake'.	rowMorph addMorph: messageArea.	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:07' prior: 33742066!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO add start functionality"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake'.	rowMorph addMorph: messageArea.	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:07' prior: 33741265!createTextArea: string	| newTextArea |	newTextArea := TextMorph new.	newTextArea contents: string. 	newTextArea color: (Color white).	newTextArea extent: 120@50.	"newTextArea on: #click send: #value to: newTextArea."	^newTextArea! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:07' prior: 33723004!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	"no clue what the 20 does, maybe number of cells later on?"	model := SnakeModel new: 20.	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:08' prior: 33742541!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO add start functionality"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake'.	rowMorph addMorph: messageArea.	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:08' prior: 33743705!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO add start functionality"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake'.	rowMorph addMorph: messageArea frame: (1@1) .	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:09' prior: 33744180!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO add start functionality"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake'.	rowMorph addMorph: messageArea offsets: 50@0.	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:10' prior: 33744669!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO add start functionality"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake'.	rowMorph addMorph: messageArea offsets: (10@0 corner: 0@0).	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:12' prior: 33745158!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO add start functionality"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake'.	rowMorph addMorph: messageArea.	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:12' prior: 33743014!createTextArea: string	| newTextArea |	newTextArea := TextMorph new margins: 5@5.	newTextArea contents: string. 	newTextArea color: (Color white).	newTextArea extent: 120@50.	"newTextArea on: #click send: #value to: newTextArea."	^newTextArea! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:12' prior: 33746134!createTextArea: string	| newTextArea |	newTextArea := TextMorph new margins: 20@0.	newTextArea contents: string. 	newTextArea color: (Color white).	newTextArea extent: 120@50.	"newTextArea on: #click send: #value to: newTextArea."	^newTextArea! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:13' prior: 33746471!createTextArea: string	| newTextArea |	newTextArea := TextMorph new margins: 10@0.	newTextArea contents: string. 	newTextArea color: (Color white).	newTextArea extent: 120@50.	"newTextArea on: #click send: #value to: newTextArea."	^newTextArea! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:13' prior: 33746809!createTextArea: string	| newTextArea |	"margins so that not everything is directly next to each other"	newTextArea := TextMorph new margins: 10@0.	newTextArea contents: string. 	newTextArea color: (Color white).	newTextArea extent: 120@50.	"newTextArea on: #click send: #value to: newTextArea."	^newTextArea! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:13' prior: 33747147!createTextArea: string	| newTextArea |	"margins so that not everything is directly next to each other"	newTextArea := TextMorph new margins: 10@0.	newTextArea contents: string. 	newTextArea color: (Color white).	newTextArea extent: 120@50.	^newTextArea! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:13' prior: 33747550!createTextArea: string	| newTextArea |	"margins so that not everything is directly next to each other"	newTextArea := TextMorph new margins: 10@0.	newTextArea contents: string. 	newTextArea color: (Color white).	newTextArea extent: 120@50.	^newTextArea! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:14' prior: 33720732!addRows	| rowMorph cell |	1 to: 20 do: [ :row |		rowMorph := Morph new layoutPolicy: RowLayout new.		1 to: 20 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:15' prior: 33748246!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new layoutPolicy: RowLayout new.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 18:15' prior: 33729513!initialize	super initialize.	self label: ''.	self extent: 20@20.	self color: Color yellow.	self on: #click send: #value to: (self onClickExecution).	^self.! !!SnakeGame methodsFor: 'execution' stamp: 'Patrick 6/21/2017 18:17' prior: 33728184!onClickExecution	| row column |	^[		(self label isEmpty)			ifTrue: [  				self label: 	(model updateAtRow: row col: column).				model checkWinCondition.				self extent: 80@80.			].	]! !SnakeGame removeSelector: #onClickExecution!!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:19' prior: 33743340!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	"no clue what the 20 does, maybe number of cells later on?"	model := SnakeModel new: 25.	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:20' prior: 33749541!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	"no clue what the 20 does, maybe number of cells later on?"	model := SnakeModel new: 3.	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:20' prior: 33749906!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	"no clue what the 20 does, maybe number of cells later on?"	model := SnakeModel new: 25.	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:20' prior: 33750270!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	"no clue what the 20 does, maybe number of cells later on?"	model := SnakeModel new.	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:20' prior: 33750635!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	"no clue what the 20 does, maybe number of cells later on?"	model := SnakeModel new: 20.	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:20' prior: 33750996!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	"no clue what the 25 does, maybe number of cells later on?"	model := SnakeModel new: 25.	self addRows.	self addControls.	^self.! !!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 18:20' prior: 33748964!initialize	super initialize.	self label: ''.	self extent: 20@20.	self color: Color yellow.	^self.! !!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 18:21' prior: 33751730!initialize	super initialize.	self label: ''.	self extent: 20@20.	self color: Color gray.	^self.! !!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 18:22' prior: 33751926!initialize	super initialize.	self label: ''.	self extent: 20@20.	self color: Color gray.	self on: #click do: [  ].	^self.! !!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 18:22' prior: 33752120!initialize	super initialize.	self label: ''.	self extent: 20@20.	self color: Color gray.	^self.! !!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 18:22' prior: 33730421!onClickExecution	^[		(self label isEmpty)			ifTrue:[				self label: (parent updateAtRow: row col: column).				parent checkWinCondition.				self extent: 25@25.			]. 	]! !SnakeCell removeSelector: #onClickExecution!!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 18:23' prior: 33752341!initialize	super initialize.	self label: ''.	self extent: 20@20.	self color: Color yellow.	^self.! !!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 18:23' prior: 33752849!initialize	super initialize.	self extent: 20@20.	self color: Color yellow.	^self.! !!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 18:23' prior: 33753045!initialize	super initialize.	self label: ''.	self extent: 20@20.	self color: Color yellow.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:24' prior: 33751361!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	"no clue what the 25 does, maybe number of cells later on?"	model := SnakeModel new: 0.	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:24' prior: 33753416!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 18:25' prior: 33753224!initialize	super initialize.	self label: ''.	self extent: 20@20.	self color: Color lightGray.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:26' prior: 33748603!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new layoutPolicy: RowLayout new.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:26' prior: 33754289!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:26' prior: 33747897!createTextArea: string	| newTextArea |	"margins so that not everything is directly next to each other"	newTextArea := TextMorph new margins: 10@0.	newTextArea contents: string. 	newTextArea color: (Color white).	newTextArea extent: 500@50.	^newTextArea! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:27' prior: 33755004!createTextArea: string	| newTextArea |	"margins so that not everything is directly next to each other"	newTextArea := TextMorph new margins: 10@0.	newTextArea contents: string.	newTextArea color: (Color white).	newTextArea extent: 500@50.	^newTextArea! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:28' prior: 33754646!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new;			margins: 0@0.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:28' prior: 33755699!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 18:29' prior: 33754094!initialize	super initialize.	self label: ''.	self extent: 20@20.	self margins: 0@0.	self color: Color lightGray.	^self.! !!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 18:29' prior: 33756440!initialize	super initialize.	self label: ''.	self extent: 20@20.	self color: Color lightGray.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:29' prior: 33756076!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new.		1 to: 25 do: [ :col |			cell := SnakeCell new margins: 0@0.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:29' prior: 33756854!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:30' prior: 33757227!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: TableLayout new.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:30' prior: 33757587!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: EmptyLayout new.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:30' prior: 33757949!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:30' prior: 33758311!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: FTRowLayout new.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:31' prior: 33758671!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: SpecRowLayout new.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:31' prior: 33759033!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:32' prior: 33759397!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: (25*25)@25.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:32' prior: 33759757!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: (25*25)@1.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:32' prior: 33760140!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: (25*25)@25.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:32' prior: 33760522!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: (25)@25.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:32' prior: 33760905!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 25@25.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:32' prior: 33761285!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 500@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:33' prior: 33761663!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 250@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:33' prior: 33762042!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 500@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/21/2017 18:33' prior: 33731021!open	container openInWindowLabeled: 'Snake'.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:34' prior: 33753780!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@50;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:34' prior: 33755351!createTextArea: string	| newTextArea |	"margins so that not everything is directly next to each other"	newTextArea := TextMorph new margins: 10@0.	newTextArea contents: string.	newTextArea color: (Color white).	newTextArea extent: 350@50.	^newTextArea! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:35' prior: 33745661!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO add start functionality"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake'.	rowMorph addMorph: startBtn.	rowMorph addMorph: messageArea.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:35' prior: 33763607!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO add start functionality"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake'.		rowMorph addMorph: messageArea.	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:35' prior: 33764082!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		color: Color transparent.	"TODO add start functionality"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake'.	rowMorph addMorph: messageArea.	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:36' prior: 33710776!createButton: string onClickExecutes: function	| newButton |	newButton := SimpleButtonMorph new label: string margins: (-150)@0.	newButton color: (Color black alpha: 0.2).	newButton extent: 120@50.	newButton on: #click send: #value to: function.	^newButton! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:36' prior: 33765031!createButton: string onClickExecutes: function	| newButton |	newButton := SimpleButtonMorph new margins: (-150)@0 label: string .	newButton color: (Color black alpha: 0.2).	newButton extent: 120@50.	newButton on: #click send: #value to: function.	^newButton! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 18:36' prior: 33765381!createButton: string onClickExecutes: function	| newButton |	newButton := SimpleButtonMorph new label: string .	newButton color: (Color black alpha: 0.2).	newButton extent: 120@50.	newButton on: #click send: #value to: function.	^newButton! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:38' prior: 33762933!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: RowLayout new;		extent: 500@50;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:38' prior: 33766067!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@50;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:39' prior: 33766393!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 550@50;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:39' prior: 33766721!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 550@500;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:39' prior: 33767049!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:39' prior: 33767378!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 10@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:39' prior: 33767707!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:40' prior: 33768035!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@700;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:40' prior: 33768364!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@560;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:40' prior: 33768693!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:41' prior: 33769022!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addControls.	self addRows.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:41' prior: 33769351!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 18:41' prior: 33756659!initialize	super initialize.	self label: ''.	self extent: 19@19.	self color: Color lightGray.	^self.! !!SnakeCell methodsFor: 'initialization' stamp: 'Patrick 6/21/2017 18:42' prior: 33770013!initialize	super initialize.	self label: ''.	self extent: 20@20.	self color: Color lightGray.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:45' prior: 33764558!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		extent: 500@50;		color: Color transparent.	"TODO add start functionality"	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake'.	rowMorph addMorph: messageArea.	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:45' prior: 33770407!addControls	| rowMorph startBtn messageArea |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		extent: 500@50;		color: Color transparent.	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake'.	rowMorph addMorph: messageArea.	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:47' prior: 33762421!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 500@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/21/2017 18:48' prior: 33726357!start	"TODO start game loop later on"! !Object subclass: #SnakeGame	instanceVariableNames: 'container model rows'	classVariableNames: ''	package: 'snake_game'!!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:49' prior: 33771361!addRows	| rowMorph cell |	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 500@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:50' prior: 33771990!addRows	| rowMorph cell |	rows := Array new: 25.	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 500@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:51' prior: 33772369!addRows	| rowMorph cell |	rows := Array new: 25.	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 500@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	rows at: row put: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:52' prior: 33772772!addRows	| rowMorph cell |	rows := Array new: 25.	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 500@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	rows at: row put: rowMorph.	].	! !!Manifestsnakegame commentStamp: '<historical>' prior: 0!I store metadata for this package. These meta data are used by other tools such as the SmalllintManifestChecker and the critics Browser!!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'Patrick 6/21/2017 18:52'!ruleRBToDoCollectRuleV1FalsePositive	^ #()! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'Patrick 6/21/2017 18:52' prior: 33773831!ruleRBToDoCollectRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#SnakeGame)) #'2017-06-21T18:52:12.527448+02:00') )! !!SnakeGame methodsFor: 'accessing' stamp: 'Patrick 6/21/2017 18:52'!container	^ container! !!SnakeGame methodsFor: 'accessing' stamp: 'Patrick 6/21/2017 18:52'!container: anObject	container := anObject! !!SnakeGame methodsFor: 'accessing' stamp: 'Patrick 6/21/2017 18:52'!model	^ model! !!SnakeGame methodsFor: 'accessing' stamp: 'Patrick 6/21/2017 18:52'!model: anObject	model := anObject! !!SnakeGame methodsFor: 'accessing' stamp: 'Patrick 6/21/2017 18:52'!rows	^ rows! !!SnakeGame methodsFor: 'accessing' stamp: 'Patrick 6/21/2017 18:52'!rows: anObject	rows := anObject! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/21/2017 18:54' prior: 33771738!start	rows at: 5 color: Color red.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/21/2017 18:54' prior: 33774780!start	rows at: 5 at: 5.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/21/2017 18:55' prior: 33774903!start	| redCell blueCell |	redCell := rows at: 5 at: 5.	blueCell := rows at: 20 at: 20.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/21/2017 18:55' prior: 33775015!start	| redCell blueCell |	redCell := rows at: 5 at: 5.	blueCell := rows at: 20 at: 20.	redCell color: Color red.	blueCell color: Color blue.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 18:56' prior: 33773204!addRows	| rowMorph cell |	rows := Array new: 25@25.	1 to: 25 do: [ :row |		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 500@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.				rows at: row@col put: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:00' prior: 33775429!addRows	| rowMorph cell |	rows := Array new: 25.	1 to: 25 do: [ :row |		rows at: row put: Array new: 25.		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 500@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.						].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:00' prior: 33775867!addRows	| rowMorph cell |	rows := Array new: 25.	1 to: 25 do: [ :row |		rows at: row put: Array new: 25.		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 500@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.					].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:00' prior: 33776310!addRows	| rowMorph cell |	rows := Array new: 25.	1 to: 25 do: [ :row |		rows at: row put: Array new: 25.		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 500@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:01' prior: 33776752!addRows	| rowMorph cell |	rows := Array new: 25.	1 to: 25 do: [ :row |		rows at: row.		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 500@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:01' prior: 33777190!addRows	| rowMorph cell |	rows := Array new: 25.	1 to: 25 do: [ :row |		rows at: row put: Array new: 25.		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 500@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:02' prior: 33777609!addRows	| rowMorph cell |	rows := Array new: 25.	1 to: 25 do: [ :row |		| currentRow |		currentRow := Array new: 25.		rows at: row put: currentRow.		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 500@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:03' prior: 33778047!addRows	| rowMorph cell |	rows := Array new: 25.	1 to: 25 do: [ :row |		| currentRow |		currentRow := Array new: 25.		rows at: row put: currentRow.		rowMorph := Morph new			layoutPolicy: RowLayout new;			extent: 500@20.		1 to: 25 do: [ :col |			cell := SnakeCell new.			cell setModel: (model) row: row col: col.			rowMorph addMorph: cell.			currentRow at: col put: cell.		].	container addMorph: rowMorph.	].	! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/21/2017 19:04' prior: 33775193!start	| redCell blueCell |	redCell := (rows at: 5) at: 5.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/21/2017 19:04' prior: 33779044!start	| redCell blueCell |	"4/20 are 4 cells out since 0-24 indices"	redCell := (rows at: 4) at: 4.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.! !----SNAPSHOT----2017-06-21T19:05:02.732448+02:00 Pharo6.1.image priorSource: 165798!!SnakeGame methodsFor: 'starting' stamp: 'Anonymous 6/21/2017 19:06' prior: 33779282!start	| redCell blueCell |	"0/0 is right bottom corner"	redCell := (rows at: 0) at: 0.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.! !----SNAPSHOT----2017-06-21T19:06:48.75728+02:00 Pharo6.1.image priorSource: 225046!!SnakeGame methodsFor: 'starting' stamp: 'Anonymous 6/21/2017 19:07' prior: 33779651!start	| redCell blueCell |	"0/0 is right bottom corner"	redCell := (rows at: 5) at: 5.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.! !!SnakeGame methodsFor: 'starting' stamp: 'Anonymous 6/21/2017 19:07' prior: 33780006!start	| redCell blueCell |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.! !----SNAPSHOT----2017-06-21T19:09:30.83028+02:00 Pharo6.1.image priorSource: 225402!Object subclass: #SnakeGame	instanceVariableNames: 'container model rows keyListener'	classVariableNames: ''	package: 'snake_game'!!SnakeGame methodsFor: 'initialize' stamp: 'Anonymous 6/21/2017 19:14' prior: 33769680!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	self addKeyListener.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:15'!addKeyListener	keyListener := SimpleHierarchicalListMorph new.! !----SNAPSHOT----2017-06-21T19:15:17.648111+02:00 Pharo6.1.image priorSource: 226050!!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:19' prior: 33781127!addKeyListener	keyListener := SimpleHierarchicalListMorph new.	"keyListener handleKeystroke:" ! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:21' prior: 33781366!addKeyListener	keyListener := SimpleHierarchicalListMorph new.	"keyListener handleKeystroke:" ! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:23' prior: 33780792!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	self addKeyListener.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:24' prior: 33781552!addKeyListener	keyListener := SimpleHierarchicalListMorph new.! !!SnakeGame methodsFor: 'execution' stamp: 'Patrick 6/21/2017 19:26'!handleKeystroke: event	| key |	key := event keyValue.	key = 30 "up"		ifTrue: [  ].	key = 31 "down"		ifTrue: [  ].	key = 29 "right"		ifTrue: [  ].	key = 28 "left"		ifTrue: [  ]! !!SnakeGame methodsFor: 'execution' stamp: 'Patrick 6/21/2017 19:26' prior: 33782225!handleKeystroke: event	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [  ].	key = 31 "down blue"		ifTrue: [  ].	key = 29 "right blue"		ifTrue: [  ].	key = 28 "left blue"		ifTrue: [  ]! !!SnakeGame methodsFor: 'execution' stamp: 'Patrick 6/21/2017 19:27' prior: 33782499!handleKeystroke: event	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [  ].	key = 31 "down blue"		ifTrue: [  ].	key = 29 "right blue"		ifTrue: [  ].	key = 28 "left blue"		ifTrue: [  ].	key > 31 "test"		ifTrue: [  ]! !!SnakeGame methodsFor: 'creating' stamp: 'Patrick 6/21/2017 19:27' prior: 33763259!createTextArea: string	| newTextArea |	"margins so that not everything is directly next to each other"	newTextArea := TextMorph new margins: 10@0.	newTextArea contents: string.	newTextArea color: (Color white).	newTextArea extent: 350@50.	^newTextArea! !Object subclass: #SnakeGame	instanceVariableNames: 'container model rows keyListener messageArea'	classVariableNames: ''	package: 'snake_game'!!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:28' prior: 33770900!addControls	| rowMorph startBtn |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		extent: 500@50;		color: Color transparent.	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake'.	rowMorph addMorph: messageArea.	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'execution' stamp: 'Patrick 6/21/2017 19:28' prior: 33782793!handleKeystroke: event	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [  ].	key = 31 "down blue"		ifTrue: [  ].	key = 29 "right blue"		ifTrue: [  ].	key = 28 "left blue"		ifTrue: [  ].	key > 31 "test"		ifTrue: [  ]! !!SnakeGame methodsFor: 'execution' stamp: 'Patrick 6/21/2017 19:29' prior: 33784063!handleKeystroke: event	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ messageArea contents: 'left arrow' ].	key > 31 | key < 28 "test"		ifTrue: [ messageArea contents: 'up arrow' ]! !!SnakeGame methodsFor: 'execution' stamp: 'Patrick 6/21/2017 19:30' prior: 33784390!handleKeystroke: event	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ messageArea contents: 'left arrow' ].	key > 31 | key < 28 "test"		ifTrue: [ messageArea contents: key ]! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:31' prior: 33782089!addKeyListener	keyListener := SimpleHierarchicalListMorph new.! !!SnakeGame methodsFor: 'execution' stamp: 'Patrick 6/21/2017 19:31' prior: 33784895!handleKeystroke: event	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ messageArea contents: 'left arrow' ].	key > 31 | key < 28 "test"		ifTrue: [ messageArea contents: key ]! !!SnakeGame methodsFor: 'execution' stamp: 'Patrick 6/21/2017 19:32' prior: 33785546!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ messageArea contents: 'left arrow' ].	key > 31 | key < 28 "test"		ifTrue: [ messageArea contents: key ]! !SnakeGame removeSelector: #addKeyListener!!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:34'!addKeyListener	keyListener := SimpleHierarchicalListMorph new.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:36' prior: 33786606!addKeyListener	keyListener := SimpleHierarchicalListMorph new.	keyListener drawKeyboardFocusOn: keyListener.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:36' prior: 33786759!addKeyListener	keyListener := SimpleHierarchicalListMorph new.	self drawKeyboardFocusOn: keyListener.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:37' prior: 33786959!addKeyListener	keyListener := SimpleHierarchicalListMorph new.	keyListener hasKeyboardFocus 		ifTrue: [ messageArea content: 'yes' ]		ifFalse: [ messageArea content: 'no' ]! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:37' prior: 33787152!addKeyListener	keyListener := SimpleHierarchicalListMorph new.	keyListener hasKeyboardFocus 		ifTrue: [ messageArea content: 'yes' ]		ifFalse: [ messageArea content: 'no' ].! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:38' prior: 33787418!addKeyListener	keyListener := SimpleHierarchicalListMorph new.	keyListener hasKeyboardFocus 		ifTrue: [ messageArea textArea content: 'yes' ]		ifFalse: [ messageArea content: 'no' ].! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:38' prior: 33787685!addKeyListener	keyListener := SimpleHierarchicalListMorph new.	keyListener hasKeyboardFocus 		ifTrue: [ messageArea textArea content: 'yes' ]		ifFalse: [ messageArea textArea content: 'no' ].! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:38' prior: 33787961!addKeyListener	keyListener := SimpleHierarchicalListMorph new.	keyListener hasKeyboardFocus 		ifTrue: [ messageArea content: 'yes' ]		ifFalse: [ messageArea textArea content: 'no' ].! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:39' prior: 33788246!addKeyListener	keyListener := SimpleHierarchicalListMorph new.	keyListener hasKeyboardFocus 		ifTrue: [ messageArea contents: 'yes' ]		ifFalse: [ messageArea contents: 'no' ].! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:41' prior: 33788522!addKeyListener	keyListener := SimpleHierarchicalListMorph new.	keyListener hasKeyboardFocus 		ifTrue: [ messageArea contents: 'yes' ]		ifFalse: [ messageArea contents: 'no' ].	keyListener drawKeyboardFocusOn: keyListener.	keyListener hasKeyboardFocus 		ifTrue: [ messageArea contents: 'yesss' ]		ifFalse: [ messageArea contents: 'not' ].! !SnakeGame removeSelector: #addKeyListener!!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:46' prior: 33781738!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !Object subclass: #SnakeGame	instanceVariableNames: 'container model rows messageArea'	classVariableNames: ''	package: 'snake_game'!!SnakeGame methodsFor: 'keyboard control' stamp: 'Patrick 6/21/2017 19:47' prior: 33786044!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ messageArea contents: 'left arrow' ].	key > 31 | key < 28 "test"		ifTrue: [ messageArea contents: key ]! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:48' prior: 33789270!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:50' prior: 33790275!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:51' prior: 33790604!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:52' prior: 33790933!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:54' prior: 33791262!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:54' prior: 33791591!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	container eventHandler: self.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:55' prior: 33791920!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		eventHandler: self;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'Patrick 6/21/2017 19:55'!ruleRBInconsistentMethodClassificationRuleV1FalsePositive	^ #()! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'Patrick 6/21/2017 19:55' prior: 33792631!ruleRBInconsistentMethodClassificationRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#SnakeGame)) #'2017-06-21T19:55:19.866111+02:00') )! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:56' prior: 33792280!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/21/2017 19:56' prior: 33793030!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	^self.! !----SNAPSHOT----2017-06-21T19:59:26.417111+02:00 Pharo6.1.image priorSource: 226761!Morph subclass: #KeyListener	instanceVariableNames: ''	classVariableNames: ''	package: 'snake_game'!!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 13:26'!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ messageArea contents: 'left arrow' ].	key > 31 | key < 28 "test"		ifTrue: [ messageArea contents: key ]! !SnakeGame removeSelector: #handleKeystroke:!!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 13:27'!keyStroke: event "no clue how to actually use this"	| key messageArea |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ messageArea contents: 'left arrow' ].	key > 31 | key < 28 "test"		ifTrue: [ messageArea contents: key ]! !!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 13:27' prior: 33794443!keyStroke: event "no clue how to actually use this"	| key messageArea |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ messageArea contents: 'left arrow' ].	key > 31 | key < 28 "test"		ifTrue: [ messageArea contents: key ]! !Morph subclass: #KeyListener	instanceVariableNames: 'parent'	classVariableNames: ''	package: 'snake_game'!!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 13:28' prior: 33793359!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	self addKeyListener.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 13:28'!addKeyListener	keyListener := KeyListener new.	keyListener parent: self.! !!SnakeGame methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 13:29'!messageArea	^ messageArea! !!SnakeGame methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 13:29'!messageArea: anObject	messageArea := anObject! !KeyListener removeSelector: #handleKeystroke:!!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 13:30' prior: 33794991!keyStroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ parent messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ parent messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ parent messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ parent messageArea contents: 'left arrow' ].	key > 31 | key < 28 "test"		ifTrue: [ parent messageArea contents: key ]! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 13:30' prior: 33780276!start	| redCell blueCell |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.! !HandMorph subclass: #KeyListener	instanceVariableNames: 'parent'	classVariableNames: ''	package: 'snake_game'!!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 13:32' prior: 33796976!start	| redCell blueCell |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.	keyListener newKeyboardFocus: keyListener.! !!KeyListener methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 13:33'!parent	^ parent! !!KeyListener methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 13:33'!parent: anObject	parent := anObject! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 13:35' prior: 33795977!addKeyListener	keyListener := KeyListener new.	container addMorph: keyListener .	keyListener parent: container.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 13:37' prior: 33793359!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new. "new: 3?"	self addRows.	self addControls.	self addKeyListener.	^self.! !Object subclass: #KeyListener		instanceVariableNames: 'parent' 		classVariableNames: ''		category: 'snake_game'!!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 13:38'!addKeyListener	keyListener := KeyListener new.	container addMorph: keyListener.	keyListener parent: self.! !!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 13:38'!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ messageArea contents: 'left arrow' ].	key > 31 | key < 28 "test"		ifTrue: [ messageArea contents: key ]! !SnakeGame removeSelector: #handleKeystroke:!!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 13:39' prior: 33798767!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ parent messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ parent messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ parent messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ parent messageArea contents: 'left arrow' ].	key > 31 | key < 28 "test"		ifTrue: [ parent messageArea contents: key ]! !!SnakeGame methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 13:39'!messageArea	^ messageArea! !!SnakeGame methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 13:39'!messageArea: anObject	messageArea := anObject! !----SNAPSHOT----2017-06-22T13:39:39.474336+02:00 Pharo6.1.image priorSource: 239169!HandMorph subclass: #KeyListener	instanceVariableNames: 'parent'	classVariableNames: ''	package: 'snake_game'!----SNAPSHOT----2017-06-22T13:40:04.780336+02:00 Pharo6.1.image priorSource: 245623!!KeyListener methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 13:40'!parent	^ parent! !!KeyListener methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 13:40'!parent: anObject	parent := anObject! !----SNAPSHOT----2017-06-22T13:40:43.079336+02:00 Pharo6.1.image priorSource: 245824!!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 13:42' prior: 33780276!start	| redCell blueCell |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.	keyListener newKeyboardFocus: keyListener.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 13:42' prior: 33798577!addKeyListener	keyListener := KeyListener new.	container addMorph: keyListener.	keyListener parent: self.	container newKeyboardFocus: keyListener.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 13:42' prior: 33801052!addKeyListener	keyListener := KeyListener new.	container addMorph: keyListener.	"keyListener parent: self."	container newKeyboardFocus: keyListener.! !----SNAPSHOT----2017-06-22T13:42:55.860359+02:00 Pharo6.1.image priorSource: 246112!!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 13:43' prior: 33801292!addKeyListener	keyListener := KeyListener new.	container addMorph: keyListener.	"keyListener parent: self."	keyListener newKeyboardFocus: keyListener.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 13:43' prior: 33801292!addKeyListener	keyListener := KeyListener new.	container addMorph: keyListener.	"keyListener parent: self."	keyListener newKeyboardFocus: container.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 13:44' prior: 33801864!addKeyListener	keyListener := KeyListener new.	container addMorph: keyListener.	keyListener parent: self.	keyListener newKeyboardFocus: container.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 13:45' prior: 33802106!addKeyListener	keyListener := KeyListener new.	container addMorph: keyListener.	keyListener parent: self.	keyListener keyboardFocus: container.! !Morph subclass: #KeyListener	instanceVariableNames: 'parent'	classVariableNames: ''	package: 'snake_game'!!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'Patrick 6/22/2017 13:45'!ruleRBNoClassCommentRuleV1FalsePositive	^ #()! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'Patrick 6/22/2017 13:45' prior: 33802694!ruleRBNoClassCommentRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#KeyListener)) #'2017-06-22T13:45:43.049248+02:00') )! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 13:46' prior: 33802346!addKeyListener	keyListener := KeyListener new.	container addMorph: keyListener.	keyListener parent: self.! !!KeyListener methodsFor: 'initalize' stamp: 'Patrick 6/22/2017 13:47'!initialize	self extent: 0@0.! !!KeyListener methodsFor: 'initalize' stamp: 'Patrick 6/22/2017 13:47' prior: 33803242!initialize	super initialize.	self extent: 0@0.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 13:48' prior: 33800715!start	| redCell blueCell |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.	container keyboardFocusChange: keyListener.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 13:49' prior: 33803498!start	| redCell blueCell |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.	container drawKeyboardFocusOn: keyListener.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 13:51' prior: 33803834!start	| redCell blueCell |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 13:52' prior: 33804170!start	| redCell blueCell |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 13:53' prior: 33804461!start	| redCell blueCell |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.	keyListener takeKeyboardFocus.! !!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 13:55' prior: 33799355!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ parent messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ parent messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ parent messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ parent messageArea contents: 'left arrow' ].	key > 31 "test high"		ifTrue: [ parent messageArea contents: key, 'high' ].	key < 28 "test low"		ifTrue: [ parent messageArea contents: key, 'low' ].! !!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 13:55' prior: 33805085!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ parent messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ parent messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ parent messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ parent messageArea contents: 'left arrow' ].	key > 31 "test high"		ifTrue: [ parent messageArea contents: (key, 'high') ].	key < 28 "test low"		ifTrue: [ parent messageArea contents: (key, 'low') ].! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'Patrick 6/22/2017 13:55' prior: 33792801!ruleRBInconsistentMethodClassificationRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#SnakeGame)) #'2017-06-21T19:55:19.866111+02:00') #(#(#RGClassDefinition #(#KeyListener)) #'2017-06-22T13:55:27.473248+02:00') )! !!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 13:56' prior: 33805741!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ parent messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ parent messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ parent messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ parent messageArea contents: 'left arrow' ].	key > 31 "test high"		ifTrue: [ parent messageArea contents: key ].	key < 28 "test low"		ifTrue: [ parent messageArea contents: key ].! !!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 13:57' prior: 33806723!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ parent messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ parent messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ parent messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ parent messageArea contents: 'left arrow' ].	key > 31 "test high"		ifTrue: [ parent messageArea contents: (key printString) ].	key < 28 "test low"		ifTrue: [ parent messageArea contents: (key printString) ].! !!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 13:59' prior: 33807364!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ parent messageArea contents: 'up arrow' ].	key = 31 "down blue"		ifTrue: [ parent messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ parent messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ parent messageArea contents: 'left arrow' ].	key = 119 "red up"		ifTrue: [ parent messageArea contents: 'w' ].	key = 115 "red down"		ifTrue: [ parent messageArea contents: 's' ].	key = 100 "red right"		ifTrue: [ parent messageArea contents: 'd' ].	key = 97 "red left"		ifTrue: [ parent messageArea contents: 'a' ].! !----SNAPSHOT----2017-06-22T13:59:57.441248+02:00 Pharo6.1.image priorSource: 247015!!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 14:01' prior: 33798125!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new.	self addRows.	self addControls.	self addKeyListener.	^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 14:01' prior: 33808891!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new blueDirection: #south; redDirection: #north.	self addRows.	self addControls.	self addKeyListener.	^self.! !Matrix subclass: #SnakeModel	instanceVariableNames: 'filledCells current winner blueDirection redDirection'	classVariableNames: ''	package: 'snake_game'!Object subclass: #Directions	instanceVariableNames: ''	classVariableNames: ''	package: 'snake_game'!Smalltalk globals removeClassNamed: #AnObsoleteDirections!Matrix subclass: #SnakeModel	instanceVariableNames: 'blueCells redCells blueDirection redDirection'	classVariableNames: ''	package: 'snake_game'!SnakeModel removeSelector: #checkWinCondition!SnakeModel removeSelector: #checkWinConditionInColumn:!SnakeModel removeSelector: #checkWinConditionInDiagonals!SnakeModel removeSelector: #checkWinConditionInRow:!SnakeModel removeSelector: #checkWinConditionInSet:!SnakeModel removeSelector: #updateAtRow:col:!!SnakeModel methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 14:05'!blueCells	^ blueCells! !!SnakeModel methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 14:05'!blueCells: anObject	blueCells := anObject! !!SnakeModel methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 14:06'!redCells	^ redCells! !!SnakeModel methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 14:06'!redCells: anObject	redCells := anObject! !!SnakeModel methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 14:06'!blueDirection	^ blueDirection! !!SnakeModel methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 14:06'!blueDirection: anObject	blueDirection := anObject! !!SnakeModel methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 14:06'!redDirection	^ redDirection! !!SnakeModel methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 14:06'!redDirection: anObject	redDirection := anObject! !!SnakeModel methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 14:06' prior: 33713571!initialize	super initialize.	blueDirection := #north.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 14:06' prior: 33809232!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	model := SnakeModel new.	self addRows.	self addControls.	self addKeyListener.	^self.! !!SnakeModel methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 14:06' prior: 33811282!initialize	super initialize.	blueDirection := #south.	redDirection := #north.! !!SnakeModel methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 14:07' prior: 33811769!initialize	super initialize.	blueDirection := #south.	redDirection := #north.! !!SnakeModel methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 15:06' prior: 33811940!initialize	super initialize.	blueDirection := #south.	redDirection := #north.	blueCells := OrderedCollection new.	redCells := OrderedCollection new.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 15:06' prior: 33811427!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.	self addRows.	self addControls.	self addKeyListener.		model := SnakeModel new.		^self.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 15:07' prior: 33804752!start	| redCell blueCell |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.! !!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 15:08' prior: 33808033!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ parent model blueDirection: #north ].	key = 31 "down blue"		ifTrue: [ parent messageArea contents: 'down arrow' ].	key = 29 "right blue"		ifTrue: [ parent messageArea contents: 'right arrow' ].	key = 28 "left blue"		ifTrue: [ parent messageArea contents: 'left arrow' ].	key = 119 "red up"		ifTrue: [ parent messageArea contents: 'w' ].	key = 115 "red down"		ifTrue: [ parent messageArea contents: 's' ].	key = 100 "red right"		ifTrue: [ parent messageArea contents: 'd' ].	key = 97 "red left"		ifTrue: [ parent messageArea contents: 'a' ].! !!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 15:09' prior: 33813106!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ parent model blueDirection: #north ].	key = 31 "down blue"		ifTrue: [ parent model blueDirection: #south ].	key = 29 "right blue"		ifTrue: [ parent model blueDirection: #east ].	key = 28 "left blue"		ifTrue: [ parent model blueDirection: #west ].	key = 119 "red up"		ifTrue: [ parent model redDirection: #north ].	key = 115 "red down"		ifTrue: [ parent model redDirection: #south ].	key = 100 "red right"		ifTrue: [ parent model redDirection: #east ].	key = 97 "red left"		ifTrue: [ parent model redDirection: #west ].! !!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 15:10' prior: 33813881!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ parent model blueDirection: #north ].	key = 31 "down blue"		ifTrue: [ parent model blueDirection: #south ].	key = 29 "right blue"		ifTrue: [ parent model blueDirection: #east ].	key = 28 "left blue"		ifTrue: [ parent model blueDirection: #west ].	key = 119 "red up (w)"		ifTrue: [ parent model redDirection: #north ].	key = 115 "red down (s)"		ifTrue: [ parent model redDirection: #south ].	key = 100 "red right (d)"		ifTrue: [ parent model redDirection: #east ].	key = 97 "red left (a)"		ifTrue: [ parent model redDirection: #west ].! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 15:11' prior: 33783615!addControls	| rowMorph startBtn |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		extent: 500@50;		color: Color transparent.	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake (use WASD to control red, arrow keys to control blue)'.	rowMorph addMorph: messageArea.	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 15:12' prior: 33815395!addControls	| rowMorph startBtn |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		extent: 500@50;		color: Color transparent.	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake!! (WASD controls red, arrow keys control blue)'.	rowMorph addMorph: messageArea.	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !----SNAPSHOT----2017-06-22T15:12:34.271248+02:00 Pharo6.1.image priorSource: 254286!!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 17:25' prior: 33812697!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.		! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 17:25' prior: 33816478!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.		winner := nil.		! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 17:29' prior: 33816888!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	winner = nil		whileTrue: [ 			(Delay forMilliseconds: 120).			model executeSteps.			winner := winner.		].! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 17:29' prior: 33817316!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	winner = nil		whileTrue: [ 			(Delay forMilliseconds: 120).			model executeSteps.			winner := model checkWinner.		].! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 17:30' prior: 33817916!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	winner = nil		whileTrue: [ 			(Delay forMilliseconds: 120).			model executeStep.			winner := model checkWinner.		].! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:34'!executeStep	"TODO start with blue only"	"TODO this is supposed to compute snake movement"	blueDirection = #north		ifTrue: [ self moveNorth: blueCells ].	blueDirection = #south		ifTrue: [ self moveSouth: blueCells ].	blueDirection = #east		ifTrue: [ self moveEast: blueCells ].	blueDirection = #west		ifTrue: [ self moveWest: blueCells ].	"TODO here we want to do collision checks after movement"! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:35'!moveNorth: ordered	| firstCell newCell lastCell |		! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:36' prior: 33819603!moveNorth: ordered	| firstCell newCell lastCell |	firstCell := ordered first.	! !!SnakeCell methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 17:38'!parent	^ parent! !!SnakeCell methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 17:38'!parent: anObject	parent := anObject! !!SnakeCell methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 17:38'!row	^ row! !!SnakeCell methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 17:38'!row: anObject	row := anObject! !!SnakeCell methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 17:38'!column	^ column! !!SnakeCell methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 17:38'!column: anObject	column := anObject! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:41' prior: 33819747!moveNorth: ordered	| firstCell newCell lastCell |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ].		! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:42' prior: 33820500!moveNorth: ordered	| firstCell newCell lastCell |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ]	! !Matrix subclass: #SnakeModel	instanceVariableNames: 'parent blueCells redCells blueDirection redDirection'	classVariableNames: ''	package: 'snake_game'!Matrix subclass: #SnakeModel	instanceVariableNames: 'board blueCells redCells blueDirection redDirection'	classVariableNames: ''	package: 'snake_game'!!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 17:44' prior: 33812354!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.			model := SnakeModel new.		self addRows.	self addControls.	self addKeyListener.		^self.! !!SnakeModel methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 17:44'!board	^ board! !!SnakeModel methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 17:44'!board: anObject	board := anObject! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 17:44' prior: 33821306!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.			model := SnakeModel new.	model board put: self. 		self addRows.	self addControls.	self addKeyListener.		^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 17:44' prior: 33821850!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.			model := SnakeModel new.	model board put: self.		self addRows.	self addControls.	self addKeyListener.		^self.! !!SnakeGame methodsFor: 'initialize' stamp: 'Patrick 6/22/2017 17:44' prior: 33822223!initialize	"makes a table to be filled with information"	container := Morph new		layoutPolicy: TableLayout new;		extent: 500@550;		color: Color transparent.			model := SnakeModel new.	model board: self.		self addRows.	self addControls.	self addKeyListener.		^self.! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:45' prior: 33820748!moveNorth: ordered	| firstCell newCell lastCell |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows at: (firstCell row) ]	! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:46' prior: 33822963!moveNorth: ordered	| firstCell newCell lastCell |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows at: (firstCell row)+1 at: (firstCell column)]	! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:47' prior: 33823265!moveNorth: ordered	| firstCell newCell lastCell |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows at: (firstCell row)+1 at: (firstCell column)].	ordered removeLast.	! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:47' prior: 33823591!moveNorth: ordered	| firstCell newCell lastCell |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows at: (firstCell row)+1 at: (firstCell column)].	lastCell := ordered last.				ordered removeLast.	! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:49' prior: 33823939!moveNorth: ordered	| firstCell newCell lastCell |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows at: (firstCell row)+1 at: (firstCell column)].	lastCell := ordered last.		newCell color: Color blue.	lastCell color: Color lightGray.		ordered removeLast.	! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:49' prior: 33824320!moveNorth: ordered	| firstCell newCell lastCell |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows at: (firstCell row)+1 at: (firstCell column)].	lastCell := ordered last.		newCell color: Color blue.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.	! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:50'!moveNorth: ordered for: player	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows at: (firstCell row)+1 at: (firstCell column)].	lastCell := ordered last.		playerColor := self getColor: player.		newCell color: Color blue.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.	! !SnakeModel removeSelector: #moveNorth:!!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:52'!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows at: (firstCell row)+1 at: (firstCell column)].	lastCell := ordered last.		playerColor := firstCell color.		newCell color: playerColor.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.	! !SnakeModel removeSelector: #moveNorth:for:!!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:52'!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 1)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows at: (firstCell row)-1 at: (firstCell column)].	lastCell := ordered last.		playerColor := firstCell color.		newCell color: playerColor.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:53'!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows at: (firstCell row)+1 at: (firstCell column)].	lastCell := ordered last.		playerColor := firstCell color.		newCell color: playerColor.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:53' prior: 33825773!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell row = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows at: (firstCell row)+1 at: (firstCell column)].	lastCell := ordered last.		playerColor := firstCell color.		newCell color: playerColor.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.	! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:53' prior: 33826319!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell row = 1)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows at: (firstCell row)-1 at: (firstCell column)].	lastCell := ordered last.		playerColor := firstCell color.		newCell color: playerColor.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:53'!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 1)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows at: (firstCell row)-1 at: (firstCell column)].	lastCell := ordered last.		playerColor := firstCell color.		newCell color: playerColor.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:54' prior: 33826817!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows at: (firstCell row) at: (firstCell column)+1].	lastCell := ordered last.		playerColor := firstCell color.		newCell color: playerColor.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:54' prior: 33828340!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 1)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows at: (firstCell row) at: (firstCell column)-1].	lastCell := ordered last.		playerColor := firstCell color.		newCell color: playerColor.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 17:54'!move: ordered	! !SnakeModel removeSelector: #move:!!SnakeModel methodsFor: 'evaluation' stamp: 'Patrick 6/22/2017 17:56'!checkWinner	^nil.! !!SnakeModel methodsFor: 'evaluation' stamp: 'Patrick 6/22/2017 17:57' prior: 33829990!checkWinner "TODO evaluate a winner depending on snake stats"	^nil.! !!SnakeModel methodsFor: 'evaluation' stamp: 'Patrick 6/22/2017 17:57' prior: 33830099!checkWinner "TODO evaluate a winner depending on snake stats --> TODO implement snake with stats"	^nil.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 17:58' prior: 33818527!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[winner = nil ] whileTrue: [ 			(Delay forMilliseconds: 120).			model executeStep.			winner := model checkWinner.		].! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 17:58' prior: 33830450!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[winner = nil ] whileTrue: [ 		(Delay forMilliseconds: 120).		model executeStep.		winner := model checkWinner.	].! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 17:58' prior: 33831061!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[winner isNil ] whileTrue: [ 		(Delay forMilliseconds: 120).		model executeStep.		winner := model checkWinner.	].! !!SnakeGame methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 18:00'!rows: aRow at: aColumn	^rows at: aRow at: aColumn.! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:01' prior: 33828853!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows: (firstCell row) at: (firstCell column)+1].	lastCell := ordered last.		playerColor := firstCell color.		newCell color: playerColor.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:01' prior: 33827331!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell row = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows: (firstCell row)+1 at: (firstCell column)].	lastCell := ordered last.		playerColor := firstCell color.		newCell color: playerColor.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.	! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:01' prior: 33827845!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell row = 1)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows: (firstCell row)-1 at: (firstCell column)].	lastCell := ordered last.		playerColor := firstCell color.		newCell color: playerColor.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:01' prior: 33829367!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 1)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows: (firstCell row) at: (firstCell column)-1].	lastCell := ordered last.		playerColor := firstCell color.		newCell color: playerColor.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.! !!SnakeGame methodsFor: 'accessing' stamp: 'Patrick 6/22/2017 18:02' prior: 33832260!rows: aRow at: aColumn	^(rows at: aRow) at: aColumn.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 18:04' prior: 33831668!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[winner isNil ] whileTrue: [ 		(Delay forMilliseconds: 1200).		model executeStep.		winner := model checkWinner.	].! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 18:06' prior: 33834581!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[winner isNil ] whileTrue: [ 		| delay |		delay := (Delay forMilliseconds: 1200).		delay wait.		model executeStep.		winner := model checkWinner.	].! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 18:06' prior: 33835189!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[winner isNil ] whileTrue: [ 		| delay |		delay := (Delay forMilliseconds: 120).		delay wait.		model executeStep.		winner := model checkWinner.	].! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 18:12' prior: 33835832!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[winner isNil ] whileTrue: [ 		| delay |		delay := (Delay forMilliseconds: 250).		delay wait.		model executeStep.		winner := model checkWinner.	].! !!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 18:16' prior: 33814634!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ parent model blueDirection: #north. parent messageArea contents: 'n' ].	key = 31 "down blue"		ifTrue: [ parent model blueDirection: #south. parent messageArea contents: 's' ].	key = 29 "right blue"		ifTrue: [ parent model blueDirection: #east. parent messageArea contents: 'e' ].	key = 28 "left blue"		ifTrue: [ parent model blueDirection: #west. parent messageArea contents: 'w' ].	key = 119 "red up (w)"		ifTrue: [ parent model redDirection: #north ].	key = 115 "red down (s)"		ifTrue: [ parent model redDirection: #south ].	key = 100 "red right (d)"		ifTrue: [ parent model redDirection: #east ].	key = 97 "red left (a)"		ifTrue: [ parent model redDirection: #west ].! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 18:19' prior: 33836474!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[[winner isNil ] whileTrue: [ 		| delay |		delay := (Delay forMilliseconds: 250).		delay wait.		model executeStep.		winner := model checkWinner.	]] fork.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 18:19' prior: 33838021!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[[winner isNil ] whileTrue: [ 		| delay |		delay := (Delay forMilliseconds: 200).		delay wait.		model executeStep.		winner := model checkWinner.	]] fork.! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:20' prior: 33832401!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 0)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows: (firstCell row) at: (firstCell column)-1].	lastCell := ordered last.		playerColor := firstCell color.		newCell color: playerColor.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:20' prior: 33833931!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows: (firstCell row) at: (firstCell column)+1].	lastCell := ordered last.		playerColor := firstCell color.		newCell color: playerColor.	lastCell color: Color lightGray.		ordered addFirst: newCell.	ordered removeLast.! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:21' prior: 33839831!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)+1.			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.			].! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:21' prior: 33833423!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell row = 1)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [			newCell := board rows: (firstCell row)-1 at: (firstCell column).			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:22' prior: 33840342!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)+1.			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:22' prior: 33832912!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell row = 25)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [			newCell := board rows: (firstCell row)+1 at: (firstCell column).			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:23' prior: 33839321!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 0)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [ newCell := board rows: (firstCell row) at: (firstCell column)-1.			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.	].! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:24' prior: 33842458!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 0)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)-1.			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.	].! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:25' prior: 33842983!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 1)		ifTrue: [ "TODO catch collision with border" ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)-1.			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.	].! !!KeyListener methodsFor: 'keyboard control' stamp: 'Patrick 6/22/2017 18:26' prior: 33837126!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up blue"		ifTrue: [ parent model blueDirection: #north. parent messageArea contents: 'up' ].	key = 31 "down blue"		ifTrue: [ parent model blueDirection: #south. parent messageArea contents: 'down' ].	key = 29 "right blue"		ifTrue: [ parent model blueDirection: #east. parent messageArea contents: 'right' ].	key = 28 "left blue"		ifTrue: [ parent model blueDirection: #west. parent messageArea contents: 'left' ].	key = 119 "red up (w)"		ifTrue: [ parent model redDirection: #north. parent messageArea contents: 'w' ].	key = 115 "red down (s)"		ifTrue: [ parent model redDirection: #south. parent messageArea contents: 's' ].	key = 100 "red right (d)"		ifTrue: [ parent model redDirection: #east. parent messageArea contents: 'd' ].	key = 97 "red left (a)"		ifTrue: [ parent model redDirection: #west. parent messageArea contents: 'a' ].! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:26' prior: 33819123!executeStep	"TODO start with blue only"	blueDirection = #north		ifTrue: [ self moveNorth: blueCells ].	blueDirection = #south		ifTrue: [ self moveSouth: blueCells ].	blueDirection = #east		ifTrue: [ self moveEast: blueCells ].	blueDirection = #west		ifTrue: [ self moveWest: blueCells ].	"TODO here we want to do collision checks after movement"! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:26' prior: 33845091!executeStep	"TODO start with blue only"	"TODO currently runs into wall and then, keeps running into wall"	blueDirection = #north		ifTrue: [ self moveNorth: blueCells ].	blueDirection = #south		ifTrue: [ self moveSouth: blueCells ].	blueDirection = #east		ifTrue: [ self moveEast: blueCells ].	blueDirection = #west		ifTrue: [ self moveWest: blueCells ].	"TODO here we want to do collision checks after movement"! !!SnakeModel methodsFor: 'execution' stamp: 'Patrick 6/22/2017 18:27' prior: 33845536!executeStep	"TODO currently runs into wall and then, keeps running into wall"	blueDirection = #north		ifTrue: [ self moveNorth: blueCells ].	blueDirection = #south		ifTrue: [ self moveSouth: blueCells ].	blueDirection = #east		ifTrue: [ self moveEast: blueCells ].	blueDirection = #west		ifTrue: [ self moveWest: blueCells ].			redDirection = #north		ifTrue: [ self moveNorth: redCells ].	redDirection = #south		ifTrue: [ self moveSouth: redCells ].	redDirection = #east		ifTrue: [ self moveEast: redCells ].	redDirection = #west		ifTrue: [ self moveWest: redCells ].	"TODO here we want to do collision checks after movement"! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 18:30' prior: 33838670!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[[winner isNil ] whileTrue: [ 		| delay |		delay := (Delay forMilliseconds: 200).		delay wait.		model executeStep.		winner := model checkWinner.	]] fork.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 18:30' prior: 33846780!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		1 to: 3 do: [ :tailCell |			].		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[[winner isNil ] whileTrue: [ 		| delay |		delay := (Delay forMilliseconds: 200).		delay wait.		model executeStep.		winner := model checkWinner.	]] fork.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 18:32' prior: 33847429!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		1 to: 3 do: [ :tailCell |		| newCell |		newCell := rows at: (blueCell rows)	].		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[[winner isNil ] whileTrue: [ 		| delay |		delay := (Delay forMilliseconds: 200).		delay wait.		model executeStep.		winner := model checkWinner.	]] fork.! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 18:34' prior: 33848114!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		1 to: 3 do: [ :offset |		| newCell |		newCell := rows at: (blueCell row)+offset at: (blueCell column).		model blueCells addLast: newCell.		newCell := rows at: (redCell row)-offset at: (redCell column).		model redCells addLast: newCell.	].		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[[winner isNil ] whileTrue: [ 		| delay |		delay := (Delay forMilliseconds: 200).		delay wait.		model executeStep.		winner := model checkWinner.	]] fork.! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'Patrick 6/22/2017 18:34'!ruleRBLongMethodsRuleV1FalsePositive	^ #()! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'Patrick 6/22/2017 18:34' prior: 33849747!ruleRBLongMethodsRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#SnakeGame)) #'2017-06-22T18:34:05.757248+02:00') )! !!SnakeGame methodsFor: 'starting' stamp: 'Patrick 6/22/2017 18:34' prior: 33848848!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		1 to: 3 do: [ :offset |		| newCell |		newCell := (rows at: (blueCell row)+offset) at: (blueCell column).		model blueCells addLast: newCell.		newCell := (rows at: (redCell row)-offset) at: (redCell column).		model redCells addLast: newCell.	].		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[[winner isNil ] whileTrue: [ 		| delay |		delay := (Delay forMilliseconds: 200).		delay wait.		model executeStep.		winner := model checkWinner.	]] fork.! !----SNAPSHOT----2017-06-22T18:35:13.295248+02:00 Pharo6.1.image priorSource: 261875!----SNAPSHOT----2017-06-22T18:52:37.769248+02:00 Pharo6.1.image priorSource: 296486!!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:14' prior: 33843511!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 1)		ifTrue: [ self respawn ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)-1.			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.	].! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'ChristophGross 6/22/2017 23:16'!ruleRBSelfSentNotImplementedRuleV1FalsePositive	^ #()! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'ChristophGross 6/22/2017 23:16' prior: 33851697!ruleRBSelfSentNotImplementedRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#SnakeModel)) #'2017-06-22T23:16:11.6956+02:00') )! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'ChristophGross 6/22/2017 23:16'!ruleRBSentNotImplementedRuleV1FalsePositive	^ #()! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'ChristophGross 6/22/2017 23:16' prior: 33852089!ruleRBSentNotImplementedRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#SnakeModel)) #'2017-06-22T23:16:14.409302+02:00') )! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:16' prior: 33851184!moveEast: ordered	| firstCell newCell lastCell playerColor |	self haltIfNil.	firstCell := ordered first.	firstCell column = 1		ifTrue: [ self respawn ]		ifFalse: [ newCell := board rows: firstCell row at: firstCell column - 1.			lastCell := ordered last.			playerColor := firstCell color.			newCell color: playerColor.			lastCell color: Color lightGray.			ordered addFirst: newCell.			ordered removeLast ]! !!SnakeModel methodsFor: 'as yet unclassified' stamp: 'ChristophGross 6/22/2017 23:22'!respawn	"respawns the snake on a fixed point (depending on color)"! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:24' prior: 33841930!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell row = 25)		ifTrue: [ self respawn ]		ifFalse: [			newCell := board rows: (firstCell row)+1 at: (firstCell column).			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:25' prior: 33840873!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell row = 1)		ifTrue: [ self respawn ]		ifFalse: [			newCell := board rows: (firstCell row)-1 at: (firstCell column).			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:25' prior: 33841400!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ self respawn ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)+1.			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !----QUIT----2017-06-22T23:25:30.93288+02:00 Pharo6.1.image priorSource: 296572!----QUIT----2017-06-22T23:26:13.602676+02:00 Pharo6.1.image priorSource: 300161!!SnakeModel methodsFor: 'as yet unclassified' stamp: 'ChristophGross 6/22/2017 23:27'!respawn	"respawns a snake to its fixed starting location"! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:27' prior: 33843511!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 1)		ifTrue: [ self respawn ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)-1.			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:27' prior: 33841930!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell row = 25)		ifTrue: [ self respawn ]		ifFalse: [			newCell := board rows: (firstCell row)+1 at: (firstCell column).			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:28' prior: 33840873!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell row = 1)		ifTrue: [ self respawn ]		ifFalse: [			newCell := board rows: (firstCell row)-1 at: (firstCell column).			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:28' prior: 33841400!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ self respawn ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)+1.			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:31' prior: 33854844!respawn	"respawns a snake to its fixed starting location"	! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:32'!respawn: cells	"respawns a snake to its fixed starting location"	(cells color)! !SnakeModel removeSelector: #respawn:!!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:37' prior: 33857052!respawn	"respawns a snake to its fixed starting location"	! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:40' prior: 33857411!respawn OrderedCollection snake	"respawns a snake to its fixed starting location"	! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:43'!respawn: ordered	"respawns a snake to its fixed starting location"! !SnakeModel removeSelector: #respawn!!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:44' prior: 33856537!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ self respawn: ordered ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)+1.			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:44' prior: 33856025!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell row = 1)		ifTrue: [ self respawn: ordered ]		ifFalse: [			newCell := board rows: (firstCell row)-1 at: (firstCell column).			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:44' prior: 33855512!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell row = 25)		ifTrue: [ self respawn: ordered ]		ifFalse: [			newCell := board rows: (firstCell row)+1 at: (firstCell column).			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:44' prior: 33854999!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 1)		ifTrue: [ self respawn: ordered ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)-1.			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:47' prior: 33857935!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 25)		ifTrue: [ self respawn: ordered ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)+1.			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:49' prior: 33857733!respawn: ordered | firstCell playerColor lastCell |	"respawns a snake to its fixed starting location"! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/22/2017 23:49' prior: 33860548!respawn: ordered | firstCell playerColor |	"respawns a snake to its fixed starting location"! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:01'!respawn: firstCell color: playerColor | cell color |	"respawns a snake to its fixed starting location"		cell := firstCell.	color := playerColor.! !SnakeModel removeSelector: #respawn:!!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:02' prior: 33859502!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	(firstCell column = 1)		ifTrue: [ self respawn: ordered color: playerColor ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)-1.			lastCell := ordered last.				playerColor := firstCell color.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:03' prior: 33860921!respawn: firstCell color: playerColor | cell |	"respawns a snake to its fixed starting location"		cell := firstCell.	color := playerColor.! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:03' prior: 33861205!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 1)		ifTrue: [ self respawn: ordered color: playerColor ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)-1.			lastCell := ordered last.						newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:04' prior: 33858980!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 25)		ifTrue: [ self respawn: ordered ]		ifFalse: [			newCell := board rows: (firstCell row)+1 at: (firstCell column).			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:04' prior: 33862524!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 25)		ifTrue: [ self respawn: ordered color: playerColor  ]		ifFalse: [			newCell := board rows: (firstCell row)+1 at: (firstCell column).			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:04' prior: 33863042!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 25)		ifTrue: [ self respawn: ordered color: playerColor ]		ifFalse: [			newCell := board rows: (firstCell row)+1 at: (firstCell column).			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:04' prior: 33858459!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 1)		ifTrue: [ self respawn: ordered color: playerColor ]		ifFalse: [			newCell := board rows: (firstCell row)-1 at: (firstCell column).			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:05' prior: 33860024!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 25)		ifTrue: [ self respawn: ordered ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)+1.			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:05' prior: 33864653!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 25)		ifTrue: [ self respawn: ordered color: playerColor ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)+1.			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:08' prior: 33861746!respawn: firstCell color: playerColor	"respawns a snake to its fixed starting location"		color := playerColor.		! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:17' prior: 33865712!respawn: firstCell color: playerColor	"respawns a snake to its fixed starting location"		! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:19' prior: 33865926!respawn: firstCell color: playerColor	"respawns a snake to its fixed starting location"		(playerColor = Color red)  End of statement list encountered ->[ ]	! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:21' prior: 33866115!respawn: firstCell color: playerColor	"respawns a snake to its fixed starting location"		(playerColor = Color red)		ifTrue: [ ]		ifFalse: [ ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:27' prior: 33866372!respawn: firstCell color: playerColor	"respawns a snake to its fixed starting location"		(playerColor = Color red)		ifTrue: [ ]		ifFalse: [ ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:32'!respawn: ordered	"respawns a snake to its fixed starting location"	| firstCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(playerColor = Color red)		ifTrue: [ ]		ifFalse: [ ]! !SnakeModel removeSelector: #respawn:color:!!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:32' prior: 33861985!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 1)		ifTrue: [ self respawn: ordered ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)-1.			lastCell := ordered last.						newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:33' prior: 33863580!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 25)		ifTrue: [ self respawn: ordered ]		ifFalse: [			newCell := board rows: (firstCell row)+1 at: (firstCell column).			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:33' prior: 33864117!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 1)		ifTrue: [ self respawn: ordered ]		ifFalse: [			newCell := board rows: (firstCell row)-1 at: (firstCell column).			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:33' prior: 33865173!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 25)		ifTrue: [ self respawn: ordered ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)+1.			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:33' prior: 33866842!respawn: ordered	"respawns a snake to its fixed starting location"	| firstCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(playerColor = Color red)		ifTrue: [ ]		ifFalse: [ ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:34' prior: 33869271!respawn: ordered	"respawns a snake to its fixed starting location"	| firstCell playerColor snakeSize |	firstCell := ordered first.	playerColor := firstCell color.	(playerColor = Color red)		ifTrue: [ ]		ifFalse: [ ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:34' prior: 33869582!respawn: ordered	"respawns a snake to its fixed starting location"	| firstCell playerColor snakeSize |	firstCell := ordered first.	playerColor := firstCell color.	snakeSize := ordered size.		(playerColor = Color red)		ifTrue: [ ]		ifFalse: [ ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:35' prior: 33869903!respawn: ordered	"respawns a snake to its fixed starting location"	| firstCell playerColor snakeSize |	firstCell := ordered first.	playerColor := firstCell color.	snakeSize := ordered size.		1 to: snakeSize do: 		(playerColor = Color red)		ifTrue: [ ]		ifFalse: [ ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:38' prior: 33870253!respawn: ordered	"respawns a snake to its fixed starting location"	| firstCell playerColor snakeSize |	firstCell := ordered first.	playerColor := firstCell color.	snakeSize := ordered size.		1 to: snakeSize do: [ ordered removeLast ]		 End of statement list encountered ->(playerColor = Color red)		ifTrue: [ ]		ifFalse: [ ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:38' prior: 33870627!respawn: ordered	"respawns a snake to its fixed starting location"	| firstCell playerColor snakeSize |	firstCell := ordered first.	playerColor := firstCell color.	snakeSize := ordered size.		1 to: snakeSize do: [ ordered removeLast ].		(playerColor = Color red)		ifTrue: [ ]		ifFalse: [ ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:38' prior: 33871060!respawn: ordered	"respawns a snake to its fixed starting location"	| firstCell playerColor snakeSize |	firstCell := ordered first.	playerColor := firstCell color.	snakeSize := ordered size.		1 to: snakeSize-1 do: [ ordered removeLast ].		(playerColor = Color red)		ifTrue: [ ]		ifFalse: [ ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:46' prior: 33871457!respawn: ordered	"respawns a snake to its fixed starting location"	| firstCell playerColor snakeSize |	firstCell := ordered first.	playerColor := firstCell color.	snakeSize := ordered size.		1 to: snakeSize-1 do: [ ordered removeLast ].		(playerColor = Color red)		ifTrue: [ ]		ifFalse: [ ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:49' prior: 33871856!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell playerColor snakeSize |	(playerColor = Color red)		ifTrue: [ cells := redCells ]		ifFalse: [ cells := blueCells ].		firstCell := cells first.	playerColor := firstCell color.	snakeSize := cells size.		1 to: snakeSize-1 do: [ cells removeLast ].	! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:49' prior: 33872255!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell playerColor snakeSize |	(cellColor = Color red)		ifTrue: [ cells := redCells ]		ifFalse: [ cells := blueCells ].		firstCell := cells first.	playerColor := firstCell color.	snakeSize := cells size.		1 to: snakeSize-1 do: [ cells removeLast ].	! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:49' prior: 33872697!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize |	(cellColor = Color red)		ifTrue: [ cells := redCells ]		ifFalse: [ cells := blueCells ].		firstCell := cells first.	snakeSize := cells size.		1 to: snakeSize-1 do: [ cells removeLast ].	! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:49' prior: 33868751!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)+1.			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:49' prior: 33868234!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [			newCell := board rows: (firstCell row)-1 at: (firstCell column).			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:50' prior: 33867716!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [			newCell := board rows: (firstCell row)+1 at: (firstCell column).			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:50' prior: 33867196!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)-1.			lastCell := ordered last.						newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:54' prior: 33873137!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace = 6 ]		ifFalse: [ cells := blueCells. spawnPlace = 20 ].		firstCell := cells first.	snakeSize := cells size.		1 to: snakeSize-1 do: [ cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.		! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:55' prior: 33875623!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		1 to: snakeSize-1 do: [ cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.		! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:57' prior: 33876127!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		1 to: snakeSize-1 do: [ cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.			"1 to: snakeSize-1 do: [ :offset |		cells add:   Variable or expression expected ->]. Variable or expression expected ->"! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:59' prior: 33876633!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		1 to: snakeSize-1 do: [ cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.			"1 to: snakeSize-1 do: [ :offset |		cells add:   Variable or expression expected ->]. Variable or expression expected ->"	1 to: snakeSize-1 do: [ :offset |		| newCell |		newCell := (SnakeGame rows at: (firstCell row)+offset) at: (firstCell column).	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 00:59' prior: 33877260!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		1 to: snakeSize-1 do: [ cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.			1 to: snakeSize-1 do: [ :offset |		| newCell |		newCell := (SnakeGame rows at: (firstCell row)+offset) at: (firstCell column).	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 01:18' prior: 33878021!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		1 to: (snakeSize-1) do: [ cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.			1 to: (snakeSize-1) do: [ :offset |		| newCell |		newCell := (SnakeGame rows at: (firstCell row)+offset) at: (firstCell column).	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 01:19' prior: 33878658!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		1 to: 3 do: [ cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.			1 to: 3 do: [ :offset |		| newCell |		newCell := (SnakeGame rows at: (firstCell row)+offset) at: (firstCell column).	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 01:22' prior: 33879299!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		1 to: 2 do: [ cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.			1 to: 2 do: [ :offset |		| newCell |		newCell := (SnakeGame rows at: (firstCell row)+offset) at: (firstCell column).		cells add: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 01:24' prior: 33879916!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		1 to: 3 do: [ cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.			1 to: 3 do: [ :offset |		| newCell |		newCell := (SnakeGame rows at: (firstCell row)+offset) at: (firstCell column).		cells add: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 01:24' prior: 33880554!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		1 to: (snakeSize - 1) do: [ cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.			1 to: (snakeSize - 1) do: [ :offset |		| newCell |		newCell := (SnakeGame rows at: (firstCell row)+offset) at: (firstCell column).		cells add: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 01:28' prior: 33881192!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		1 to: (snakeSize - 1) do: [ cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.			1 to: (snakeSize - 1) do: [ :offset |		| newCell |		newCell := (SnakeGame rows at: (firstCell row)+offset) at: (firstCell column).		cells addLast: newCell	].! !----SNAPSHOT----2017-06-23T01:35:03.285273+02:00 Pharo6.1.image priorSource: 296572!----SNAPSHOT----2017-06-23T01:35:08.738025+02:00 Pharo6.1.image priorSource: 328002!----SNAPSHOT----2017-06-23T01:35:13.757264+02:00 Pharo6.1.image priorSource: 328088!----SNAPSHOT----2017-06-23T01:35:16.289428+02:00 Pharo6.1.image priorSource: 328174!----QUIT----2017-06-23T01:35:23.719223+02:00 Pharo6.1.image priorSource: 328260!!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 13:04' prior: 33881858!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		Transcript show: snakeSize.		1 to: (snakeSize - 1) do: [ cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.			1 to: (snakeSize - 1) do: [ :offset |		| newCell |		newCell := (SnakeGame rows at: (firstCell row)+offset) at: (firstCell column).		cells addLast: newCell	].! !----QUIT----2017-06-23T13:06:52.730416+02:00 Pharo6.1.image priorSource: 328346!!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 13:10' prior: 33882954!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		Transcript show: 'SnakeSize: '++snakeSize.		1 to: (snakeSize - 1) do: [ cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.			1 to: (snakeSize - 1) do: [ :offset |		| newCell |		newCell := (SnakeGame rows at: (firstCell row)+offset) at: (firstCell column).		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 13:11' prior: 33883737!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		Transcript show: 'SnakeSize: '+snakeSize.		1 to: (snakeSize - 1) do: [ cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.			1 to: (snakeSize - 1) do: [ :offset |		| newCell |		newCell := (SnakeGame rows at: (firstCell row)+offset) at: (firstCell column).		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 13:13' prior: 33884453!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		Transcript show: 'SnakeSize:'.	Transcript show: snakeSize.		1 to: (snakeSize - 1) do: [ cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.			1 to: (snakeSize - 1) do: [ :offset |		| newCell |		newCell := (SnakeGame rows at: (firstCell row)+offset) at: (firstCell column).		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 13:17' prior: 33885168!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		Transcript show: 'SnakeSize:'.	Transcript show: snakeSize.		1 to: (snakeSize - 1) do: [ :x | cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.			1 to: (snakeSize - 1) do: [ :offset |		| newCell |		newCell := (SnakeGame rows at: (firstCell row)+offset) at: (firstCell column).		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 13:18' prior: 33885901!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		Transcript show: 'SnakeSize:'.	Transcript show: snakeSize.		1 to: (snakeSize - 1) do: [ :x | cells removeLast ].		firstCell := (SnakeGame rows at: spawnPlace) at: spawnPlace.			1 to: (snakeSize - 1) do: [ :offset |		| newCell |		newCell := (SnakeGame rows at: (firstCell row)+offset) at: (firstCell column).		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 13:26' prior: 33886639!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		Transcript show: 'SnakeSize:'.	Transcript show: snakeSize.		1 to: (snakeSize - 1) do: [ :x | cells removeLast ].		firstCell := (board rows at: spawnPlace) at: spawnPlace.			1 to: (snakeSize - 1) do: [ :offset |		| newCell |		newCell := (board rows at: (firstCell row)+offset) at: (firstCell column).		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 13:32' prior: 33887377!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].		firstCell := cells first.	snakeSize := cells size.		Transcript show: 'SnakeSize:'.	Transcript show: snakeSize.		1 to: (snakeSize - 1) do: [ :x | cells removeLast ].		firstCell := (board rows at: spawnPlace) at: spawnPlace.			1 to: (snakeSize - 1) do: [ :offset |		| newCell |		newCell := (board rows at: (firstCell row)+offset) at: (firstCell column).		cells addLast: newCell	].	(cellColor = Color red)		ifTrue: [ redCells := cells ]		ifFalse: [ blueCells := cells ]! !----QUIT----2017-06-23T13:42:04.86568+02:00 Pharo6.1.image priorSource: 329129!!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 13:42' prior: 33888107!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	cellColor = Color red		ifTrue: [ cells := redCells.			spawnPlace := 6 ]		ifFalse: [ cells := blueCells.			spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	Transcript show: snakeSize.	1 to: snakeSize - 1 do: [ :x | cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset)			at: firstCell column.		cells addLast: newCell ].	cellColor = Color red		ifTrue: [ redCells := cells ]		ifFalse: [ blueCells := cells ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 13:57' prior: 33889010!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	Transcript show: snakeSize.	1 to: snakeSize - 1 do: [ :x | cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   cells addLast: newCell	].		(cellColor = Color red)		ifTrue: [ redCells := cells ]		ifFalse: [ blueCells := cells ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 13:57' prior: 33889789!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	Transcript show: snakeSize.	1 to: snakeSize - 1 do: [ :x | cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   cells addLast: newCell	].		(cellColor = Color red)		ifTrue: [ redCells := cells ]		ifFalse: [ blueCells := cells ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 13:58' prior: 33890571!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	Transcript show: snakeSize.	1 to: snakeSize - 1 do: [ :x | cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   cells addLast: newCell	].		(cellColor = Color red)		ifTrue: [ redCells := cells ]		ifFalse: [ blueCells := cells ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:00' prior: 33891354!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	Transcript show: snakeSize.	1 to: snakeSize - 1 do: [ :x | cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   cells addLast: newCell	].		(cellColor = Color red)		ifTrue: [ redCells := cells deepCopy]		ifFalse: [ blueCells := cells deepCopy]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:00' prior: 33892137!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	Transcript show: snakeSize.	1 to: snakeSize - 1 do: [ :x | cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   cells addLast: newCell	].		(cellColor = Color red)		ifTrue: [ redCells := cells veryDeepCopy]		ifFalse: [ blueCells := cells veryDeepCopy]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:01' prior: 33892936!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	Transcript show: snakeSize.	1 to: snakeSize - 1 do: [ :x | cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:04' prior: 33893743!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	Transcript show: snakeSize.	(snakeSize - 1) timesRepeat: [ cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   cells addLast: newCell	].! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'ChristophGross 6/23/2017 14:04'!ruleRBCodeCruftLeftInMethodsRuleV1FalsePositive	^ #()! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'ChristophGross 6/23/2017 14:04' prior: 33895123!ruleRBCodeCruftLeftInMethodsRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#SnakeModel)) #'2017-06-23T14:04:45.129841+02:00') )! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:05' prior: 33894433!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	Transcript crShow: snakeSize.	(snakeSize - 1) timesRepeat: [ cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:06' prior: 33895517!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	Transcript crShow: snakeSize asString.	(snakeSize - 1) timesRepeat: [ cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:08' prior: 33896209!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	Transcript crShow: 'TEST TEST'.	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	Transcript crShow: snakeSize asString.	(snakeSize - 1) timesRepeat: [ cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:16' prior: 33896910!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	(snakeSize - 1) timesRepeat: [ cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:21' prior: 33897642!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	board messageArea: snakeSize asString.	(snakeSize - 1) timesRepeat: [ cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:23' prior: 33898301!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	board messageArea: 'test'.	(snakeSize - 1) timesRepeat: [ cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:27' prior: 33899001!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	board messageArea contents: snakeSize.	(snakeSize - 1) timesRepeat: [ cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:27' prior: 33899689!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |	(cellColor = Color red)		ifTrue: [ cells := redCells. spawnPlace := 6 ]		ifFalse: [ cells := blueCells. spawnPlace := 20 ].	firstCell := cells first.	snakeSize := cells size.	board messageArea contents: snakeSize asString.	(snakeSize - 1) timesRepeat: [ cells removeLast ].	firstCell := (board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:35' prior: 33900389!respawn: cellColor	"respawns a snake to its fixed starting location"	| newCells firstCell snakeSize spawnPlace |		newCells := OrderedCollection new.		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size ].	board messageArea contents: snakeSize asString.	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	   newCells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:41' prior: 33901098!respawn: cellColor	"respawns a snake to its fixed starting location"	| cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	board messageArea contents: snakeSize asString.	[ cells size = 0 ] whileFalse: [ cells removeLast ].	1 to: snakeSize - 1 do: [ :offset | 		| newCell |		newCell := (board rows at: firstCell row + offset) at: firstCell column.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:42' prior: 33901707!respawn: cellColor	"respawns a snake to its fixed starting location"	| newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	board messageArea contents: snakeSize asString.	[ cells size = 0 ] whileFalse: [ cells removeLast ].	newCell := 	(board rows at: spawnPlace) at: spawnPlace.	1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: firstCell row + offset) at: firstCell column.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:42' prior: 33902339!respawn: cellColor	"respawns a snake to its fixed starting location"	| newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	board messageArea contents: snakeSize asString.	[ cells size = 0 ] whileFalse: [ cells removeLast ].	newCell := 	(board rows at: spawnPlace) at: spawnPlace.	cells add: newCell.	1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: firstCell row + offset) at: firstCell column.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:43' prior: 33903022!respawn: cellColor	"respawns a snake to its fixed starting location"	| newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	board messageArea contents: snakeSize asString.	[ cells size = 0 ] whileFalse: [ cells removeLast ].	newCell := 	(board rows at: spawnPlace) at: spawnPlace.	newCell color: Color red.	cells add: newCell.	1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: firstCell row + offset) at: firstCell column.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:43' prior: 33903726!respawn: cellColor	"respawns a snake to its fixed starting location"	| newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	board messageArea contents: snakeSize asString.	[ cells size = 0 ] whileFalse: [ cells removeLast ].	newCell := 	(board rows at: spawnPlace) at: spawnPlace.	newCell color: cellColor.	cells add: newCell.	1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: firstCell row + offset) at: firstCell column.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:44' prior: 33904457!respawn: cellColor	"respawns a snake to its fixed starting location"	| newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	board messageArea contents: snakeSize asString.	[ cells size = 0 ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].	newCell := 	(board rows at: spawnPlace) at: spawnPlace.	newCell color: cellColor.	cells add: newCell.	1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: firstCell row + offset) at: firstCell column.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:45' prior: 33905188!respawn: cellColor	"respawns a snake to its fixed starting location"	| newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	board messageArea contents: snakeSize asString.	[ cells size = 0 ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].	newCell := 	(board rows at: spawnPlace) at: spawnPlace.	newCell color: cellColor.	cells add: newCell.	firstCell := cells first.		1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: firstCell row + offset) at: firstCell column.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:46' prior: 33905954!respawn: cellColor	"respawns a snake to its fixed starting location"	| newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	board messageArea contents: snakeSize asString.	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].	newCell := 	(board rows at: spawnPlace) at: spawnPlace.	newCell color: cellColor.	cells add: newCell.	firstCell := cells first.		1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: firstCell row + offset) at: firstCell column.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:46' prior: 33906749!respawn: cellColor	"respawns a snake to its fixed starting location"	| newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	board messageArea contents: snakeSize asString.	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].	newCell := 	(board rows at: spawnPlace) at: spawnPlace.	newCell color: cellColor.	cells add: newCell.	firstCell := cells first.		1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: firstCell row + offset) at: firstCell column.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:52' prior: 33907543!respawn: cellColor	"respawns a snake to its fixed starting location"	| newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	board messageArea streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor ].	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].	newCell := 	(board rows at: spawnPlace) at: spawnPlace.	newCell color: cellColor.	cells add: newCell.	firstCell := cells first.		1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: firstCell row + offset) at: firstCell column.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:53' prior: 33908390!respawn: cellColor	"respawns a snake to its fixed starting location"	| newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	board messageArea contents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor ].	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].	newCell := 	(board rows at: spawnPlace) at: spawnPlace.	newCell color: cellColor.	cells add: newCell.	firstCell := cells first.		1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: firstCell row + offset) at: firstCell column.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:54' prior: 33909301!respawn: cellColor	"respawns a snake to its fixed starting location"	| msg newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	msg := [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].	newCell := 	(board rows at: spawnPlace) at: spawnPlace.	newCell color: cellColor.	cells add: newCell.	firstCell := cells first.		1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: firstCell row + offset) at: firstCell column.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:54' prior: 33910206!respawn: cellColor	"respawns a snake to its fixed starting location"	| msg newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].	newCell := 	(board rows at: spawnPlace) at: spawnPlace.	newCell color: cellColor.	cells add: newCell.	firstCell := cells first.		1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: firstCell row + offset) at: firstCell column.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:54' prior: 33911129!respawn: cellColor	"respawns a snake to its fixed starting location"	| msg newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].	newCell := 	(board rows at: spawnPlace) at: spawnPlace.	newCell color: cellColor.	cells add: newCell.	firstCell := cells first.		1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: firstCell row + offset) at: firstCell column.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:56' prior: 33912075!respawn: cellColor	"respawns a snake to its fixed starting location"	| msg newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].	newCell := 	(board rows at: spawnPlace) at: spawnPlace.	newCell color: cellColor.	cells add: newCell.	firstCell := cells first.		1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: spawnPlace row + offset) at: spawnPlace column.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:56' prior: 33913030!respawn: cellColor	"respawns a snake to its fixed starting location"	| msg newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].	newCell := 	(board rows at: spawnPlace) at: spawnPlace.	newCell color: cellColor.	cells add: newCell.	firstCell := cells first.		1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: spawnPlace + offset) at: spawnPlace.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:56' prior: 33913987!respawn: cellColor	"respawns a snake to its fixed starting location"	| msg newCell cells firstCell snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].	firstCell := cells first.		1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: spawnPlace + offset) at: spawnPlace.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:57' prior: 33914933!respawn: cellColor	"respawns a snake to its fixed starting location"	| msg newCell cells snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].		1 to: snakeSize - 1 do: [ :offset | 		newCell := (board rows at: spawnPlace + offset) at: spawnPlace.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:57' prior: 33915774!respawn: cellColor	"respawns a snake to its fixed starting location"	| msg newCell cells snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].		1 to: snakeSize  do: [ :offset | 		newCell := (board rows at: spawnPlace + offset) at: spawnPlace.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 14:57' prior: 33916577!respawn: cellColor	"respawns a snake to its fixed starting location"	| msg newCell cells snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].		1 to: snakeSize do: [ :offset | 		newCell := (board rows at: spawnPlace + offset) at: spawnPlace.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 15:03' prior: 33917377!respawn: cellColor	"respawns a snake to its fixed starting location"	| msg newCell cells snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells. self redDirection: 'w' ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].		1 to: snakeSize do: [ :offset | 		newCell := (board rows at: spawnPlace + offset) at: spawnPlace.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 15:04' prior: 33918176!respawn: cellColor	"respawns a snake to its fixed starting location"	| msg newCell cells snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells. self redDirection: #north ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells. self blueDirection: #south ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].		1 to: snakeSize do: [ :offset | 		newCell := (board rows at: spawnPlace + offset) at: spawnPlace.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 15:06' prior: 33918999!respawn: cellColor	"respawns a snake to its fixed starting location"	| msg newCell cells snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].		1 to: snakeSize do: [ :offset | 		newCell := (board rows at: spawnPlace + offset) at: spawnPlace.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 15:17' prior: 33919853!respawn: cellColor	"respawns a snake to its fixed starting location"	| msg newCell cells snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].		1 to: snakeSize do: [ :offset | 		newCell := (board rows at: spawnPlace + offset) at: spawnPlace.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 15:19' prior: 33846048!executeStep		blueDirection = #north		ifTrue: [ self moveNorth: blueCells ].	blueDirection = #south		ifTrue: [ self moveSouth: blueCells ].	blueDirection = #east		ifTrue: [ self moveEast: blueCells ].	blueDirection = #west		ifTrue: [ self moveWest: blueCells ].			redDirection = #north		ifTrue: [ self moveNorth: redCells ].	redDirection = #south		ifTrue: [ self moveSouth: redCells ].	redDirection = #east		ifTrue: [ self moveEast: redCells ].	redDirection = #west		ifTrue: [ self moveWest: redCells ].	"TODO here we want to do collision checks after movement"! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 15:21' prior: 33875099!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [			newCell := board rows: (firstCell row) at: (firstCell column)-1.			lastCell := ordered last.						newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 15:24' prior: 33920652!respawn: cellColor	"respawns a snake to its fixed starting location"	| offsetSign msg newCell cells snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells. offsetSign := -1 ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells. offsetSign := 1 ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].		1 to: snakeSize do: [ :offset | 		newCell := (board rows at: spawnPlace + offset) at: spawnPlace.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 15:24' prior: 33922651!respawn: cellColor	"respawns a snake to its fixed starting location"	| offsetSign msg newCell cells snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells. offsetSign := -1 ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells. offsetSign := 1 ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].		1 to: snakeSize do: [ :offset | 		newCell := (board rows at: spawnPlace + (offset*offsetSign)) at: spawnPlace.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 15:27' prior: 33923496!respawn: cellColor	"respawns a snake to its fixed starting location"	| offsetSign msg newCell cells snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells. offsetSign := (-1) ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells. offsetSign := 1 ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].		1 to: snakeSize do: [ :offset | 		newCell := (board rows at: spawnPlace + (offset*offsetSign)) at: spawnPlace.		newCell color: cellColor.		cells addLast: newCell	].! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'ChristophGross 6/23/2017 15:28' prior: 33849896!ruleRBLongMethodsRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#SnakeGame)) #'2017-06-22T18:34:05.757248+02:00') #(#(#RGClassDefinition #(#SnakeModel)) #'2017-06-23T15:28:20.207825+02:00') )! !----SNAPSHOT----2017-06-23T15:28:31.184904+02:00 Pharo6.1.image priorSource: 334403!!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 18:31' prior: 33924354!respawn: cellColor	"respawns a snake to its fixed starting location"	| offsetSign msg newCell cells snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells. redDirection := #north. offsetSign := (-1) ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells. blueDirection := #south. offsetSign := 1 ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].		1 to: snakeSize do: [ :offset | 		newCell := (board rows at: spawnPlace + (offset*offsetSign)) at: spawnPlace.		newCell color: cellColor.		cells addLast: newCell	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 18:34' prior: 33925607!respawn: cellColor	"respawns a snake to its fixed starting location"	| offsetSign msg newCell cells snakeSize spawnPlace |		(cellColor = Color red)		ifTrue: [ spawnPlace := 6. snakeSize := redCells size. cells := redCells. redDirection := #north. offsetSign := (-1) ]		ifFalse: [ spawnPlace := 20. snakeSize := blueCells size. cells := blueCells. blueDirection := #south. offsetSign := 1 ].	msg := String streamContents: [:stream | stream nextPutAll: 'respawn for snake: '; nextPutAll: cellColor asString ].	board messageArea contents: msg. 	[ cells isEmpty ] whileFalse: [ cells last color: Color lightGray. cells removeLast ].		1 to: snakeSize do: [ :offset | 		newCell := (board rows at: spawnPlace + (offset*offsetSign)) at: spawnPlace.		(cells isEmpty)			ifTrue: [newCell color: cellColor ]			ifFalse: [ newCell color: Color lightGray ].		cells addLast: newCell	].! !----SNAPSHOT----2017-06-23T18:35:10.884929+02:00 Pharo6.1.image priorSource: 370995!!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 18:48'!checkCollision: ordered col: playerColor	"checks for collisions with colored cells"	| col dir firstCell |		col := playerColor = Color red		ifTrue: [ dir := redDirection ]		ifFalse: [ dir := blueDirection ].		dir = #north		ifTrue: [  ].	dir = #south		ifTrue: [  ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 18:50' prior: 33927572!checkCollision: ordered col: playerColor	"checks for collisions with colored cells"	| col dir neighbour firstCell |		col := playerColor = Color red		ifTrue: [ dir := redDirection ]		ifFalse: [ dir := blueDirection ].	firstCell := ordered first.		dir = #north		ifTrue: [ 			neighbour := board rows: (firstCell row)+1 at: (firstCell column). 					].	dir = #south		ifTrue: [  ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 18:52' prior: 33927943!checkCollision: ordered col: playerColor	"checks for collisions with colored cells"	| col dir neighbour firstCell |		col := playerColor = Color red		ifTrue: [ dir := redDirection ]		ifFalse: [ dir := blueDirection ].	firstCell := ordered first.		dir = #north		ifTrue: [ 			neighbour := board rows: (firstCell row)+1 at: (firstCell column). 			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ].		].	dir = #south		ifTrue: [  ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 18:53' prior: 33928430!checkCollision: ordered col: playerColor	"checks for collisions with colored cells"	| col dir neighbour firstCell |		col := playerColor = Color red		ifTrue: [ dir := redDirection ]		ifFalse: [ dir := blueDirection ].	firstCell := ordered first.		dir = #north		ifTrue: [ 			neighbour := board rows: (firstCell row)+1 at: (firstCell column). 			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ].		].	dir = #south		ifTrue: [			neighbour := board rows: (firstCell row)-1 at: (firstCell column). 			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ].		].	dir = #east		ifTrue: [			neighbour := board rows: (firstCell row) at: (firstCell column)-1. 			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ].		].	dir = #west		ifTrue: [			neighbour := board rows: (firstCell row) at: (firstCell column)+1. 			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ].		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 18:55' prior: 33928989!checkCollision: ordered col: playerColor	"checks for collisions with colored cells"	| col dir neighbour firstCell |	col := dir := playerColor = Color red		ifTrue: [ redDirection ]		ifFalse: [ blueDirection ].	firstCell := ordered first.	dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #west		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column + 1.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 18:57' prior: 33930051!checkCollision: ordered col: playerColor	| col dir neighbour firstCell |	col := dir := playerColor = Color red		ifTrue: [ redDirection ]		ifFalse: [ blueDirection ].	firstCell := ordered first.	dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #west		ifFalse: [ ^ self ].	neighbour := board rows: firstCell row at: firstCell column + 1.	neighbour color = playerColor		ifTrue: [ self respawn: playerColor ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 18:59' prior: 33931064!checkCollision: ordered col: playerColor	| col dir neighbour firstCell |	col := playerColor = Color red		ifTrue: [ dir := redDirection ]		ifFalse: [ dir := blueDirection ].		firstCell := ordered first.	dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #west		ifFalse: [ ^ self ].	neighbour := board rows: firstCell row at: firstCell column + 1.	neighbour color = playerColor		ifTrue: [ self respawn: playerColor ]! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:01' prior: 33932038!checkCollision: ordered col: playerColor	| col dir neighbour firstCell |	col := playerColor = Color red		ifTrue: [ dir := redDirection ]		ifFalse: [ dir := blueDirection ].	firstCell := ordered first.		dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #west		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column + 1.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].		! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:04' prior: 33922127!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [						self checkCollision: ordered col: playerColor. 						newCell := board rows: (firstCell row) at: (firstCell column)-1.			lastCell := ordered last.						newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:06' prior: 33933022!checkCollision: ordered col: playerColor	| col dir neighbour firstCell |	col := playerColor = Color red		ifTrue: [ dir := redDirection ]		ifFalse: [ dir := blueDirection ].	firstCell := ordered first.		dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor. ^true ] ]				ifFalse: [ ^false]. 	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor. ^true ] ]				ifFalse: [ ^false].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor. ^true ] ]				ifFalse: [ ^false].	dir = #west		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column + 1.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor. ^true ] ]				ifFalse: [ ^false].		! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:09' prior: 33934587!checkCollision: ordered col: playerColor	| col dir neighbour firstCell |	col := playerColor = Color red		ifTrue: [ dir := redDirection ]		ifFalse: [ dir := blueDirection ].	firstCell := ordered first.		dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #west		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column + 1.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:10' prior: 33934004!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [						(self checkCollision: ordered col: playerColor)				ifTrue: [ ].						newCell := board rows: (firstCell row) at: (firstCell column)-1.			lastCell := ordered last.						newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:11' prior: 33936669!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [						(self checkCollision: ordered col: playerColor = playerColor)				ifTrue: [ self respawn: playerColor ].							newCell := board rows: (firstCell row) at: (firstCell column)-1.			lastCell := ordered last.						newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:12' prior: 33935690!checkCollision: ordered col: playerColor	| col dir neighbour firstCell |	col := playerColor = Color red		ifTrue: [ dir := redDirection ]		ifFalse: [ dir := blueDirection ].	firstCell := ordered first.		dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ] ].	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ] ].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].	dir = #west		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column + 1.			neighbour color = playerColor				ifTrue: [ self respawn: playerColor ] ].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:13' prior: 33937910!checkCollision: ordered col: playerColor	| col dir neighbour firstCell |	col := playerColor = Color red		ifTrue: [ dir := redDirection ]		ifFalse: [ dir := blueDirection ].	firstCell := ordered first.		dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ] ].	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ] ].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ] ].	dir = #west		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column + 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ] ].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:13' prior: 33938863!checkCollision: ordered col: playerColor	"TODO: at some point, add collision with other snake -> return other color"	| col dir neighbour firstCell |	col := playerColor = Color red		ifTrue: [ dir := redDirection ]		ifFalse: [ dir := blueDirection ].	firstCell := ordered first.		dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ] ].	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ] ].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ] ].	dir = #west		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column + 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ] ].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:14' prior: 33874577!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [						(self checkCollision: ordered col: playerColor = playerColor)				ifTrue: [ self respawn: playerColor ].						newCell := board rows: (firstCell row)+1 at: (firstCell column).			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:14' prior: 33874056!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [						(self checkCollision: ordered col: playerColor = playerColor)				ifTrue: [ self respawn: playerColor ].						newCell := board rows: (firstCell row)-1 at: (firstCell column).			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:15' prior: 33941432!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [						((self checkCollision: ordered col: playerColor) = playerColor)				ifTrue: [ self respawn: playerColor ].						newCell := board rows: (firstCell row)-1 at: (firstCell column).			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:15' prior: 33940794!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [						((self checkCollision: ordered col: playerColor) = playerColor)				ifTrue: [ self respawn: playerColor ].						newCell := board rows: (firstCell row)+1 at: (firstCell column).			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:15' prior: 33937269!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [						((self checkCollision: ordered col: playerColor) = playerColor)				ifTrue: [ self respawn: playerColor ].							newCell := board rows: (firstCell row) at: (firstCell column)-1.			lastCell := ordered last.						newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:15' prior: 33873532!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [						((self checkCollision: ordered col: playerColor) = playerColor)				ifTrue: [ self respawn: playerColor ].						newCell := board rows: (firstCell row) at: (firstCell column)+1.			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:18' prior: 33943991!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [						((self checkCollision: ordered col: playerColor) = playerColor)				ifTrue: [ self respawn: playerColor ].			newCell := board rows: (firstCell row) at: (firstCell column)+1.			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:19' prior: 33944633!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [						((self checkCollision: ordered col: playerColor) = playerColor)				ifTrue: [ self respawn: playerColor. ^self. ].							newCell := board rows: (firstCell row) at: (firstCell column)+1.			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:20' prior: 33945272!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [						((self checkCollision: ordered col: playerColor) = playerColor)				ifTrue: [ self respawn: playerColor ].							newCell := board rows: (firstCell row) at: (firstCell column)+1.			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:20' prior: 33945923!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [						((self checkCollision: ordered col: playerColor) = playerColor)				ifTrue: [ self respawn: playerColor ]				ifFalse: [					newCell := board rows: (firstCell row) at: (firstCell column)+1.					lastCell := ordered last.						newCell color: playerColor.					lastCell color: Color lightGray.							ordered addFirst: newCell.					ordered removeLast.				].		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:21' prior: 33942069!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [						((self checkCollision: ordered col: playerColor) = playerColor)				ifTrue: [ self respawn: playerColor ]				ifFalse: [ 								newCell := board rows: (firstCell row)-1 at: (firstCell column).					lastCell := ordered last.							newCell color: playerColor.					lastCell color: Color lightGray.						ordered addFirst: newCell.					ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:22' prior: 33947238!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					((self checkCollision: ordered col: playerColor) = playerColor)			ifTrue: [ self respawn: playerColor ]			ifFalse: [ 							newCell := board rows: (firstCell row)-1 at: (firstCell column).				lastCell := ordered last.					newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			].		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:22' prior: 33946566!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					((self checkCollision: ordered col: playerColor) = playerColor)			ifTrue: [ self respawn: playerColor ]			ifFalse: [				newCell := board rows: (firstCell row) at: (firstCell column)+1.				lastCell := ordered last.					newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			].		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:23' prior: 33942708!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [						((self checkCollision: ordered col: playerColor) = playerColor)				ifTrue: [ self respawn: playerColor ]				ifFalse: [ 						newCell := board rows: (firstCell row)+1 at: (firstCell column).			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:23' prior: 33949232!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					((self checkCollision: ordered col: playerColor) = playerColor)			ifTrue: [ self respawn: playerColor ]			ifFalse: [ 						newCell := board rows: (firstCell row)+1 at: (firstCell column).			lastCell := ordered last.				newCell color: playerColor.			lastCell color: Color lightGray.				ordered addFirst: newCell.			ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:23' prior: 33949892!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					((self checkCollision: ordered col: playerColor) = playerColor)			ifTrue: [ self respawn: playerColor ]			ifFalse: [ 				newCell := board rows: (firstCell row)+1 at: (firstCell column).				lastCell := ordered last.					newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:23' prior: 33943348!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					((self checkCollision: ordered col: playerColor) = playerColor)			ifTrue: [ self respawn: playerColor ]			ifFalse: [				newCell := board rows: (firstCell row) at: (firstCell column)-1.				lastCell := ordered last.							newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]	].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:24' prior: 33948571!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					((self checkCollision: ordered col: playerColor) = playerColor)			ifTrue: [ self respawn: playerColor ]			ifFalse: [				newCell := board rows: (firstCell row) at: (firstCell column)+1.				lastCell := ordered last.					newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:24' prior: 33947909!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					((self checkCollision: ordered col: playerColor) = playerColor)			ifTrue: [ self respawn: playerColor ]			ifFalse: [ 							newCell := board rows: (firstCell row)-1 at: (firstCell column).				lastCell := ordered last.					newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:24' prior: 33951208!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					((self checkCollision: ordered col: playerColor) = playerColor)			ifTrue: [ self respawn: playerColor ]			ifFalse: [				newCell := board rows: (firstCell row) at: (firstCell column)-1.				lastCell := ordered last.							newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !----QUIT----2017-06-23T19:24:56.432715+02:00 Pharo6.1.image priorSource: 372976!!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:35' prior: 33939790!checkCollision: ordered col: playerColor	"TODO: at some point, add collision with other snake -> return other color"	| col dir neighbour firstCell |	col := playerColor = Color red		ifTrue: [ dir := redDirection ]		ifFalse: [ dir := blueDirection ].	firstCell := ordered first.		dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ] ].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ] ].	dir = #west		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column + 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ] ].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:36' prior: 33953932!checkCollision: ordered col: playerColor	"TODO: at some point, add collision with other snake -> return other color"	| col dir neighbour firstCell |	col := playerColor = Color red		ifTrue: [ dir := redDirection ]		ifFalse: [ dir := blueDirection ].	firstCell := ordered first.		dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #west		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column + 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:37' prior: 33953189!moveEast: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					((self checkCollision: ordered col: playerColor) = playerColor)			ifTrue: [ self respawn: playerColor ].		((self checkCollision: ordered col: playerColor) = Color lightGray)			ifTrue: [				newCell := board rows: (firstCell row) at: (firstCell column)-1.				lastCell := ordered last.							newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:38' prior: 33950549!moveNorth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					((self checkCollision: ordered col: playerColor) = playerColor)			ifTrue: [ self respawn: playerColor ].		((self checkCollision: ordered col: playerColor) = Color lightGray)			ifTrue: [ 				newCell := board rows: (firstCell row)+1 at: (firstCell column).				lastCell := ordered last.					newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:38' prior: 33952528!moveSouth: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					((self checkCollision: ordered col: playerColor) = playerColor)			ifTrue: [ self respawn: playerColor ].		((self checkCollision: ordered col: playerColor) = Color lightGray)			ifTrue: [ 							newCell := board rows: (firstCell row)-1 at: (firstCell column).				lastCell := ordered last.					newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:39' prior: 33951868!moveWest: ordered	| firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					((self checkCollision: ordered col: playerColor) = playerColor)			ifTrue: [ self respawn: playerColor ].		((self checkCollision: ordered col: playerColor) = Color lightGray)			ifTrue: [				newCell := board rows: (firstCell row) at: (firstCell column)+1.				lastCell := ordered last.					newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:40' prior: 33955008!checkCollision: ordered col: playerColor	"TODO: at some point, add collision with other snake -> return other color"	"TODO: check auf neighbour color -> noch grau aber zugehrigkeit zu anderer schlange?"	| col dir neighbour firstCell |	col := playerColor = Color red		ifTrue: [ dir := redDirection ]		ifFalse: [ dir := blueDirection ].	firstCell := ordered first.		dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #west		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column + 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'ChristophGross 6/23/2017 19:40'!ruleRBGuardingClauseRuleV1FalsePositive	^ #()! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'ChristophGross 6/23/2017 19:40' prior: 33960602!ruleRBGuardingClauseRuleV1FalsePositive	^ #(#(#(#RGMethodDefinition #(#SnakeModel #checkCollision:col: #false)) #'2017-06-23T19:40:22.405144+02:00') )! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'ChristophGross 6/23/2017 19:40'!ruleRBAssignmentInIfTrueRuleV1FalsePositive	^ #()! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'ChristophGross 6/23/2017 19:40' prior: 33961009!ruleRBAssignmentInIfTrueRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#SnakeModel)) #'2017-06-23T19:40:25.543765+02:00') )! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'ChristophGross 6/23/2017 19:40'!ruleGRGuradGuardClauseRuleV1FalsePositive	^ #()! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'ChristophGross 6/23/2017 19:40' prior: 33961395!ruleGRGuradGuardClauseRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#SnakeModel)) #'2017-06-23T19:40:27.36282+02:00') )! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'ChristophGross 6/23/2017 19:40'!ruleGRTemporaryNeitherReadNorWrittenRuleV1FalsePositive	^ #()! !!Manifestsnakegame class methodsFor: 'code-critics' stamp: 'ChristophGross 6/23/2017 19:40' prior: 33961776!ruleGRTemporaryNeitherReadNorWrittenRuleV1FalsePositive	^ #(#(#(#RGClassDefinition #(#SnakeModel)) #'2017-06-23T19:40:29.746362+02:00') )! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:43' prior: 33959221!checkCollision: ordered col: playerColor	"TODO: at some point, add collision with other snake -> return other color"	"TODO: check auf neighbour color -> noch grau aber zugehrigkeit zu anderer schlange?"	| col oppCol dir neighbour firstCell oppColor |	col := playerColor = Color red		ifTrue: [ dir := redDirection ]		ifFalse: [ dir := blueDirection. oppColor := Color red ].	firstCell := ordered first.		dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #west		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column + 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:43' prior: 33962186!checkCollision: ordered col: playerColor	"TODO: at some point, add collision with other snake -> return other color"	"TODO: check auf neighbour color -> noch grau aber zugehrigkeit zu anderer schlange?"	| col oppCol dir neighbour firstCell |	col := playerColor = Color red		ifTrue: [ dir := redDirection. oppCol := Color blue ]		ifFalse: [ dir := blueDirection. oppCol := Color red ].	firstCell := ordered first.		dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #west		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column + 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:44' prior: 33963606!checkCollision: ordered col: playerColor	"TODO: at some point, add collision with other snake -> return other color"	"TODO: check auf neighbour color -> noch grau aber zugehrigkeit zu anderer schlange?"	| col oppCol dir neighbour firstCell |	col := playerColor = Color red		ifTrue: [ dir := redDirection. oppCol := Color blue ]		ifFalse: [ dir := blueDirection. oppCol := Color red ].	firstCell := ordered first.		dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = oppCol				ifTrue: [ ^oppCol ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #west		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column + 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:44' prior: 33965037!checkCollision: ordered col: playerColor	"TODO: at some point, add collision with other snake -> return other color"	"TODO: check auf neighbour color -> noch grau aber zugehrigkeit zu anderer schlange?"	| col oppCol dir neighbour firstCell |	col := playerColor = Color red		ifTrue: [ dir := redDirection. oppCol := Color blue ]		ifFalse: [ dir := blueDirection. oppCol := Color red ].	firstCell := ordered first.		dir = #north		ifTrue: [ neighbour := board rows: firstCell row + 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = oppCol				ifTrue: [ ^oppCol ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #south		ifTrue: [ neighbour := board rows: firstCell row - 1 at: firstCell column.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = oppCol				ifTrue: [ ^oppCol ].				neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #east		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column - 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = oppCol				ifTrue: [ ^oppCol ].				neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].	dir = #west		ifTrue: [ neighbour := board rows: firstCell row at: firstCell column + 1.			neighbour color = playerColor				ifTrue: [ ^playerColor ].			neighbour color = oppCol				ifTrue: [ ^oppCol ].			neighbour color = Color lightGray 				ifTrue: [ ^Color lightGray ] ].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:48' prior: 33956300!moveEast: ordered	| retCol firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [				retCol := self checkCollision: ordered col: playerColor.  					(retCol = playerColor)			ifTrue: [ self respawn: playerColor ].		(retCol = Color lightGray)			ifFalse: [ self respawn: retCol ]			ifTrue: [				newCell := board rows: (firstCell row) at: (firstCell column)-1.				lastCell := ordered last.							newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:49' prior: 33968166!moveEast: ordered	| retCol firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [				retCol := self checkCollision: ordered col: playerColor.  					(retCol = playerColor)			ifTrue: [ self respawn: playerColor ].		(retCol = Color lightGray)			ifFalse: [ self respawn: retCol ]			ifTrue: [				newCell := board rows: (firstCell row) at: (firstCell column)-1.				lastCell := ordered last.							newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:50' prior: 33957031!moveNorth: ordered	| firstCell newCell lastCell playerColor retCol |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					((self checkCollision: ordered col: playerColor) = playerColor)			ifTrue: [ self respawn: playerColor ].		((self checkCollision: ordered col: playerColor) = Color lightGray)			ifTrue: [ 				newCell := board rows: (firstCell row)+1 at: (firstCell column).				lastCell := ordered last.					newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:50' prior: 33968923!moveEast: ordered	| retCol firstCell newCell lastCell playerColor |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [				retCol := self checkCollision: ordered col: playerColor.  					(retCol = playerColor)			ifTrue: [ self respawn: playerColor ].		(retCol = Color lightGray)			ifFalse: [ self respawn: retCol ]			ifTrue: [				newCell := board rows: (firstCell row) at: (firstCell column)-1.				lastCell := ordered last.							newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:50' prior: 33969680!moveNorth: ordered	| firstCell newCell lastCell playerColor retCol |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					retCol := self checkCollision: ordered col: playerColor.					(retCol = playerColor)			ifTrue: [ self respawn: playerColor ].		(retCol = Color lightGray)			ifTrue: [ 				newCell := board rows: (firstCell row)+1 at: (firstCell column).				lastCell := ordered last.					newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:50' prior: 33971173!moveNorth: ordered	| firstCell newCell lastCell playerColor retCol |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					retCol := self checkCollision: ordered col: playerColor.					(retCol = playerColor)			ifTrue: [ self respawn: playerColor ].		(retCol = Color lightGray)			ifFalse: [ self respawn: retCol ]			ifTrue: [ 				newCell := board rows: (firstCell row)+1 at: (firstCell column).				lastCell := ordered last.					newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:51' prior: 33957760!moveSouth: ordered	| firstCell newCell lastCell playerColor retCol |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [				retCol := self checkCollision: ordered col: playerColor.					(retCol = playerColor)			ifTrue: [ self respawn: playerColor ].		(retCol = Color lightGray)			ifTrue: [ 							newCell := board rows: (firstCell row)-1 at: (firstCell column).				lastCell := ordered last.					newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:51' prior: 33972644!moveSouth: ordered	| firstCell newCell lastCell playerColor retCol |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell row = 1)		ifTrue: [ self respawn: playerColor ]		ifFalse: [				retCol := self checkCollision: ordered col: playerColor.					(retCol = playerColor)			ifTrue: [ self respawn: playerColor ].		(retCol = Color lightGray)			ifFalse: [ self respawn: retCol ]			ifTrue: [ 							newCell := board rows: (firstCell row)-1 at: (firstCell column).				lastCell := ordered last.					newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:51' prior: 33958491!moveWest: ordered	| firstCell newCell lastCell playerColor retCol |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					((self checkCollision: ordered col: playerColor) = playerColor)			ifTrue: [ self respawn: playerColor ].		((self checkCollision: ordered col: playerColor) = Color lightGray)			ifTrue: [				newCell := board rows: (firstCell row) at: (firstCell column)+1.				lastCell := ordered last.					newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !!SnakeModel methodsFor: 'execution' stamp: 'ChristophGross 6/23/2017 19:52' prior: 33974117!moveWest: ordered	| firstCell newCell lastCell playerColor retCol |	firstCell := ordered first.	playerColor := firstCell color.	(firstCell column = 25)		ifTrue: [ self respawn: playerColor ]		ifFalse: [					retCol := self checkCollision: ordered col: playerColor.				(retCol = playerColor)			ifTrue: [ self respawn: playerColor ].		(retCol = Color lightGray)			ifFalse: [ self respawn: retCol ]			ifTrue: [				newCell := board rows: (firstCell row) at: (firstCell column)+1.				lastCell := ordered last.					newCell color: playerColor.				lastCell color: Color lightGray.					ordered addFirst: newCell.				ordered removeLast.			]		].! !----QUIT----2017-06-23T19:53:33.609555+02:00 Pharo6.1.image priorSource: 399324!----SNAPSHOT----2017-06-24T16:00:52.694294+02:00 Pharo6.1.image priorSource: 421082!!KeyListener methodsFor: 'keyboard control' stamp: 'p 6/24/2017 16:01' prior: 33844047!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up red"		ifTrue: [ parent model redDirection: #north. parent messageArea contents: 'up' ].	key = 31 "down red"		ifTrue: [ parent model redDirection: #south. parent messageArea contents: 'down' ].	key = 29 "right red"		ifTrue: [ parent model redDirection: #east. parent messageArea contents: 'right' ].	key = 28 "left red"		ifTrue: [ parent model redDirection: #west. parent messageArea contents: 'left' ].	key = 119 "blue up (w)"		ifTrue: [ parent model blueDirection: #north. parent messageArea contents: 'w' ].	key = 115 "blue down (s)"		ifTrue: [ parent model blueDirection: #south. parent messageArea contents: 's' ].	key = 100 "blue right (d)"		ifTrue: [ parent model blueDirection: #east. parent messageArea contents: 'd' ].	key = 97 "blue left (a)"		ifTrue: [ parent model blueDirection: #west. parent messageArea contents: 'a' ].! !----SNAPSHOT----2017-06-24T16:02:24.670294+02:00 Pharo6.1.image priorSource: 421164!!SnakeGame methodsFor: 'initialize' stamp: 'p 6/24/2017 16:02' prior: 33815898!addControls	| rowMorph startBtn |	rowMorph := Morph new 		layoutPolicy: RowLayout new;		extent: 500@50;		color: Color transparent.	startBtn := self createButton: 'Start' onClickExecutes: [ self start ].	messageArea := self createTextArea: 'Welcome to Snake!! (arrow keys control red, WASD controls blue)'.	rowMorph addMorph: messageArea.	rowMorph addMorph: startBtn.	container addMorph: rowMorph.! !----SNAPSHOT----2017-06-24T16:02:27.249294+02:00 Pharo6.1.image priorSource: 422296!!SnakeGame methodsFor: 'starting' stamp: 'p 6/24/2017 16:08' prior: 33850102!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		1 to: 3 do: [ :offset |		| newCell |		newCell := (rows at: (blueCell row)+offset) at: (blueCell column).		model blueCells addLast: newCell.		newCell := (rows at: (redCell row)-offset) at: (redCell column).		model redCells addLast: newCell.	].		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[[winner isNil ] whileTrue: [ 		| delay |		delay := (Delay forMilliseconds: 200).		delay wait.		model executeStep.		winner := model checkWinner.	]] fork.! !----SNAPSHOT----2017-06-24T16:10:54.756294+02:00 Pharo6.1.image priorSource: 422872!!SnakeGame methodsFor: 'starting' stamp: 'p 6/24/2017 16:10' prior: 33977469!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		1 to: 3 do: [ :offset |		| newCell |		newCell := (rows at: (blueCell row)+offset) at: (blueCell column).		model blueCells addLast: newCell.		newCell := (rows at: (redCell row)-offset) at: (redCell column).		model redCells addLast: newCell.	].		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[[winner isNil ] whileTrue: [ 		| delay |		delay := (Delay forMilliseconds: 200).		delay wait.		model executeStep.		winner := model checkWinner.				winner notNil			ifTrue: [ messageArea contents: (winner, 'wins') ]	]] fork.! !!SnakeModel methodsFor: 'evaluation' stamp: 'p 6/24/2017 16:11' prior: 33830258!checkWinner "TODO evaluate a winner depending on snake stats --> TODO implement snake with stats"	^'Blue'.! !----SNAPSHOT----2017-06-24T16:11:25.818294+02:00 Pharo6.1.image priorSource: 423853!!SnakeGame methodsFor: 'starting' stamp: 'p 6/24/2017 16:11' prior: 33978450!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		1 to: 3 do: [ :offset |		| newCell |		newCell := (rows at: (blueCell row)+offset) at: (blueCell column).		model blueCells addLast: newCell.		newCell := (rows at: (redCell row)-offset) at: (redCell column).		model redCells addLast: newCell.	].		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[[winner isNil ] whileTrue: [ 		| delay |		delay := (Delay forMilliseconds: 200).		delay wait.		model executeStep.		winner := model checkWinner.				winner notNil			ifTrue: [ messageArea contents: (winner, ' wins!!') ]	]] fork.! !----SNAPSHOT----2017-06-24T16:11:58.166294+02:00 Pharo6.1.image priorSource: 425099!----SNAPSHOT----2017-06-24T16:12:25.810294+02:00 Pharo6.1.image priorSource: 426156!Matrix subclass: #SnakeModel	instanceVariableNames: 'board blueCells redCells blueDirection redDirection color timer'	classVariableNames: ''	package: 'snake_game'!----SNAPSHOT----2017-06-24T16:13:11.319294+02:00 Pharo6.1.image priorSource: 426242!!SnakeModel methodsFor: 'initialize' stamp: 'p 6/24/2017 16:13' prior: 33812111!initialize	super initialize.	blueDirection := #south.	redDirection := #north.	blueCells := OrderedCollection new.	redCells := OrderedCollection new.	timer := 100.! !----SNAPSHOT----2017-06-24T16:15:47.389294+02:00 Pharo6.1.image priorSource: 426496!!SnakeModel methodsFor: 'evaluation' stamp: 'p 6/24/2017 16:15' prior: 33979421!checkWinner "TODO evaluate a winner depending on snake stats --> TODO implement snake with stats"	(timer = 0 & ((redCells size) > (blueCells size)))		ifTrue: [ ^'Red' ]		ifFalse: [ 			((redCells size) < (blueCells size))				ifTrue: [ ^'Blue' ]					ifFalse: [ ^'No one' ].		].! !!SnakeModel methodsFor: 'execution' stamp: 'p 6/24/2017 16:16' prior: 33921451!executeStep		blueDirection = #north		ifTrue: [ self moveNorth: blueCells ].	blueDirection = #south		ifTrue: [ self moveSouth: blueCells ].	blueDirection = #east		ifTrue: [ self moveEast: blueCells ].	blueDirection = #west		ifTrue: [ self moveWest: blueCells ].			redDirection = #north		ifTrue: [ self moveNorth: redCells ].	redDirection = #south		ifTrue: [ self moveSouth: redCells ].	redDirection = #east		ifTrue: [ self moveEast: redCells ].	redDirection = #west		ifTrue: [ self moveWest: redCells ].		timer := timer - 1.! !----SNAPSHOT----2017-06-24T16:16:04.790294+02:00 Pharo6.1.image priorSource: 426835!----SNAPSHOT----2017-06-24T16:17:15.724294+02:00 Pharo6.1.image priorSource: 427915!!KeyListener methodsFor: 'keyboard control' stamp: 'p 6/24/2017 16:18' prior: 33975771!handleKeystroke: event "no clue how to actually use this"	| key |	key := event keyValue.	key = 30 "up red"		ifTrue: [ parent model redDirection: #north. "parent messageArea contents: 'up'" ].	key = 31 "down red"		ifTrue: [ parent model redDirection: #south. "parent messageArea contents: 'down'" ].	key = 29 "right red"		ifTrue: [ parent model redDirection: #east. "parent messageArea contents: 'right'" ].	key = 28 "left red"		ifTrue: [ parent model redDirection: #west. "parent messageArea contents: 'left'" ].	key = 119 "blue up (w)"		ifTrue: [ parent model blueDirection: #north. "parent messageArea contents: 'w'" ].	key = 115 "blue down (s)"		ifTrue: [ parent model blueDirection: #south. "parent messageArea contents: 's'" ].	key = 100 "blue right (d)"		ifTrue: [ parent model blueDirection: #east. "parent messageArea contents: 'd'" ].	key = 97 "blue left (a)"		ifTrue: [ parent model blueDirection: #west. "parent messageArea contents: 'a'" ].! !----SNAPSHOT----2017-06-24T16:18:30.442294+02:00 Pharo6.1.image priorSource: 428001!!SnakeModel methodsFor: 'execution' stamp: 'p 6/24/2017 16:18' prior: 33981801!executeStep		blueDirection = #north		ifTrue: [ self moveNorth: blueCells ].	blueDirection = #south		ifTrue: [ self moveSouth: blueCells ].	blueDirection = #east		ifTrue: [ self moveEast: blueCells ].	blueDirection = #west		ifTrue: [ self moveWest: blueCells ].			redDirection = #north		ifTrue: [ self moveNorth: redCells ].	redDirection = #south		ifTrue: [ self moveSouth: redCells ].	redDirection = #east		ifTrue: [ self moveEast: redCells ].	redDirection = #west		ifTrue: [ self moveWest: redCells ].		timer := timer - 1.	board messageArea contents: timer asString.! !----SNAPSHOT----2017-06-24T16:18:57.132294+02:00 Pharo6.1.image priorSource: 429149!----SNAPSHOT----2017-06-24T16:20:04.667294+02:00 Pharo6.1.image priorSource: 429907!!SnakeModel methodsFor: 'evaluation' stamp: 'p 6/24/2017 16:20' prior: 33981435!checkWinner "TODO evaluate a winner depending on snake stats --> TODO implement snake with stats"	(timer = 0 & ((redCells size) > (blueCells size)))		ifTrue: [ ^'Red' ]		ifFalse: [ 			((redCells size) < (blueCells size))				ifTrue: [ ^'Blue' ]					ifFalse: [ ^'No one' ].		].! !!SnakeGame methodsFor: 'starting' stamp: 'p 6/24/2017 16:21' prior: 33979696!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		1 to: 3 do: [ :offset |		| newCell |		newCell := (rows at: (blueCell row)+offset) at: (blueCell column).		model blueCells addLast: newCell.		newCell := (rows at: (redCell row)-offset) at: (redCell column).		model redCells addLast: newCell.	].		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[[winner isNil ] whileTrue: [ 		| delay |		delay := (Delay forMilliseconds: 200).		delay wait.		model executeStep.		winner := model checkWinner.				"winner notNil			ifTrue: [ messageArea contents: (winner, ' wins!!') ]"	]] fork.! !----SNAPSHOT----2017-06-24T16:21:23.695294+02:00 Pharo6.1.image priorSource: 429993!!SnakeGame methodsFor: 'starting' stamp: 'p 6/24/2017 16:22' prior: 33984957!start	| redCell blueCell winner |	"0/0 is right bottom corner, 25/25 left top corner"	redCell := (rows at: 6) at: 6.	blueCell := (rows at: 20) at: 20.	redCell color: Color red.	blueCell color: Color blue.		model blueCells addFirst: blueCell.	model redCells addFirst: redCell.		1 to: 3 do: [ :offset |		| newCell |		newCell := (rows at: (blueCell row)+offset) at: (blueCell column).		model blueCells addLast: newCell.		newCell := (rows at: (redCell row)-offset) at: (redCell column).		model redCells addLast: newCell.	].		keyListener takeKeyboardFocus.		winner := nil.		"the game loop code ought to give us a winner at some point"	[[winner isNil ] whileTrue: [ 		| delay |		delay := (Delay forMilliseconds: 200).		delay wait.		model executeStep.		winner := model checkWinner.				winner notNil			ifTrue: [ messageArea contents: (winner, ' wins!!') ]	]] fork.! !----SNAPSHOT----2017-06-24T16:22:02.705294+02:00 Pharo6.1.image priorSource: 431419!!SnakeModel methodsFor: 'evaluation' stamp: 'p 6/24/2017 16:22' prior: 33984593!checkWinner "TODO evaluate a winner depending on snake stats --> TODO implement snake with stats"	((timer = 0) & ((redCells size) > (blueCells size)))		ifTrue: [ ^'Red' ]		ifFalse: [ 			((redCells size) < (blueCells size))				ifTrue: [ ^'Blue' ]					ifFalse: [ ^'No one' ].		].! !----SNAPSHOT----2017-06-24T16:22:16.249294+02:00 Pharo6.1.image priorSource: 432476!!SnakeModel methodsFor: 'evaluation' stamp: 'p 6/24/2017 16:22' prior: 33987076!checkWinner "TODO evaluate a winner depending on snake stats --> TODO implement snake with stats"	((timer = 0) and: ((redCells size) > (blueCells size)))		ifTrue: [ ^'Red' ]		ifFalse: [ 			((redCells size) < (blueCells size))				ifTrue: [ ^'Blue' ]					ifFalse: [ ^'No one' ].		].! !----SNAPSHOT----2017-06-24T16:22:32.681294+02:00 Pharo6.1.image priorSource: 432931!!SnakeModel methodsFor: 'evaluation' stamp: 'p 6/24/2017 16:24' prior: 33987531!checkWinner "TODO evaluate a winner depending on snake stats --> TODO implement snake with stats"	timer = 0		ifTrue: [			(redCells size) > (blueCells size)				ifTrue: [ ^'Red' ]				ifFalse: [ 					(redCells size) < (blueCells size)						ifTrue: [ ^'Blue' ]							ifFalse: [ ^'No one' ].				].		].! !----SNAPSHOT----2017-06-24T16:24:16.599294+02:00 Pharo6.1.image priorSource: 433389!!SnakeModel methodsFor: 'evaluation' stamp: 'p 6/24/2017 16:26' prior: 33987989!checkWinner "TODO evaluate a winner depending on snake stats --> TODO implement snake with stats"	timer = 0		ifTrue: [			(redCells size) > (blueCells size)				ifTrue: [ ^'Red' ]				ifFalse: [ 					(redCells size) < (blueCells size)						ifTrue: [ ^'Blue' ]							ifFalse: [ ^'No one' ].				].		]		ifFalse: [ ^nil ].! !----SNAPSHOT----2017-06-24T16:26:06.395294+02:00 Pharo6.1.image priorSource: 433866!----SNAPSHOT----2017-06-24T16:26:40.123294+02:00 Pharo6.1.image priorSource: 434363!!SnakeModel methodsFor: 'initialize' stamp: 'p 6/24/2017 16:27' prior: 33981096!initialize	super initialize.	blueDirection := #south.	redDirection := #north.	blueCells := OrderedCollection new.	redCells := OrderedCollection new.	timer := 600.! !----SNAPSHOT----2017-06-24T16:27:45.591294+02:00 Pharo6.1.image priorSource: 434449!!SnakeModel methodsFor: 'execution' stamp: 'p 6/24/2017 16:27' prior: 33983748!executeStep		blueDirection = #north		ifTrue: [ self moveNorth: blueCells ].	blueDirection = #south		ifTrue: [ self moveSouth: blueCells ].	blueDirection = #east		ifTrue: [ self moveEast: blueCells ].	blueDirection = #west		ifTrue: [ self moveWest: blueCells ].			redDirection = #north		ifTrue: [ self moveNorth: redCells ].	redDirection = #south		ifTrue: [ self moveSouth: redCells ].	redDirection = #east		ifTrue: [ self moveEast: redCells ].	redDirection = #west		ifTrue: [ self moveWest: redCells ].		timer := timer - 1.	board messageArea contents: ('Time remaining: ', (timer/60) asString).! !!SnakeModel methodsFor: 'execution' stamp: 'p 6/24/2017 16:28' prior: 33989387!executeStep		blueDirection = #north		ifTrue: [ self moveNorth: blueCells ].	blueDirection = #south		ifTrue: [ self moveSouth: blueCells ].	blueDirection = #east		ifTrue: [ self moveEast: blueCells ].	blueDirection = #west		ifTrue: [ self moveWest: blueCells ].			redDirection = #north		ifTrue: [ self moveNorth: redCells ].	redDirection = #south		ifTrue: [ self moveSouth: redCells ].	redDirection = #east		ifTrue: [ self moveEast: redCells ].	redDirection = #west		ifTrue: [ self moveWest: redCells ].		timer := timer - 1.	board messageArea contents: ('Time remaining: ', ((timer/60)) asString).! !!SnakeModel methodsFor: 'execution' stamp: 'p 6/24/2017 16:29' prior: 33990086!executeStep	| remainingTime |		blueDirection = #north		ifTrue: [ self moveNorth: blueCells ].	blueDirection = #south		ifTrue: [ self moveSouth: blueCells ].	blueDirection = #east		ifTrue: [ self moveEast: blueCells ].	blueDirection = #west		ifTrue: [ self moveWest: blueCells ].			redDirection = #north		ifTrue: [ self moveNorth: redCells ].	redDirection = #south		ifTrue: [ self moveSouth: redCells ].	redDirection = #east		ifTrue: [ self moveEast: redCells ].	redDirection = #west		ifTrue: [ self moveWest: redCells ].		timer := timer - 1.	board messageArea contents: ('Steps remaining: ', timer/60 asString).! !----SNAPSHOT----2017-06-24T16:29:18.552294+02:00 Pharo6.1.image priorSource: 434788!!SnakeModel methodsFor: 'execution' stamp: 'p 6/24/2017 16:29'!executeSteps		blueDirection = #north		ifTrue: [ self moveNorth: blueCells ].	blueDirection = #south		ifTrue: [ self moveSouth: blueCells ].	blueDirection = #east		ifTrue: [ self moveEast: blueCells ].	blueDirection = #west		ifTrue: [ self moveWest: blueCells ].			redDirection = #north		ifTrue: [ self moveNorth: redCells ].	redDirection = #south		ifTrue: [ self moveSouth: redCells ].	redDirection = #east		ifTrue: [ self moveEast: redCells ].	redDirection = #west		ifTrue: [ self moveWest: redCells ].		timer := timer - 1.	board messageArea contents: ('Steps remaining: ', (timer asString)).! !----SNAPSHOT----2017-06-24T16:29:40.150294+02:00 Pharo6.1.image priorSource: 436991!----SNAPSHOT----2017-06-24T16:29:56.747294+02:00 Pharo6.1.image priorSource: 437759!!SnakeModel methodsFor: 'execution' stamp: 'p 6/24/2017 16:30' prior: 33990787!executeStep		blueDirection = #north		ifTrue: [ self moveNorth: blueCells ].	blueDirection = #south		ifTrue: [ self moveSouth: blueCells ].	blueDirection = #east		ifTrue: [ self moveEast: blueCells ].	blueDirection = #west		ifTrue: [ self moveWest: blueCells ].			redDirection = #north		ifTrue: [ self moveNorth: redCells ].	redDirection = #south		ifTrue: [ self moveSouth: redCells ].	redDirection = #east		ifTrue: [ self moveEast: redCells ].	redDirection = #west		ifTrue: [ self moveWest: redCells ].		timer := timer - 1.	board messageArea contents: ('Steps remaining: ', timer/60 asString).! !!SnakeModel methodsFor: 'execution' stamp: 'p 6/24/2017 16:30' prior: 33992444!executeStep		blueDirection = #north		ifTrue: [ self moveNorth: blueCells ].	blueDirection = #south		ifTrue: [ self moveSouth: blueCells ].	blueDirection = #east		ifTrue: [ self moveEast: blueCells ].	blueDirection = #west		ifTrue: [ self moveWest: blueCells ].			redDirection = #north		ifTrue: [ self moveNorth: redCells ].	redDirection = #south		ifTrue: [ self moveSouth: redCells ].	redDirection = #east		ifTrue: [ self moveEast: redCells ].	redDirection = #west		ifTrue: [ self moveWest: redCells ].		timer := timer - 1.	board messageArea contents: ('Steps remaining: ', (timer asString)).! !----SNAPSHOT----2017-06-24T16:30:37.364294+02:00 Pharo6.1.image priorSource: 437845!!SnakeModel methodsFor: 'initialize' stamp: 'p 6/24/2017 16:31' prior: 33989049!initialize	super initialize.	blueDirection := #south.	redDirection := #north.	blueCells := OrderedCollection new.	redCells := OrderedCollection new.	timer := 10.! !!SnakeModel methodsFor: 'initialize' stamp: 'p 6/24/2017 16:31' prior: 33993926!initialize	super initialize.	blueDirection := #south.	redDirection := #north.	blueCells := OrderedCollection new.	redCells := OrderedCollection new.	timer := 600.! !----SNAPSHOT----2017-06-24T16:31:24.944294+02:00 Pharo6.1.image priorSource: 439326!