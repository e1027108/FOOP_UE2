[31m
[0mProcess>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox: in Block: [ :hand | hand releaseKeyboardFocus ]
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[0m[31mInstance of SimpleHierarchicalListMorph did not understand #fillRectangle:fillStyle:borderStyle:
[0mSimpleHierarchicalListMorph(Object)>>doesNotUnderstand: #fillRectangle:fillStyle:borderStyle:
BorderedMorph(Morph)>>drawOn:
SimpleHierarchicalListMorph(Morph)>>drawKeyboardFocusOn:
SnakeGame>>addKeyListener
SnakeGame>>initialize
SnakeGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #drawKeyboardFocusOn:
[0mSnakeGame(Object)>>doesNotUnderstand: #drawKeyboardFocusOn:
SnakeGame>>addKeyListener
SnakeGame>>initialize
SnakeGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of TextMorph did not understand #content:
[0mTextMorph(Object)>>doesNotUnderstand: #content:
SnakeGame>>addKeyListener
SnakeGame>>initialize
SnakeGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of TextMorph did not understand #textArea
[0mTextMorph(Object)>>doesNotUnderstand: #textArea
SnakeGame>>addKeyListener
SnakeGame>>initialize
SnakeGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SimpleHierarchicalListMorph did not understand #fillRectangle:fillStyle:borderStyle:
[0mSimpleHierarchicalListMorph(Object)>>doesNotUnderstand: #fillRectangle:fillStyle:borderStyle:
BorderedMorph(Morph)>>drawOn:
SimpleHierarchicalListMorph(Morph)>>drawKeyboardFocusOn:
SnakeGame>>addKeyListener
SnakeGame>>initialize
SnakeGame class(Behavior)>>new
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea editor highlightEvaluateAndDo...etc...
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate: in Block: [ textMorph textArea...
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseDown:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseDown:
Morph>>handlesMouseDown:
Morph>>handlerForMouseDown:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
Morph>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
SystemWindow(Morph)>>processEvent:using:
MorphicEventDispatcher>>dispatchMouseDown:with:
MorphicEventDispatcher>>handleMouseDown:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with: in Block: [ ^ anEvent sentTo: self ]
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
WorldMorph(Morph)>>processEvent:using:
WorldMorph(Morph)>>processEvent:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[0m[31mInstance of SnakeGame did not understand #handlesMouseOverDragging:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOverDragging:
Morph>>handlesMouseOverDragging:
Morph>>handleMouseEnter:
MouseButtonEvent(MouseEvent)>>sentTo:
MouseButtonEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOverDragging:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOverDragging:
Morph>>handlesMouseOverDragging:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOverDragging:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOverDragging:
Morph>>handlesMouseOverDragging:
Morph>>handleMouseEnter:
MouseEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseButtonEvent(MouseEvent)>>sentTo:
MouseButtonEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31mInstance of SnakeGame did not understand #handlesMouseOver:
[0mSnakeGame(Object)>>doesNotUnderstand: #handlesMouseOver:
Morph>>handlesMouseOver:
Morph>>handleMouseEnter:
MouseMoveEvent(MouseEvent)>>sentTo:
MouseMoveEvent>>sentTo:
Morph>>handleEvent:
MouseOverHandler>>transform:from:andSendTo:
[ self transform: evt from: anEvent andSendTo: aLeftMorph ] in MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo: in Block: [ self transform: evt from: anEvent andSendTo: aLe...etc...
True>>ifTrue:ifFalse:
MouseOverHandler>>inform:to:originatedFrom:ifNotFocusedDo:
[ :anEnteredMorph | 
self
	inform: asMouseEnterEvent
	to: anEnteredMorph
	originatedFrom: anEvent
	ifNotFocusedDo: [  ] ] in MouseOverHandler>>handleAsMouseEnter: in Block: [ :anEnteredMorph | ...
Array(SequenceableCollection)>>reverseDo:
MouseOverHandler>>handleAsMouseEnter:
MouseOverHandler>>processMouseOver:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor: in Block: [ :h | ...
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess in Block: [ [ WorldMorph doOneCycle....
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess in Block: [ self value....
[0m[31m
[0mProcess>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver: in Block: [ action cull: anAnnouncement cull: announcer ]
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt: in Block: [ "Ensure delivery to remaining announcements" sub...etc...
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox: in Block: [ :hand | hand releaseKeyboardFocus ]
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[0m