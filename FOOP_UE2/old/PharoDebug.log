THERE_BE_DRAGONS_HERE
#theNonMetaClass was sent to nil
15 June 2017 3:03:41.769971 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

UndefinedObject(Object)>>doesNotUnderstand: #theNonMetaClass
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	theNonMetaClass
		exception: 	MessageNotUnderstood: receiver of "theNonMetaClass" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

ClassWidget>>selectClass:
	Receiver: a ClassWidget
	Arguments and temporary variables: 
		aClass: 	nil
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a FTPluggableIconListMorphAdaptor(223455744))
		announceur: 	nil
		model: 	a NautilusUI
		classesList: 	a FTPluggableIconListMorphAdaptor(223455744)
		classesSelection: 	a Dictionary()
		classesListElements: 	an OrderedCollection()
		cachedHierarchy: 	a SortHierarchically
		showHierarchy: 	false


NautilusUI>>selectedClassWithoutChangingSelectionInternally:
	Receiver: a NautilusUI
	Arguments and temporary variables: 
		aClass: 	nil
		package: 	a PackageTreeGroupSelection
		packageChanged: 	false
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		announceur: 	nil
		model: 	a Nautilus
		window: 	a NautilusWindow(199408128)
		sourceCodePanel: 	a PanelMorph(161901568)
		fullDisplayedComment: 	false
		sourceCodeContainer: 	a PanelMorph(219484672)
		shouldUpdateTitle: 	true
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		commentWidget: 	nil
		sourceTextWidget: 	a RubScrolledTextMorph(578405888)
		sourceCodeSelectionInterval: 	nil
		sourceTextModel: 	a RubScrolledTextModel
		methodClassifier: 	nil
		commentTextModel: 	a RubScrolledTextModel
		instanceButtonWidget: 	a PluggableToggleButtonMorph(684640256)
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageWidget
		packagePatternString: 	'Snake'
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(3174400)


NautilusHistoryEntry>>applyTo:
	Receiver: a NautilusHistoryEntry
	Arguments and temporary variables: 
		aNautilus: 	a Nautilus
		interface: 	a NautilusUI
	Receiver's instance variables: 
		selectedPackage: 	a PackageTreeGroupSelection
		selectedCategory: 	nil
		selectedSelector: 	nil
		selectedClass: 	nil
		selectedGroup: 	a MethodGroup ( Last Modified Methods )
		showHierarchy: 	false
		sortHierarchically: 	true
		showComment: 	false
		showInstance: 	true
		showCategories: 	true


[ anAssociation key applyTo: self ] in Nautilus>>adopt:
	Receiver: a Nautilus
	Arguments and temporary variables: 
		anAssociation: 	a NautilusHistoryEntry->2017-06-15T15:03:38.582971+02:00
	Receiver's instance variables: 
		announcer: 	an Announcer
		browsedEnvironment: 	Smalltalk
		browsingHistory: 	a NavigationHistory
		plugins: 	an OrderedCollection(a QANautilusPlugin)
		selectedCategory: 	nil
		selectedClass: 	nil
		selectedGroup: 	a MethodGroup ( Last Modified Methods )
		selectedMethod: 	nil
		selectedPackage: 	a PackageTreeGroupSelection
		showCategories: 	true
		showComment: 	false
		sortHierarchically: 	true
		showInstance: 	false
		showHierarchy: 	false
		ui: 	a NautilusUI
		methodClassifier: 	nil


BlockClosure>>ensure:
	Receiver: [ anAssociation key applyTo: self ]
	Arguments and temporary variables: 
		aBlock: 	[ paused := previousPausedValue ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	Nautilus>>adopt:
		startpc: 	36
		numArgs: 	0


NavigationHistory>>pauseDuring:
	Receiver: a NavigationHistory
	Arguments and temporary variables: 
		aBlock: 	[ anAssociation key applyTo: self ]
		previousPausedValue: 	false
	Receiver's instance variables: 
		storage: 	an OrderedCollection(a NautilusHistoryEntry->2017-06-15T15:03:38.58297...etc...
		index: 	1
		maxSize: 	15
		paused: 	true


Nautilus>>adopt:
	Receiver: a Nautilus
	Arguments and temporary variables: 
		anAssociation: 	a NautilusHistoryEntry->2017-06-15T15:03:38.582971+02:00
	Receiver's instance variables: 
		announcer: 	an Announcer
		browsedEnvironment: 	Smalltalk
		browsingHistory: 	a NavigationHistory
		plugins: 	an OrderedCollection(a QANautilusPlugin)
		selectedCategory: 	nil
		selectedClass: 	nil
		selectedGroup: 	a MethodGroup ( Last Modified Methods )
		selectedMethod: 	nil
		selectedPackage: 	a PackageTreeGroupSelection
		showCategories: 	true
		showComment: 	false
		sortHierarchically: 	true
		showInstance: 	false
		showHierarchy: 	false
		ui: 	a NautilusUI
		methodClassifier: 	nil


NautilusUI>>setHistory:
	Receiver: a NautilusUI
	Arguments and temporary variables: 
		anIndex: 	1
		entry: 	a NautilusHistoryEntry->2017-06-15T15:03:38.582971+02:00
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		announceur: 	nil
		model: 	a Nautilus
		window: 	a NautilusWindow(199408128)
		sourceCodePanel: 	a PanelMorph(161901568)
		fullDisplayedComment: 	false
		sourceCodeContainer: 	a PanelMorph(219484672)
		shouldUpdateTitle: 	true
		contentSelection: 	nil
		acceptor: 	a ClassDefinitionAcceptor
		commentWidget: 	nil
		sourceTextWidget: 	a RubScrolledTextMorph(578405888)
		sourceCodeSelectionInterval: 	nil
		sourceTextModel: 	a RubScrolledTextModel
		methodClassifier: 	nil
		commentTextModel: 	a RubScrolledTextModel
		instanceButtonWidget: 	a PluggableToggleButtonMorph(684640256)
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageWidget
		packagePatternString: 	'Snake'
		packagePattern: 	a RxMatcher
		searchWidget: 	a SearchMorph(3174400)


DropListMorph>>listSelectionIndex:
	Receiver: a DropListMorph(346750464)
	Arguments and temporary variables: 
		anInteger: 	1
		m: 	a NautilusUI
		s: 	#setHistory:
	Receiver's instance variables: 
		bounds: 	(721.0@59.0) corner: (1100.0@86.0)
		owner: 	a PanelMorph(167914496)
		submorphs: 	an Array(a TextMorphForFieldView(312204800) a ControlButtonMorph(925...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.13 g: 0.13 b: 0.13 alpha: 1.0)
		extension: 	a MorphExtension (962467840) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.37 g: 0.369 b: 0.369 alpha: 1.0)
		model: 	a NautilusUI
		contentMorph: 	a TextMorphForFieldView(312204800)
		listMorph: 	a PluggableListMorph(585809920)
		buttonMorph: 	a ControlButtonMorph(925134848)
		list: 	an OrderedCollection(a NautilusHistoryEntry->2017-06-15T15:03:38.582971+0...etc...
		listSelectionIndex: 	1
		getListSelector: 	#getHistoryList
		getIndexSelector: 	#currentHistoryIndex
		setIndexSelector: 	#setHistory:
		getEnabledSelector: 	nil
		enabled: 	true
		useSelectionIndex: 	true
		wrapSelector: 	#wrapHistory:
		defaultContents: 	a TextMorph(167903232)


PluggableListMorph>>changeModelSelection:
	Receiver: a PluggableListMorph(585809920)
	Arguments and temporary variables: 
		anInteger: 	1
	Receiver's instance variables: 
		bounds: 	(721.0@86.0) corner: (1100.0@124.0)
		owner: 	nil
		submorphs: 	an Array(a TransformMorph(541920768))
		fullBounds: 	(721@86) corner: (1100@124)
		color: 	(Color r: 0.13 g: 0.13 b: 0.13 alpha: 1.0)
		extension: 	a MorphExtension (747603968) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#inset
		model: 	a DropListMorph(346750464)
		scrollBar: 	a ScrollBar(55754752)
		scroller: 	a TransformMorph(541920768)
		getMenuSelector: 	nil
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(768859648)
		list: 	an OrderedCollection(a StringMorph(817682944)'')
		getListSelector: 	#list
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#listSelectionIndex
		setIndexSelector: 	#listSelectionIndex:
		keystrokeActionSelector: 	nil
		autoDeselect: 	false
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(893422080)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	#wrapItem:index:
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.027 g: 0.388 b: 0.678 alpha: 1.0)
		selectionColorToUse: 	(Color r: 0.027 g: 0.388 b: 0.678 alpha: 1.0)
		enabled: 	nil
		getEnabledSelector: 	nil


DropListMorph>>listMouseDown:
	Receiver: a DropListMorph(346750464)
	Arguments and temporary variables: 
		evt: 	[(856@103) mouseDown red 400126 nil]
	Receiver's instance variables: 
		bounds: 	(721.0@59.0) corner: (1100.0@86.0)
		owner: 	a PanelMorph(167914496)
		submorphs: 	an Array(a TextMorphForFieldView(312204800) a ControlButtonMorph(925...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.13 g: 0.13 b: 0.13 alpha: 1.0)
		extension: 	a MorphExtension (962467840) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	(Color r: 0.37 g: 0.369 b: 0.369 alpha: 1.0)
		model: 	a NautilusUI
		contentMorph: 	a TextMorphForFieldView(312204800)
		listMorph: 	a PluggableListMorph(585809920)
		buttonMorph: 	a ControlButtonMorph(925134848)
		list: 	an OrderedCollection(a NautilusHistoryEntry->2017-06-15T15:03:38.582971+0...etc...
		listSelectionIndex: 	1
		getListSelector: 	#getHistoryList
		getIndexSelector: 	#currentHistoryIndex
		setIndexSelector: 	#setHistory:
		getEnabledSelector: 	nil
		enabled: 	true
		useSelectionIndex: 	true
		wrapSelector: 	#wrapHistory:
		defaultContents: 	a TextMorph(167903232)


MorphEventSubscription>>notify:from:
	Receiver: a MorphEventSubscription
	Arguments and temporary variables: 
		anEvent: 	[(856@103) mouseDown red 400126 nil]
		sourceMorph: 	a PluggableListMorph(585809920)
		arity: 	1
	Receiver's instance variables: 
		event: 	#mouseDown
		selector: 	#listMouseDown:
		recipient: 	a DropListMorph(346750464)
		valueParameter: 	nil


[ :s | result := result | ((s notify: anEvent from: sourceMorph) == true) ] in MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		anEvent: 	[(856@103) mouseDown red 400126 nil]
		eventType: 	#mouseDown
		sourceMorph: 	a PluggableListMorph(585809920)
		result: 	false
		s: 	a MorphEventSubscription
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#keyStroke->a Set(a MorphEventSubscription) #mouseD...etc...


Set>>do:
	Receiver: a Set(a MorphEventSubscription)
	Arguments and temporary variables: 
		aBlock: 	[ :s | result := result | ((s notify: anEvent from: sourceMorph) == tru...etc...
		index: 	4
		each: 	a MorphEventSubscription
	Receiver's instance variables: 
		tally: 	1
		array: 	an Array(nil nil nil a MorphEventSubscription nil)


MorphicEventHandler>>notifyMorphsOfEvent:ofType:from:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		result: 	false
		anEvent: 	[(856@103) mouseDown red 400126 nil]
		eventType: 	#mouseDown
		sourceMorph: 	a PluggableListMorph(585809920)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#keyStroke->a Set(a MorphEventSubscription) #mouseD...etc...


MorphicEventHandler>>mouseDown:fromMorph:
	Receiver: a MorphicEventHandler
	Arguments and temporary variables: 
		event: 	[(856@103) mouseDown red 400126 nil]
		sourceMorph: 	a PluggableListMorph(585809920)
	Receiver's instance variables: 
		subscriptions: 	a Dictionary(#keyStroke->a Set(a MorphEventSubscription) #mouseD...etc...


PluggableListMorph(ScrollPane)>>mouseDown:
	Receiver: a PluggableListMorph(585809920)
	Arguments and temporary variables: 
		evt: 	[(856@103) mouseDown red 400126 nil]
	Receiver's instance variables: 
		bounds: 	(721.0@86.0) corner: (1100.0@124.0)
		owner: 	nil
		submorphs: 	an Array(a TransformMorph(541920768))
		fullBounds: 	(721@86) corner: (1100@124)
		color: 	(Color r: 0.13 g: 0.13 b: 0.13 alpha: 1.0)
		extension: 	a MorphExtension (747603968) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#inset
		model: 	a DropListMorph(346750464)
		scrollBar: 	a ScrollBar(55754752)
		scroller: 	a TransformMorph(541920768)
		getMenuSelector: 	nil
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(768859648)
		list: 	an OrderedCollection(a StringMorph(817682944)'')
		getListSelector: 	#list
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#listSelectionIndex
		setIndexSelector: 	#listSelectionIndex:
		keystrokeActionSelector: 	nil
		autoDeselect: 	false
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(893422080)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	#wrapItem:index:
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.027 g: 0.388 b: 0.678 alpha: 1.0)
		selectionColorToUse: 	(Color r: 0.027 g: 0.388 b: 0.678 alpha: 1.0)
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph>>mouseDown:
	Receiver: a PluggableListMorph(585809920)
	Arguments and temporary variables: 
		evt: 	[(856@103) mouseDown red 400126 nil]
		selectors: 	#(#click: nil nil nil)
		row: 	1
	Receiver's instance variables: 
		bounds: 	(721.0@86.0) corner: (1100.0@124.0)
		owner: 	nil
		submorphs: 	an Array(a TransformMorph(541920768))
		fullBounds: 	(721@86) corner: (1100@124)
		color: 	(Color r: 0.13 g: 0.13 b: 0.13 alpha: 1.0)
		extension: 	a MorphExtension (747603968) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#inset
		model: 	a DropListMorph(346750464)
		scrollBar: 	a ScrollBar(55754752)
		scroller: 	a TransformMorph(541920768)
		getMenuSelector: 	nil
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(768859648)
		list: 	an OrderedCollection(a StringMorph(817682944)'')
		getListSelector: 	#list
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#listSelectionIndex
		setIndexSelector: 	#listSelectionIndex:
		keystrokeActionSelector: 	nil
		autoDeselect: 	false
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(893422080)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	#wrapItem:index:
		searchedElement: 	nil
		multipleSelection: 	false
		dragOnOrOff: 	nil
		setSelectionListSelector: 	nil
		getSelectionListSelector: 	nil
		resetListSelector: 	nil
		keystrokeSelector: 	nil
		backgroundColoringBlockOrSelector: 	nil
		separatorBlockOrSelector: 	nil
		separatorSize: 	nil
		separatorColor: 	nil
		lastNonZeroIndex: 	nil
		canMove: 	true
		selectionColor: 	(Color r: 0.027 g: 0.388 b: 0.678 alpha: 1.0)
		selectionColorToUse: 	(Color r: 0.027 g: 0.388 b: 0.678 alpha: 1.0)
		enabled: 	nil
		getEnabledSelector: 	nil


PluggableListMorph(Morph)>>handleMouseDown:
	Receiver: a PluggableListMorph(585809920)
	Arguments and temporary variables: 
		anEvent: 	[(856@103) mouseDown red 400126 nil]
	Receiver's instance variables: 
		bounds: 	(721.0@86.0) corner: (1100.0@124.0)
		owner: 	nil
		submorphs: 	an Array(a TransformMorph(541920768))
		fullBounds: 	(721@86) corner: (1100@124)
		color: 	(Color r: 0.13 g: 0.13 b: 0.13 alpha: 1.0)
		extension: 	a MorphExtension (747603968) [eventHandler = a MorphicEventHandler] ...etc...
		borderWidth: 	1
		borderColor: 	#inset
		model: 	a DropListMorph(346750464)
		scrollBar: 	a ScrollBar(55754752)
		scroller: 	a TransformMorph(541920768)
		getMenuSelector: 	nil
		getMenuTitleSelector: 	nil
		hasFocus: 	true
		hScrollBar: 	a ScrollBar(768859648)
		list: 	an OrderedCollection(a StringMorph(817682944)'')
		getListSelector: 	#list
		getListSizeSelector: 	nil
		getListElementSelector: 	nil
		getIndexSelector: 	#listSelectionIndex
		setIndexSelector: 	#listSelectionIndex:
		keystrokeActionSelector: 	nil
		autoDeselect: 	false
		lastKeystrokeTime: 	0
		lastKeystrokes: 	''
		doubleClickSelector: 	nil
		handlesBasicKeys: 	nil
		potentialDropRow: 	nil
		listMorph: 	a LazyListMorph(893422080)
		hScrollRangeCache: 	nil
		dragItemSelector: 	nil
		dropItemSelector: 	nil
		wantsDropSelector: 	nil
		wrapSelector: 	#wrapItem:index:
		searchedElement: 	nil
		multipleSelecTHERE_BE_DRAGONS_HERE
Warning
15 June 2017 3:04:12.968971 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

SlotClassBuilder>>validateClassName
	Receiver: a SlotClassBuilder
	Arguments and temporary variables: 

	Receiver's instance variables: 
		installer: 	a PharoClassInstaller
		oldClasses: 	an OrderedCollection()
		newClasses: 	an OrderedCollection()
		classSlots: 	#()
		category: 	nil
		superclass: 	Object
		name: 	#NameOfSubclass
		layoutClass: 	nil
		slots: 	#()
		traitComposition: 	{}
		classTraitComposition: 	{}
		result: 	nil
		sharedPoolsString: 	''
		sharedVariables: 	#()
		comment: 	nil
		commentStamp: 	nil


SlotClassBuilder>>name:
	Receiver: a SlotClassBuilder
	Arguments and temporary variables: 
		aName: 	#NameOfSubclass
	Receiver's instance variables: 
		installer: 	a PharoClassInstaller
		oldClasses: 	an OrderedCollection()
		newClasses: 	an OrderedCollection()
		classSlots: 	#()
		category: 	nil
		superclass: 	Object
		name: 	#NameOfSubclass
		layoutClass: 	nil
		slots: 	#()
		traitComposition: 	{}
		classTraitComposition: 	{}
		result: 	nil
		sharedPoolsString: 	''
		sharedVariables: 	#()
		comment: 	nil
		commentStamp: 	nil


[ :builder | 
builder
	superclass: self;
	name: t;
	layoutClass: self classLayout class;
	slots: f asSlotCollection;
	sharedVariablesFromString: d;
	sharedPools: s;
	category: cat;
	environment: self environment;
	copyClassSlotsFromExistingClass ] in Object class(Class)>>private_subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
	Receiver: Object
	Arguments and temporary variables: 
		t: 	#NameOfSubclass
		f: 	''
		d: 	''
		s: 	''
		cat: 	'Snake_Game'
		builder: 	a SlotClassBuilder
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 408)
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{BalloonState. UndefinedObject. Boolean. FillStyle. ConnectionQueue...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary(TextStyl...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'
		traitComposition: 	{}
		localSelectors: 	nil


PharoClassInstaller class(AbstractClassInstaller class)>>make:
	Receiver: PharoClassInstaller
	Arguments and temporary variables: 
		aBlock: 	[ :builder | 
builder
	superclass: self;
	name: t;
	layoutClass: self c...etc...
		builder: 	a SlotClassBuilder
	Receiver's instance variables: 
		superclass: 	AbstractClassInstaller
		methodDict: 	a MethodDictionary(#basicClassDefinitionChangedFrom:to:using:->Phar...etc...
		format: 	65540
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#PharoClassInstaller
		classPool: 	a Dictionary()
		sharedPools: 	nil
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Slot-ClassBuilder'
		traitComposition: 	{}
		localSelectors: 	nil


Object class(Class)>>private_subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:
	Receiver: Object
	Arguments and temporary variables: 
		t: 	#NameOfSubclass
		f: 	''
		d: 	''
		s: 	''
		cat: 	'Snake_Game'
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 408)
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{BalloonState. UndefinedObject. Boolean. FillStyle. ConnectionQueue...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary(TextStyl...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'
		traitComposition: 	{}
		localSelectors: 	nil


[ self
	private_subclass: aName
	instanceVariableNames: someInstanceVariableNames
	classVariableNames: someClassVariableNames
	poolDictionaries: someSharedPoolNames
	category: aCategory ] in Object class(Class)>>subclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:package:
	Receiver: Object
	Arguments and temporary variables: 
		aName: 	#NameOfSubclass
		aTraitCompositionOrArray: 	#()
		someInstanceVariableNames: 	''
		someClassVariableNames: 	''
		someSharedPoolNames: 	''
		aCategory: 	'Snake_Game'
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 408)
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{BalloonState. UndefinedObject. Boolean. FillStyle. ConnectionQueue...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary(TextStyl...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'
		traitComposition: 	{}
		localSelectors: 	nil


[ | newClass |
"Create the class and set the trait composition"
newClass := aBlock value.
newClass setTraitComposition: aTraitComposition asTraitComposition.
SystemAnnouncer uniqueInstance classModificationAppliedTo: newClass.
newClass ] in Object class(Class)>>subclass:uses:with:
	Receiver: Object
	Arguments and temporary variables: 
		aName: 	#NameOfSubclass
		aTraitComposition: 	#()
		aBlock: 	[ self
	private_subclass: aName
	instanceVariableNames: someInstanceVar...etc...
		newClass: 	nil
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 408)
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{BalloonState. UndefinedObject. Boolean. FillStyle. ConnectionQueue...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary(TextStyl...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'
		traitComposition: 	{}
		localSelectors: 	nil


SystemDictionary(Dictionary)>>at:ifPresent:ifAbsent:
	Receiver: a SystemDictionary(lots of globals)
	Arguments and temporary variables: 
		key: 	#NameOfSubclass
		aPresentBlock: 	[ :old | 
| copyOfOld newClass |
copyOfOld := old copy.

"Modify...etc...
		anAbsentBlock: 	[ | newClass |
"Create the class and set the trait composition"
...etc...
	Receiver's instance variables: 
		tally: 	6520
		array: 	an Array(#SmallDictionary->SmallDictionary #MetacelloExampleProjectConfi...etc...
		cachedClassNames: 	an OrderedCollection(#AColorSelectorMorph #AGroupContentHasBe...etc...
		cachedNonClassNames: 	an OrderedCollection(#ActiveEvent #ActiveHand #ActiveWorld...etc...


Object class(Class)>>subclass:uses:with:
	Receiver: Object
	Arguments and temporary variables: 
		aName: 	#NameOfSubclass
		aTraitComposition: 	#()
		aBlock: 	[ self
	private_subclass: aName
	instanceVariableNames: someInstanceVar...etc...
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 408)
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{BalloonState. UndefinedObject. Boolean. FillStyle. ConnectionQueue...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary(TextStyl...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'
		traitComposition: 	{}
		localSelectors: 	nil


Object class(Class)>>subclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:package:
	Receiver: Object
	Arguments and temporary variables: 
		aName: 	#NameOfSubclass
		aTraitCompositionOrArray: 	#()
		someInstanceVariableNames: 	''
		someClassVariableNames: 	''
		someSharedPoolNames: 	''
		aCategory: 	'Snake_Game'
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 408)
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{BalloonState. UndefinedObject. Boolean. FillStyle. ConnectionQueue...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary(TextStyl...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'
		traitComposition: 	{}
		localSelectors: 	nil


Object class(Class)>>subclass:instanceVariableNames:classVariableNames:poolDictionaries:package:
	Receiver: Object
	Arguments and temporary variables: 
		t: 	#NameOfSubclass
		f: 	''
		d: 	''
		s: 	''
		cat: 	'Snake_Game'
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 408)
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{BalloonState. UndefinedObject. Boolean. FillStyle. ConnectionQueue...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary(TextStyl...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'
		traitComposition: 	{}
		localSelectors: 	nil


Object class(Class)>>subclass:instanceVariableNames:classVariableNames:package:
	Receiver: Object
	Arguments and temporary variables: 
		aSubclassSymbol: 	#NameOfSubclass
		instVarNames: 	''
		classVarNames: 	''
		aPackageSymbol: 	'Snake_Game'
	Receiver's instance variables: 
		superclass: 	ProtoObject
		methodDict: 	a MethodDictionary(size 408)
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{BalloonState. UndefinedObject. Boolean. FillStyle. ConnectionQueue...etc...
		name: 	#Object
		classPool: 	a Dictionary(#DependentsFields->a WeakIdentityKeyDictionary(TextStyl...etc...
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Objects'
		traitComposition: 	{}
		localSelectors: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	a ReadStream
		itsSelection: 	nil
		itsSelectionString: 	nil
	Receiver's instance variables: 
		ast: 	DoIt
	^ Object
		subclass: #NameOfSubclass
		instanceVariableNames: ''
		c...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


NautilusUI(AbstractTool)>>compileANewClassFrom:notifying:startingFrom:
	Receiver: a NautilusUI
	Arguments and temporary variables: 
		aString: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''''
	classV...etc...
		aController: 	a RubScrolledTextMorph(578405888)
		aClass: 	nil
		oldClass: 	nil
		class: 	nil
		newClassName: 	'NameOfSubclass'
		defTokens: 	an OrderedCollection('Object' 'subclass:' '#NameOfSubclass' 'instanc...etc...
		keywdIx: 	2
		envt: 	a SystemDictionary(lots of globals)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		announceur: 	nil
		model: 	a Nautilus
		window: 	a NautilusWindow(199408128)
		sourceCodePanel: 	a PanelMorph(161901568)
		fullDisplayedComment: 	false
		sourceCodeContainer: 	a PanelMorph(219484672)
		shouldUpdateTitle: 	true
		contentSelection: 	a Text for ''
		acceptor: 	a ClassDefinitionAcceptor
		commentWidget: 	nil
		sourceTextWidget: 	a RubScrolledTextMorph(578405888)
		sourceCodeSelectionInterval: 	(106 to: 105)
		sourceTextModel: 	a RubScrolledTextModel
		methodClassifier: 	nil
		commentTextModel: 	a RubScrolledTextModel
		instanceButtonWidget: 	a PluggableToggleButtonMorph(684640256)
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageWidget
		packagePatternString: 	''
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(3174400)


NautilusUI(AbstractNautilusUI)>>compileAClassFrom:notifying:
	Receiver: a NautilusUI
	Arguments and temporary variables: 
		aString: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''''
	classV...etc...
		aController: 	a RubScrolledTextMorph(578405888)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		announceur: 	nil
		model: 	a Nautilus
		window: 	a NautilusWindow(199408128)
		sourceCodePanel: 	a PanelMorph(161901568)
		fullDisplayedComment: 	false
		sourceCodeContainer: 	a PanelMorph(219484672)
		shouldUpdateTitle: 	true
		contentSelection: 	a Text for ''
		acceptor: 	a ClassDefinitionAcceptor
		commentWidget: 	nil
		sourceTextWidget: 	a RubScrolledTextMorph(578405888)
		sourceCodeSelectionInterval: 	(106 to: 105)
		sourceTextModel: 	a RubScrolledTextModel
		methodClassifier: 	nil
		commentTextModel: 	a RubScrolledTextModel
		instanceButtonWidget: 	a PluggableToggleButtonMorph(684640256)
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageWidget
		packagePatternString: 	''
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(3174400)


ClassDefinitionAcceptor>>accept:notifying:
	Receiver: a ClassDefinitionAcceptor
	Arguments and temporary variables: 
		aText: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''''
	classVar...etc...
		aController: 	a RubScrolledTextMorph(578405888)
	Receiver's instance variables: 
		model: 	a NautilusUI


NautilusUI>>compileSource:notifying:
	Receiver: a NautilusUI
	Arguments and temporary variables: 
		aText: 	'Object subclass: #NameOfSubclass
	instanceVariableNames: ''''
	classVar...etc...
		aController: 	a RubScrolledTextMorph(578405888)
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		announceur: 	nil
		model: 	a Nautilus
		window: 	a NautilusWindow(199408128)
		sourceCodePanel: 	a PanelMorph(161901568)
		fullDisplayedComment: 	false
		sourceCodeContainer: 	a PanelMorph(219484672)
		shouldUpdateTitle: 	true
		contentSelection: 	a Text for ''
		acceptor: 	a ClassDefinitionAcceptor
		commentWidget: 	nil
		sourceTextWidget: 	a RubScrolledTextMorph(578405888)
		sourceCodeSelectionInterval: 	(106 to: 105)
		sourceTextModel: 	a RubScrolledTextModel
		methodClassifier: 	nil
		commentTextModel: 	a RubScrolledTextModel
		instanceButtonWidget: 	a PluggableToggleButtonMorph(684640256)
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageWidget
		packagePatternString: 	''
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(3174400)


NautilusUI(AbstractNautilusUI)>>whenTextAcceptedInView:
	Receiver: a NautilusUI
	Arguments and temporary variables: 
		anAnnouncement: 	a RubTextAccepted
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a CategoryWidget a MethodWidget a ClassWidget a P...etc...
		announceur: 	nil
		model: 	a Nautilus
		window: 	a NautilusWindow(199408128)
		sourceCodePanel: 	a PanelMorph(161901568)
		fullDisplayedComment: 	false
		sourceCodeContainer: 	a PanelMorph(219484672)
		shouldUpdateTitle: 	true
		contentSelection: 	a Text for ''
		acceptor: 	a ClassDefinitionAcceptor
		commentWidget: 	nil
		sourceTextWidget: 	a RubScrolledTextMorph(578405888)
		sourceCodeSelectionInterval: 	(106 to: 105)
		sourceTextModel: 	a RubScrolledTextModel
		methodClassifier: 	nil
		commentTextModel: 	a RubScrolledTextModel
		instanceButtonWidget: 	a PluggableToggleButtonMorph(684640256)
		categoryWidget: 	a CategoryWidget
		methodWidget: 	a MethodWidget
		classWidget: 	a ClassWidget
		packageWidget: 	a PackageWidget
		packagePatternString: 	''
		packagePattern: 	nil
		searchWidget: 	a SearchMorph(3174400)


MessageSend>>value:
	Receiver: MessageSend(#whenTextAcceptedInView: -> a NautilusUI)
	Arguments and temporary variables: 
		anObject: 	a RubTextAccepted
	Receiver's instance variables: 
		receiver: 	a NautilusUI
		selector: 	#whenTextAcceptedInView:
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#whenTextAcceptedInView: -> a NautilusUI)
	Arguments and temporary variables: 
THERE_BE_DRAGONS_HERE

15 June 2017 3:20:32.370734 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	nil
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	4
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	4
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(536791552) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(536791552) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(536791552) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(536791552) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(637@385) corner: (653@401)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(637@385) mouseOver 1408767 nil]
		targetOffset: 	(327.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1408767 637 385 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(637@385) corner: (653@401)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(637@385) mouseOver 1408767 nil]
		targetOffset: 	(327.0@26.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1408767 637 385 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	932747
		lastStepMessage: 	nil
		lastCycleTime: 	932767
		alarms: 	a Heap()
		lastAlarmTime: 	932747
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

15 June 2017 3:23:16.655734 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	nil
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	5
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	5
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(134573568) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(134573568) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(134573568) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(134573568) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(447@498) corner: (463@514)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(447@498) mouseOver 1574065 nil]
		targetOffset: 	(126.0@64.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1574065 447 498 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(447@498) corner: (463@514)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(447@498) mouseOver 1574065 nil]
		targetOffset: 	(126.0@64.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1574065 447 498 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	1097019
		lastStepMessage: 	nil
		lastCycleTime: 	1097039
		alarms: 	a Heap()
		lastAlarmTime: 	1097019
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

15 June 2017 3:24:49.094734 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	nil
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	5
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	5
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@50)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(198748928) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@50)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@50)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(198748928) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@50)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@50)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(198748928) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@50)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@50)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(198748928) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@50)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(935@237) corner: (951@253)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(935@237) mouseOver 1666574 nil]
		targetOffset: 	(145.0@98.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1666574 935 237 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(935@237) corner: (951@253)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(935@237) mouseOver 1666574 nil]
		targetOffset: 	(145.0@98.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1666574 935 237 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	1189471
		lastStepMessage: 	nil
		lastCycleTime: 	1189492
		alarms: 	a Heap()
		lastAlarmTime: 	1189471
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

15 June 2017 3:28:43.575734 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	nil
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	5
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	5
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(22527744) a RubCursor(474527232)...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(22527744) a RubCursor(474527232)...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(22527744) a RubCursor(474527232)...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(22527744) a RubCursor(474527232)...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(610@422) corner: (626@438)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(610@422) mouseOver 1900060 nil]
		targetOffset: 	(299.0@62.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1900060 610 422 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(610@422) corner: (626@438)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(610@422) mouseOver 1900060 nil]
		targetOffset: 	(299.0@62.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1900060 610 422 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	1423993
		lastStepMessage: 	nil
		lastCycleTime: 	1424013
		alarms: 	a Heap()
		lastAlarmTime: 	1423993
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of BlankCellTest did not understand #shoud:
15 June 2017 3:29:15.894734 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

BlankCellTest(Object)>>doesNotUnderstand: #shoud:
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 
		aMessage: 	shoud: [ cell isOff ]
		exception: 	MessageNotUnderstood: BlankCellTest>>shoud:
		resumeValue: 	nil
	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


BlankCellTest>>testCellOnState
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


BlankCellTest(TestCase)>>performTest
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	nil
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlankCellTest(TestCase)>>runCaseManaged
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		timeStamp: 	2017-06-15T15:29:15.859734+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellOnState)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		timeStamp: 	2017-06-15T15:29:15.859734+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellOnState)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellOnState)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(BlankCellTest>>#testCellOnState)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(BlankCellTest>>#testCellOnState nil nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellOnState)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellOnState)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(6996480) a SearchMorph(87089920) a...etc...
		announceur: 	nil
		classes: 	{BlankCellTest}
		classIndex: 	1
		classesSelected: 	a Set(BlankCellTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(BlankCellTest>>#testCellOnState)
		errorSelected: 	BlankCellTest>>#testCellOnState
		lastUpdate: 	3674986134
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		classPattern: 	a RxMatcher
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#'AST-Tests-Core' #'Alien-CoreTest' #'Announcements-Tests-Core-Test...etc...
		packagesSelected: 	a Set()
		packagePattern: 	nil
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(6996480) a SearchMorph(87089920) a...etc...
		announceur: 	nil
		classes: 	{BlankCellTest}
		classIndex: 	1
		classesSelected: 	a Set(BlankCellTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(BlankCellTest>>#testCellOnState)
		errorSelected: 	BlankCellTest>>#testCellOnState
		lastUpdate: 	3674986134
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		classPattern: 	a RxMatcher
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#'AST-Tests-Core' #'Alien-CoreTest' #'Announcements-Tests-Core-Test...etc...
		packagesSelected: 	a Set()
		packagePattern: 	nil
		packageIndex: 	0



--- The full stack ---
BlankCellTest(Object)>>doesNotUnderstand: #shoud:
BlankCellTest>>testCellOnState
BlankCellTest(TestCase)>>performTest
[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
BlockClosure>>ensure:
BlankCellTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
BlankCellTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
BlockClosure>>ensure:
BlankCellTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

15 June 2017 3:30:59.026734 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	5
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	5
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@107)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(231887360) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@107)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@107)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(231887360) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@107)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@107)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(231887360) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@107)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@107)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(231887360) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@107)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(676@397) corner: (692@413)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(676@397) mouseOver 2035532 nil]
		targetOffset: 	(365.0@36.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2035532 676 397 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(676@397) corner: (692@413)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(676@397) mouseOver 2035532 nil]
		targetOffset: 	(365.0@36.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2035532 676 397 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(871380736))(a SearchMorp...etc...
		lastStepTime: 	1559414
		lastStepMessage: 	nil
		lastCycleTime: 	1559435
		alarms: 	a Heap()
		lastAlarmTime: 	1559414
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of BlankCell did not understand #activeSnake
15 June 2017 3:34:26.242734 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

BlankCell(Object)>>doesNotUnderstand: #activeSnake
	Receiver: a BlankCell
	Arguments and temporary variables: 
		aMessage: 	activeSnake
		exception: 	MessageNotUnderstood: BlankCell>>activeSnake
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )


BlankCell>>isOn
	Receiver: a BlankCell
	Arguments and temporary variables: 

	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )


BlankCell>>isOff
	Receiver: a BlankCell
	Arguments and temporary variables: 

	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )


[ cell isOff ] in BlankCellTest>>testCellOnState
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


BlankCellTest(TestAsserter)>>should:
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 
		aBlock: 	[ cell isOff ]
	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


BlankCellTest>>testCellOnState
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


BlankCellTest(TestCase)>>performTest
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlankCellTest(TestCase)>>runCaseManaged
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		timeStamp: 	2017-06-15T15:34:26.212734+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellOnState)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		timeStamp: 	2017-06-15T15:34:26.212734+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellOnState)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellOnState)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(BlankCellTest>>#testCellOnState)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(BlankCellTest>>#testCellOnState nil nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellOnState)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellOnState)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer



--- The full stack ---
BlankCell(Object)>>doesNotUnderstand: #activeSnake
BlankCell>>isOn
BlankCell>>isOff
[ cell isOff ] in BlankCellTest>>testCellOnState
BlankCellTest(TestAsserter)>>should:
BlankCellTest>>testCellOnState
BlankCellTest(TestCase)>>performTest
[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
BlockClosure>>ensure:
BlankCellTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
BlankCellTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
BlockClosure>>ensure:
BlankCellTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

15 June 2017 3:40:15.993734 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	2
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	2
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@50)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(416673536) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@50)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	(252.0@19.0)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@50)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(416673536) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@50)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	(252.0@19.0)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@50)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(416673536) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@50)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	(252.0@19.0)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@50)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(416673536) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@50)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	(252.0@19.0)
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(756@328) corner: (772@344)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(756@328) mouseOver SHIFT CTRL 2593625 nil]
		targetOffset: 	(252.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2593625 756 328 0 3 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(756@328) corner: (772@344)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(756@328) mouseOver SHIFT CTRL 2593625 nil]
		targetOffset: 	(252.0@19.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2593625 756 328 0 3 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	2116347
		lastStepMessage: 	nil
		lastCycleTime: 	2116368
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(474527232)))
		lastAlarmTime: 	2116347
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-15T15:04:59.233734+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of BlankCell did not understand #playerHead:
16 June 2017 2:37:44.485311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

BlankCell(Object)>>doesNotUnderstand: #playerHead:
	Receiver: a BlankCell
	Arguments and temporary variables: 
		aMessage: 	playerHead: a Dictionary()
		exception: 	MessageNotUnderstood: BlankCell>>playerHead:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	nil


BlankCell>>initializeSnakeHead
	Receiver: a BlankCell
	Arguments and temporary variables: 

	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	nil


BlankCell>>initialize
	Receiver: a BlankCell
	Arguments and temporary variables: 

	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	nil


BlankCell class(Behavior)>>new
	Receiver: BlankCell
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#initialize->BlankCell>>#initialize #initializeS...etc...
		format: 	65538
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#BlankCell
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Snake_Game_Model
		traitComposition: 	{}
		localSelectors: 	nil


BlankCellTest>>testCellOnState
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 
		cell: 	nil
	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


BlankCellTest(TestCase)>>performTest
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellOnState
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlankCellTest(TestCase)>>runCaseManaged
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T14:37:44.447311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellOnState)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T14:37:44.447311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellOnState)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellOnState
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellOnState
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	BlankCellTest>>#testCellOnState
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellOnState)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(BlankCellTest>>#testCellOnState)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(BlankCellTest>>#testCellOnState nil nil nil nil nil nil nil nil...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellOnState)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellOnState)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(543560192) a SearchMorph(384583424...etc...
		announceur: 	nil
		classes: 	{BlankCellTest}
		classIndex: 	1
		classesSelected: 	a Set(BlankCellTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(BlankCellTest>>#testCellOnState BlankCellTest>>#testCellSna...etc...
		errorSelected: 	BlankCellTest>>#testCellOnState
		lastUpdate: 	3675069460
		result: 	3 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 3 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	1



--- The full stack ---
BlankCell(Object)>>doesNotUnderstand: #playerHead:
BlankCell>>initializeSnakeHead
BlankCell>>initialize
BlankCell class(Behavior)>>new
BlankCellTest>>testCellOnState
BlankCellTest(TestCase)>>performTest
[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
BlockClosure>>ensure:
BlankCellTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
BlankCellTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
BlockClosure>>ensure:
BlankCellTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
THERE_BE_DRAGONS_HERE

16 June 2017 2:44:04.549311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	3
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	3
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@183)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(995515136) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@183)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@183)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(995515136) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@183)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@183)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(995515136) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@183)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@183)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(995515136) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@183)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(721@492) corner: (737@508)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(721@492) mouseOver 1262984 nil]
		targetOffset: 	(403.0@165.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1262984 721 492 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(721@492) corner: (737@508)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(721@492) mouseOver 1262984 nil]
		targetOffset: 	(403.0@165.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 1262984 721 492 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(87089920))(a SearchMorph...etc...
		lastStepTime: 	1044110
		lastStepMessage: 	nil
		lastCycleTime: 	1044131
		alarms: 	a Heap()
		lastAlarmTime: 	1044110
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

16 June 2017 3:00:52.049311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@69)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(677219328) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@69)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@69)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(677219328) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@69)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@69)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(677219328) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@69)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@69)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(677219328) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@69)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(719@388) corner: (735@404)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(719@388) mouseOver 2270438 nil]
		targetOffset: 	(428@48)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2270438 719 388 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(719@388) corner: (735@404)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(719@388) mouseOver 2270438 nil]
		targetOffset: 	(428@48)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2270438 719 388 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	2051586
		lastStepMessage: 	nil
		lastCycleTime: 	2051607
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(474527232)))
		lastAlarmTime: 	2051586
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of False did not understand #put:
16 June 2017 3:02:20.339311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

False(Object)>>doesNotUnderstand: #put:
	Receiver: false
	Arguments and temporary variables: 
		aMessage: 	put: true
		exception: 	MessageNotUnderstood: False>>put:
		resumeValue: 	nil
	Receiver's instance variables: 
false

BlankCell>>enteredFrom:
	Receiver: a BlankCell
	Arguments and temporary variables: 
		from: 	#north
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#blue->false #red->false )
		previousSegment: 	nil


BlankCellTest>>testCellSnakeEnteredFrom
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


BlankCellTest(TestCase)>>performTest
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlankCellTest(TestCase)>>runCaseManaged
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:02:20.307311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:02:20.307311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(BlankCellTest>>#testCellSnakeEnteredFrom nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(958906624) a SearchMorph(754221824...etc...
		announceur: 	nil
		classes: 	{BlankCellTest}
		classIndex: 	0
		classesSelected: 	a Set(BlankCellTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(BlankCellTest>>#testCellSnakeEnteredFrom)
		errorSelected: 	BlankCellTest>>#testCellSnakeEnteredFrom
		lastUpdate: 	3675070938
		result: 	4 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	1


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	4 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
False(Object)>>doesNotUnderstand: #put:
BlankCell>>enteredFrom:
BlankCellTest>>testCellSnakeEnteredFrom
BlankCellTest(TestCase)>>performTest
[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
BlockClosure>>ensure:
BlankCellTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
BlankCellTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
BlockClosure>>ensure:
BlankCellTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of False did not understand #put:
16 June 2017 3:03:40.587311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

False(Object)>>doesNotUnderstand: #put:
	Receiver: false
	Arguments and temporary variables: 
		aMessage: 	put: true
		exception: 	MessageNotUnderstood: False>>put:
		resumeValue: 	nil
	Receiver's instance variables: 
false

BlankCell>>enteredFrom:
	Receiver: a BlankCell
	Arguments and temporary variables: 
		from: 	#north
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#blue->false #red->false )
		previousSegment: 	nil


BlankCellTest>>testCellSnakeEnteredFrom
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


BlankCellTest(TestCase)>>performTest
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlankCellTest(TestCase)>>runCaseManaged
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:03:40.574311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:03:40.574311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(BlankCellTest>>#testCellSnakeEnteredFrom nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(308071424) a SearchMorph(185195264...etc...
		announceur: 	nil
		classes: 	{BlankCellTest}
		classIndex: 	0
		classesSelected: 	a Set(BlankCellTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(BlankCellTest>>#testCellSnakeEnteredFrom)
		errorSelected: 	BlankCellTest>>#testCellSnakeEnteredFrom
		lastUpdate: 	3675071018
		result: 	4 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	1


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	4 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
False(Object)>>doesNotUnderstand: #put:
BlankCell>>enteredFrom:
BlankCellTest>>testCellSnakeEnteredFrom
BlankCellTest(TestCase)>>performTest
[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
BlockClosure>>ensure:
BlankCellTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
BlankCellTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
BlockClosure>>ensure:
BlankCellTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#put: was sent to nil
16 June 2017 3:04:27.526311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

UndefinedObject(Object)>>doesNotUnderstand: #put:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	put: #north
		exception: 	MessageNotUnderstood: receiver of "put:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

BlankCell>>enteredFrom:
	Receiver: a BlankCell
	Arguments and temporary variables: 
		from: 	#north
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#blue->false #red->false )
		previousSegment: 	nil


BlankCellTest>>testCellSnakeEnteredFrom
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


BlankCellTest(TestCase)>>performTest
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlankCellTest(TestCase)>>runCaseManaged
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:04:27.511311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:04:27.511311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(BlankCellTest>>#testCellSnakeEnteredFrom nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(367699200) a SearchMorph(818221824...etc...
		announceur: 	nil
		classes: 	{BlankCellTest}
		classIndex: 	0
		classesSelected: 	a Set(BlankCellTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(BlankCellTest>>#testCellSnakeEnteredFrom)
		errorSelected: 	BlankCellTest>>#testCellSnakeEnteredFrom
		lastUpdate: 	3675071066
		result: 	4 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	1


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	4 run, 3 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #put:
BlankCell>>enteredFrom:
BlankCellTest>>testCellSnakeEnteredFrom
BlankCellTest(TestCase)>>performTest
[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
BlockClosure>>ensure:
BlankCellTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
BlankCellTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
BlockClosure>>ensure:
BlankCellTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of BlankCell did not understand #ifFalse:
16 June 2017 3:05:40.380311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

BlankCell(Object)>>doesNotUnderstand: #ifFalse:
	Receiver: a BlankCell
	Arguments and temporary variables: 
		aMessage: 	ifFalse: self
		exception: 	MessageNotUnderstood: BlankCell>>ifFalse:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#blue->false #red->false )
		previousSegment: 	#north


BlankCellTest(TestAsserter)>>ExecuteUnOptimizedIn:
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 
		arg1: 	BlankCellTest(TestAsserter)>>assert:
	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


BlankCell(Object)>>mustBeBooleanInMagic:
	Receiver: a BlankCell
	Arguments and temporary variables: 
		context: 	BlankCellTest(TestAsserter)>>assert:
		sendNode: 	RBMessageNode(aBoolean
	ifFalse: [ self logFailure: 'Assertion failed...etc...
		methodNode: 	ExecuteUnOptimizedIn: ThisContext
	^ (ThisContext namedTempAt: 1)
	...etc...
		method: 	TestAsserter>>#ExecuteUnOptimizedIn:
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#blue->false #red->false )
		previousSegment: 	#north


BlankCell(Object)>>mustBeBoolean
	Receiver: a BlankCell
	Arguments and temporary variables: 

	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#blue->false #red->false )
		previousSegment: 	#north


BlankCellTest(TestAsserter)>>assert:
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 
		aBoolean: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


BlankCellTest(TestAsserter)>>should:
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 
		aBlock: 	[ cell previousSegment: #north ]
	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


BlankCellTest>>testCellSnakeEnteredFrom
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


BlankCellTest(TestCase)>>performTest
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlankCellTest(TestCase)>>runCaseManaged
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:05:40.362311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:05:40.362311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSnakeEnteredFrom
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSnakeEnteredFrom
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	BlankCellTest>>#testCellSnakeEnteredFrom
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(BlankCellTest>>#testCellSnakeEnteredFrom nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSnakeEnteredFrom)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0



--- The full stack ---
BlankCell(Object)>>doesNotUnderstand: #ifFalse:
BlankCellTest(TestAsserter)>>ExecuteUnOptimizedIn:
BlankCell(Object)>>mustBeBooleanInMagic:
BlankCell(Object)>>mustBeBoolean
BlankCellTest(TestAsserter)>>assert:
BlankCellTest(TestAsserter)>>should:
BlankCellTest>>testCellSnakeEnteredFrom
BlankCellTest(TestCase)>>performTest
[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
BlockClosure>>ensure:
BlankCellTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
BlankCellTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
BlockClosure>>ensure:
BlankCellTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

16 June 2017 3:10:28.780311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	2
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	2
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@69)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(866920192) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@69)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@69)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(866920192) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@69)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@69)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(866920192) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@69)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@69)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(866920192) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@69)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(669@419) corner: (685@435)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(669@419) mouseOver CTRL 2847158 nil]
		targetOffset: 	(364@54)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2847158 669 421 0 2 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(669@419) corner: (685@435)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(669@419) mouseOver CTRL 2847158 nil]
		targetOffset: 	(364@54)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2847158 669 421 0 2 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(871380736))(a SearchMorp...etc...
		lastStepTime: 	2628361
		lastStepMessage: 	nil
		lastCycleTime: 	2628381
		alarms: 	a Heap()
		lastAlarmTime: 	2628361
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of BlankCell did not understand #isPlayerActive
16 June 2017 3:12:44.991311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

BlankCell(Object)>>doesNotUnderstand: #isPlayerActive
	Receiver: a BlankCell
	Arguments and temporary variables: 
		aMessage: 	isPlayerActive
		exception: 	MessageNotUnderstood: BlankCell>>isPlayerActive
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#blue->false #red->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )


[ cell isPlayerActive = #speedUp ] in BlankCellTest>>testCellArtifact
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


BlankCellTest(TestAsserter)>>shouldnt:
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 
		aBlock: 	[ cell isPlayerActive = #speedUp ]
	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


BlankCellTest>>testCellArtifact
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


BlankCellTest(TestCase)>>performTest
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellArtifact
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellArtifact
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellArtifact
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellArtifact
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellArtifact
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellArtifact
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellArtifact
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlankCellTest(TestCase)>>runCaseManaged
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:12:44.957311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellArtifact)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:12:44.957311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellArtifact)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellArtifact)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(BlankCellTest>>#testCellArtifact)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(BlankCellTest>>#testCellArtifact nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellArtifact)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellArtifact)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest}
		classIndex: 	0
		classesSelected: 	a Set(BlankCellTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(BlankCellTest>>#testCellArtifact)
		errorSelected: 	BlankCellTest>>#testCellArtifact
		lastUpdate: 	3675071562
		result: 	5 run, 4 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	1


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
BlankCell(Object)>>doesNotUnderstand: #isPlayerActive
[ cell isPlayerActive = #speedUp ] in BlankCellTest>>testCellArtifact
BlankCellTest(TestAsserter)>>shouldnt:
BlankCellTest>>testCellArtifact
BlankCellTest(TestCase)>>performTest
[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
BlockClosure>>ensure:
BlankCellTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
BlankCellTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
BlockClosure>>ensure:
BlankCellTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
16 June 2017 3:13:28.979311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

BlankCellTest(TestAsserter)>>assert:
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


BlankCellTest(TestAsserter)>>should:
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 
		aBlock: 	[ cell artifact = #none ]
	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


BlankCellTest>>testCellArtifact
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


BlankCellTest(TestCase)>>performTest
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellArtifact
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellArtifact
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellArtifact
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellArtifact
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellArtifact
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellArtifact
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellArtifact
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlankCellTest(TestCase)>>runCaseManaged
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:13:28.967311+02:00
		failures: 	a Set(BlankCellTest>>#testCellArtifact)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:13:28.967311+02:00
		failures: 	a Set(BlankCellTest>>#testCellArtifact)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellArtifact
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellArtifact
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	BlankCellTest>>#testCellArtifact
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellArtifact)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(BlankCellTest>>#testCellArtifact)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(BlankCellTest>>#testCellArtifact nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellArtifact)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellArtifact)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest}
		classIndex: 	0
		classesSelected: 	a Set(BlankCellTest)
		failedList: 	an Array(BlankCellTest>>#testCellArtifact)
		failedSelected: 	BlankCellTest>>#testCellArtifact
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3675071605
		result: 	5 run, 4 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	1


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	5 run, 4 passes, 0 skipped, 0 expected failures, 1 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
BlankCellTest(TestAsserter)>>assert:
BlankCellTest(TestAsserter)>>should:
BlankCellTest>>testCellArtifact
BlankCellTest(TestCase)>>performTest
[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
BlockClosure>>ensure:
BlankCellTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
BlankCellTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
BlockClosure>>ensure:
BlankCellTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
16 June 2017 3:30:31.905311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

BlankCellTest(TestAsserter)>>assert:
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlankCellTest(TestAsserter)>>should:
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		aBlock: 	[ cell somePlayerActive ]
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlankCellTest>>testCellSomePlayerActive
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlankCellTest(TestCase)>>performTest
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlankCellTest(TestCase)>>runCaseManaged
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:30:31.893311+02:00
		failures: 	a Set(BlankCellTest>>#testCellSomePlayerActive)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:30:31.893311+02:00
		failures: 	a Set(BlankCellTest>>#testCellSomePlayerActive)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(BlankCellTest>>#testCellSomePlayerActive nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest}
		classIndex: 	0
		classesSelected: 	a Set(BlankCellTest)
		failedList: 	an Array(BlankCellTest>>#testCellSomePlayerActive)
		failedSelected: 	BlankCellTest>>#testCellSomePlayerActive
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3675072629
		result: 	6 run, 5 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	1


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	6 run, 5 passes, 0 skipped, 0 expected failures, 1 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
BlankCellTest(TestAsserter)>>assert:
BlankCellTest(TestAsserter)>>should:
BlankCellTest>>testCellSomePlayerActive
BlankCellTest(TestCase)>>performTest
[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
BlockClosure>>ensure:
BlankCellTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
BlankCellTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
BlockClosure>>ensure:
BlankCellTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: only integers should be used as indices
16 June 2017 3:31:41.396311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

ByteSymbol(Object)>>error:
	Receiver: #redPlayer
	Arguments and temporary variables: 
		aString: 	'only integers should be used as indices'
	Receiver's instance variables: 
#redPlayer

ByteSymbol(Object)>>errorNonIntegerIndex
	Receiver: #redPlayer
	Arguments and temporary variables: 

	Receiver's instance variables: 
#redPlayer

ByteSymbol(Object)>>at:
	Receiver: #redPlayer
	Arguments and temporary variables: 
		index: 	#bluePlayer
	Receiver's instance variables: 
#redPlayer

ByteSymbol>>at:
	Receiver: #redPlayer
	Arguments and temporary variables: 
		index: 	#bluePlayer
	Receiver's instance variables: 
#redPlayer

BlankCell>>isPlayerActive:
	Receiver: a BlankCell
	Arguments and temporary variables: 
		player: 	#bluePlayer
	Receiver's instance variables: 
		snakeActive: 	#redPlayer
		snakeHead: 	a Dictionary(#blue->false #red->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )


BlankCell>>somePlayerActive
	Receiver: a BlankCell
	Arguments and temporary variables: 
		blue: 	nil
		red: 	nil
	Receiver's instance variables: 
		snakeActive: 	#redPlayer
		snakeHead: 	a Dictionary(#blue->false #red->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )


[ cell somePlayerActive ] in BlankCellTest>>testCellSomePlayerActive
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlankCellTest(TestAsserter)>>should:
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		aBlock: 	[ cell somePlayerActive ]
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlankCellTest>>testCellSomePlayerActive
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlankCellTest(TestCase)>>performTest
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlankCellTest(TestCase)>>runCaseManaged
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:31:41.380311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:31:41.380311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(BlankCellTest>>#testCellSomePlayerActive nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Object)>>errorNonIntegerIndex
ByteSymbol(Object)>>at:
ByteSymbol>>at:
BlankCell>>isPlayerActive:
BlankCell>>somePlayerActive
[ cell somePlayerActive ] in BlankCellTest>>testCellSomePlayerActive
BlankCellTest(TestAsserter)>>should:
BlankCellTest>>testCellSomePlayerActive
BlankCellTest(TestCase)>>performTest
[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
BlockClosure>>ensure:
BlankCellTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
BlankCellTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
BlockClosure>>ensure:
BlankCellTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: only integers should be used as indices
16 June 2017 3:32:39.518311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

ByteSymbol(Object)>>error:
	Receiver: #redPlayer
	Arguments and temporary variables: 
		aString: 	'only integers should be used as indices'
	Receiver's instance variables: 
#redPlayer

ByteSymbol(Object)>>errorNonIntegerIndex
	Receiver: #redPlayer
	Arguments and temporary variables: 

	Receiver's instance variables: 
#redPlayer

ByteSymbol(Object)>>at:
	Receiver: #redPlayer
	Arguments and temporary variables: 
		index: 	#bluePlayer
	Receiver's instance variables: 
#redPlayer

ByteSymbol>>at:
	Receiver: #redPlayer
	Arguments and temporary variables: 
		index: 	#bluePlayer
	Receiver's instance variables: 
#redPlayer

BlankCell>>isPlayerActive:
	Receiver: a BlankCell
	Arguments and temporary variables: 
		player: 	#bluePlayer
	Receiver's instance variables: 
		snakeActive: 	#redPlayer
		snakeHead: 	a Dictionary(#blue->false #red->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )


BlankCell>>somePlayerActive
	Receiver: a BlankCell
	Arguments and temporary variables: 
		blue: 	nil
		red: 	nil
	Receiver's instance variables: 
		snakeActive: 	#redPlayer
		snakeHead: 	a Dictionary(#blue->false #red->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )


[ cell somePlayerActive ] in BlankCellTest>>testCellSomePlayerActive
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlankCellTest(TestAsserter)>>should:
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		aBlock: 	[ cell somePlayerActive ]
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlankCellTest>>testCellSomePlayerActive
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlankCellTest(TestCase)>>performTest
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlankCellTest(TestCase)>>runCaseManaged
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:32:39.502311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:32:39.502311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(BlankCellTest>>#testCellSomePlayerActive nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Object)>>errorNonIntegerIndex
ByteSymbol(Object)>>at:
ByteSymbol>>at:
BlankCell>>isPlayerActive:
BlankCell>>somePlayerActive
[ cell somePlayerActive ] in BlankCellTest>>testCellSomePlayerActive
BlankCellTest(TestAsserter)>>should:
BlankCellTest>>testCellSomePlayerActive
BlankCellTest(TestCase)>>performTest
[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
BlockClosure>>ensure:
BlankCellTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
BlankCellTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
BlockClosure>>ensure:
BlankCellTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: only integers should be used as indices
16 June 2017 3:33:51.709311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

ByteSymbol(Object)>>error:
	Receiver: #redPlayer
	Arguments and temporary variables: 
		aString: 	'only integers should be used as indices'
	Receiver's instance variables: 
#redPlayer

ByteSymbol(Object)>>errorNonIntegerIndex
	Receiver: #redPlayer
	Arguments and temporary variables: 

	Receiver's instance variables: 
#redPlayer

ByteSymbol(Object)>>at:
	Receiver: #redPlayer
	Arguments and temporary variables: 
		index: 	#bluePlayer
	Receiver's instance variables: 
#redPlayer

ByteSymbol>>at:
	Receiver: #redPlayer
	Arguments and temporary variables: 
		index: 	#bluePlayer
	Receiver's instance variables: 
#redPlayer

BlankCell>>isPlayerActive:
	Receiver: a BlankCell
	Arguments and temporary variables: 
		player: 	#bluePlayer
	Receiver's instance variables: 
		snakeActive: 	#redPlayer
		snakeHead: 	a Dictionary(#blue->false #red->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )


BlankCell>>somePlayerActive
	Receiver: a BlankCell
	Arguments and temporary variables: 
		blue: 	nil
		red: 	nil
	Receiver's instance variables: 
		snakeActive: 	#redPlayer
		snakeHead: 	a Dictionary(#blue->false #red->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )


[ cell somePlayerActive ] in BlankCellTest>>testCellSomePlayerActive
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlankCellTest(TestAsserter)>>should:
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		aBlock: 	[ cell somePlayerActive ]
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlankCellTest>>testCellSomePlayerActive
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlankCellTest(TestCase)>>performTest
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlankCellTest(TestCase)>>runCaseManaged
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:33:51.693311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:33:51.693311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(BlankCellTest>>#testCellSomePlayerActive nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Object)>>errorNonIntegerIndex
ByteSymbol(Object)>>at:
ByteSymbol>>at:
BlankCell>>isPlayerActive:
BlankCell>>somePlayerActive
[ cell somePlayerActive ] in BlankCellTest>>testCellSomePlayerActive
BlankCellTest(TestAsserter)>>should:
BlankCellTest>>testCellSomePlayerActive
BlankCellTest(TestCase)>>performTest
[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
BlockClosure>>ensure:
BlankCellTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
BlankCellTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
BlockClosure>>ensure:
BlankCellTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: only integers should be used as indices
16 June 2017 3:36:22.518311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

ByteSymbol(Object)>>error:
	Receiver: #redPlayer
	Arguments and temporary variables: 
		aString: 	'only integers should be used as indices'
	Receiver's instance variables: 
#redPlayer

ByteSymbol(Object)>>errorNonIntegerIndex
	Receiver: #redPlayer
	Arguments and temporary variables: 

	Receiver's instance variables: 
#redPlayer

ByteSymbol(Object)>>at:
	Receiver: #redPlayer
	Arguments and temporary variables: 
		index: 	#bluePlayer
	Receiver's instance variables: 
#redPlayer

ByteSymbol>>at:
	Receiver: #redPlayer
	Arguments and temporary variables: 
		index: 	#bluePlayer
	Receiver's instance variables: 
#redPlayer

BlankCell>>isPlayerActive:
	Receiver: a BlankCell
	Arguments and temporary variables: 
		player: 	#bluePlayer
	Receiver's instance variables: 
		snakeActive: 	#redPlayer
		snakeHead: 	a Dictionary(#blue->false #red->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )


BlankCell>>somePlayerActive
	Receiver: a BlankCell
	Arguments and temporary variables: 
		blue: 	nil
		red: 	nil
	Receiver's instance variables: 
		snakeActive: 	#redPlayer
		snakeHead: 	a Dictionary(#blue->false #red->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )


[ cell somePlayerActive ] in BlankCellTest>>testCellSomePlayerActive
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlankCellTest(TestAsserter)>>should:
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		aBlock: 	[ cell somePlayerActive ]
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlankCellTest>>testCellSomePlayerActive
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		cell: 	a BlankCell
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlankCellTest(TestCase)>>performTest
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


BlankCellTest(TestCase)>>runCase
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	BlankCellTest>>#testCellSomePlayerActive
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlankCellTest(TestCase)>>runCaseManaged
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:36:22.502311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T15:36:22.502311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	BlankCellTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


BlankCellTest(TestCase)>>debug
	Receiver: BlankCellTest>>#testCellSomePlayerActive
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellSomePlayerActive
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	BlankCellTest>>#testCellSomePlayerActive
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(BlankCellTest>>#testCellSomePlayerActive)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(BlankCellTest>>#testCellSomePlayerActive nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Object)>>errorNonIntegerIndex
ByteSymbol(Object)>>at:
ByteSymbol>>at:
BlankCell>>isPlayerActive:
BlankCell>>somePlayerActive
[ cell somePlayerActive ] in BlankCellTest>>testCellSomePlayerActive
BlankCellTest(TestAsserter)>>should:
BlankCellTest>>testCellSomePlayerActive
BlankCellTest(TestCase)>>performTest
[ self setUp.
self performTest ] in BlankCellTest(TestCase)>>runCase
BlockClosure>>ensure:
BlankCellTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
BlankCellTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in BlankCellTest(TestCase)>>debug
BlockClosure>>ensure:
BlankCellTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

16 June 2017 3:41:37.592311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	4
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	4
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@145)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(699738112) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@145)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@145)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(699738112) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@145)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@145)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(699738112) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@145)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@145)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(699738112) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@145)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(807@467) corner: (823@483)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(807@467) mouseOver CTRL 4715395 nil]
		targetOffset: 	(491@111)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4715395 807 467 0 2 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(807@467) corner: (823@483)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(807@467) mouseOver CTRL 4715395 nil]
		targetOffset: 	(491@111)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 4715395 807 467 0 2 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(206166272))(a SearchMorp...etc...
		lastStepTime: 	4497137
		lastStepMessage: 	nil
		lastCycleTime: 	4497158
		alarms: 	a Heap()
		lastAlarmTime: 	4497137
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

16 June 2017 4:13:53.290311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	5
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	5
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(727783424) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(727783424) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(727783424) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(727783424) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(696@368) corner: (712@384)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(696@368) mouseOver 6650993 nil]
		targetOffset: 	(386@11)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6650993 696 365 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(696@368) corner: (712@384)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(696@368) mouseOver 6650993 nil]
		targetOffset: 	(386@11)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6650993 696 365 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	6432827
		lastStepMessage: 	nil
		lastCycleTime: 	6432849
		alarms: 	a Heap()
		lastAlarmTime: 	6432827
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

16 June 2017 4:15:39.007311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	3
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	3
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(364976384) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(364976384) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(364976384) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(364976384) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(769@432) corner: (785@448)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(769@432) mouseOver 6756840 nil]
		targetOffset: 	(458@71)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6756840 769 432 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(769@432) corner: (785@448)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(769@432) mouseOver 6756840 nil]
		targetOffset: 	(458@71)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6756840 769 432 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	6538580
		lastStepMessage: 	nil
		lastCycleTime: 	6538601
		alarms: 	a Heap()
		lastAlarmTime: 	6538580
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

16 June 2017 4:20:06.469311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	4
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	4
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@221)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(526553600) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@221)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@221)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(526553600) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@221)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@221)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(526553600) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@221)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@221)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(526553600) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@221)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(1@228) corner: (17@244)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1@228) mouseOver 6980420 nil]
		targetOffset: 	(162@105)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6980420 4 228 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(1@228) corner: (17@244)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(1@228) mouseOver 6980420 nil]
		targetOffset: 	(162@105)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6980420 4 228 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	6806047
		lastStepMessage: 	nil
		lastCycleTime: 	6806067
		alarms: 	a Heap()
		lastAlarmTime: 	6806047
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#adaptToNumber:andSend: was sent to nil
16 June 2017 4:29:45.046311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	adaptToNumber: 1 andSend: #'<='
		exception: 	MessageNotUnderstood: receiver of "adaptToNumber:andSend:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject(Object)>>adaptToInteger:andSend:
	Receiver: nil
	Arguments and temporary variables: 
		rcvr: 	1
		selector: 	#'<='
	Receiver's instance variables: 
nil

UndefinedObject(Object)>>adaptToInteger:andCompare:
	Receiver: nil
	Arguments and temporary variables: 
		rcvr: 	1
		selector: 	#'<='
	Receiver's instance variables: 
nil

SmallInteger(Integer)>><=
	Receiver: 1
	Arguments and temporary variables: 
		aNumber: 	nil
	Receiver's instance variables: 
1

SmallInteger>><=
	Receiver: 1
	Arguments and temporary variables: 
		aNumber: 	nil
	Receiver's instance variables: 
1

Grid>>initializeCells
	Receiver: a Grid
	Arguments and temporary variables: 
		x: 	1
	Receiver's instance variables: 
		cells: 	a Dictionary()
		started: 	false
		rows: 	nil
		columns: 	20


Grid>>initialize
	Receiver: a Grid
	Arguments and temporary variables: 

	Receiver's instance variables: 
		cells: 	a Dictionary()
		started: 	false
		rows: 	nil
		columns: 	20


Grid class(Behavior)>>new
	Receiver: Grid
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#at:->Grid>>#at: #at:put:->Grid>>#at:put: #cells...etc...
		format: 	65540
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Grid
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Snake_Game_Model
		traitComposition: 	{}
		localSelectors: 	nil


GridTest>>testGridInitialization
	Receiver: GridTest>>#testGridInitialization
	Arguments and temporary variables: 
		grid: 	nil
		cell: 	nil
	Receiver's instance variables: 
		testSelector: 	#testGridInitialization
		expectedFails: 	#()


GridTest(TestCase)>>performTest
	Receiver: GridTest>>#testGridInitialization
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGridInitialization
		expectedFails: 	#()


[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testGridInitialization
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGridInitialization
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testGridInitialization
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGridInitialization
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testGridInitialization
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testGridInitialization
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testGridInitialization
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testGridInitialization
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testGridInitialization
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testGridInitialization
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testGridInitialization
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


GridTest(TestCase)>>runCaseManaged
	Receiver: GridTest>>#testGridInitialization
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGridInitialization
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T16:29:45.018311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GridTest>>#testGridInitialization)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T16:29:45.018311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GridTest>>#testGridInitialization)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
	Receiver: GridTest>>#testGridInitialization
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testGridInitialization
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


GridTest(TestCase)>>debug
	Receiver: GridTest>>#testGridInitialization
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testGridInitialization
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testGridInitialization)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(GridTest>>#testGridInitialization)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(GridTest>>#testGridInitialization nil nil nil nil nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject(Object)>>adaptToInteger:andSend:
UndefinedObject(Object)>>adaptToInteger:andCompare:
SmallInteger(Integer)>><=
SmallInteger>><=
Grid>>initializeCells
Grid>>initialize
Grid class(Behavior)>>new
GridTest>>testGridInitialization
GridTest(TestCase)>>performTest
[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
BlockClosure>>ensure:
GridTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GridTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
BlockClosure>>ensure:
GridTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
#adaptToNumber:andSend: was sent to nil
16 June 2017 4:32:04.842311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
	Receiver: nil
	Arguments and temporary variables: 
		aMessage: 	adaptToNumber: 1 andSend: #'<='
		exception: 	MessageNotUnderstood: receiver of "adaptToNumber:andSend:" is nil
		resumeValue: 	nil
	Receiver's instance variables: 
nil

UndefinedObject(Object)>>adaptToInteger:andSend:
	Receiver: nil
	Arguments and temporary variables: 
		rcvr: 	1
		selector: 	#'<='
	Receiver's instance variables: 
nil

UndefinedObject(Object)>>adaptToInteger:andCompare:
	Receiver: nil
	Arguments and temporary variables: 
		rcvr: 	1
		selector: 	#'<='
	Receiver's instance variables: 
nil

SmallInteger(Integer)>><=
	Receiver: 1
	Arguments and temporary variables: 
		aNumber: 	nil
	Receiver's instance variables: 
1

SmallInteger>><=
	Receiver: 1
	Arguments and temporary variables: 
		aNumber: 	nil
	Receiver's instance variables: 
1

Grid>>initializeCells
	Receiver: a Grid
	Arguments and temporary variables: 
		x: 	1
	Receiver's instance variables: 
		cells: 	a Dictionary()
		started: 	false
		rows: 	nil
		columns: 	20


Grid>>initialize
	Receiver: a Grid
	Arguments and temporary variables: 

	Receiver's instance variables: 
		cells: 	a Dictionary()
		started: 	false
		rows: 	nil
		columns: 	20


Grid class(Behavior)>>new
	Receiver: Grid
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#at:->Grid>>#at: #at:put:->Grid>>#at:put: #cells...etc...
		format: 	65540
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Grid
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Snake_Game_Model
		traitComposition: 	{}
		localSelectors: 	nil


GridTest>>testGridInitialization
	Receiver: GridTest>>#testGridInitialization
	Arguments and temporary variables: 
		grid: 	nil
		cell: 	nil
	Receiver's instance variables: 
		testSelector: 	#testGridInitialization
		expectedFails: 	#()


GridTest(TestCase)>>performTest
	Receiver: GridTest>>#testGridInitialization
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGridInitialization
		expectedFails: 	#()


[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testGridInitialization
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGridInitialization
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testGridInitialization
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGridInitialization
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testGridInitialization
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testGridInitialization
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testGridInitialization
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testGridInitialization
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testGridInitialization
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testGridInitialization
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testGridInitialization
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


GridTest(TestCase)>>runCaseManaged
	Receiver: GridTest>>#testGridInitialization
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testGridInitialization
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T16:32:04.829311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GridTest>>#testGridInitialization)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T16:32:04.829311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GridTest>>#testGridInitialization)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
	Receiver: GridTest>>#testGridInitialization
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testGridInitialization
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


GridTest(TestCase)>>debug
	Receiver: GridTest>>#testGridInitialization
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testGridInitialization
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	GridTest>>#testGridInitialization
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testGridInitialization)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(GridTest>>#testGridInitialization)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(GridTest>>#testGridInitialization nil nil nil nil nil nil nil n...etc...
		firstIndex: 	1
		lastIndex: 	1



--- The full stack ---
UndefinedObject(Object)>>doesNotUnderstand: #adaptToNumber:andSend:
UndefinedObject(Object)>>adaptToInteger:andSend:
UndefinedObject(Object)>>adaptToInteger:andCompare:
SmallInteger(Integer)>><=
SmallInteger>><=
Grid>>initializeCells
Grid>>initialize
Grid class(Behavior)>>new
GridTest>>testGridInitialization
GridTest(TestCase)>>performTest
[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
BlockClosure>>ensure:
GridTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GridTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
BlockClosure>>ensure:
GridTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

16 June 2017 4:33:37.843311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	3
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	3
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@202)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(222998528) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@202)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@202)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(222998528) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@202)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@202)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(222998528) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@202)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (821@202)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(222998528) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (821@202)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(532@516) corner: (548@532)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(532@516) mouseOver 7835977 nil]
		targetOffset: 	(326@171)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7835977 532 516 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(532@516) corner: (548@532)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(532@516) mouseOver 7835977 nil]
		targetOffset: 	(326@171)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7835977 532 516 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	7617412
		lastStepMessage: 	nil
		lastCycleTime: 	7617432
		alarms: 	a Heap()
		lastAlarmTime: 	7617412
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

16 June 2017 4:34:14.665311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	3
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	3
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@202)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(222998528) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@202)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@202)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(222998528) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@202)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@202)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(222998528) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@202)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@202)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(222998528) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@202)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(636@373) corner: (652@389)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(636@373) mouseOver 7872387 nil]
		targetOffset: 	(376.0@109.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7872387 636 373 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(636@373) corner: (652@389)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(636@373) mouseOver 7872387 nil]
		targetOffset: 	(376.0@109.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7872387 636 373 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	7654211
		lastStepMessage: 	nil
		lastCycleTime: 	7654233
		alarms: 	a Heap()
		lastAlarmTime: 	7654211
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

16 June 2017 4:41:45.518311 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in [ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	[ self value.
Processor terminateActive ] in BlockClosure>>ne...etc...
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in [ self value.
Processor terminateActive ] in Bloc...etc...


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in [ self value.
Processor terminateActive ] in Bloc...etc...


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	5
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	5
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@183)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(932766464) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@183)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@183)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(932766464) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@183)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@183)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(932766464) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@183)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@183)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(932766464) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@183)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(564@382) corner: (580@398)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(564@382) mouseOver 8323417 nil]
		targetOffset: 	(323.0@122.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 8323417 564 382 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(564@382) corner: (580@398)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(564@382) mouseOver 8323417 nil]
		targetOffset: 	(323.0@122.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 8323417 564 382 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	8105045
		lastStepMessage: 	nil
		lastCycleTime: 	8105066
		alarms: 	a Heap()
		lastAlarmTime: 	8105045
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T14:26:40.216311+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

16 June 2017 6:11:40.165107 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in [ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	[ self value.
Processor terminateActive ] in BlockClosure>>ne...etc...
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in [ self value.
Processor terminateActive ] in Bloc...etc...


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in [ self value.
Processor terminateActive ] in Bloc...etc...


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	5
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	5
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@240)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(821571584) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@240)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@240)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(821571584) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@240)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@240)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(821571584) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@240)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@240)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(821571584) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@240)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(607@384) corner: (623@400)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(607@384) mouseOver 13697308 nil]
		targetOffset: 	(339.0@183.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 13697308 607 385 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(607@384) corner: (623@400)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(607@384) mouseOver 13697308 nil]
		targetOffset: 	(339.0@183.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 13697308 607 385 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	102043
		lastStepMessage: 	nil
		lastCycleTime: 	102064
		alarms: 	a Heap()
		lastAlarmTime: 	102043
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T18:09:57.749107+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T18:09:57.749107+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T18:09:57.749107+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T18:09:57.749107+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T18:09:57.749107+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T18:09:57.749107+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
16 June 2017 6:33:30.649107 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

GridTest(TestAsserter)>>assert:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestAsserter)>>should:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBlock: 	[ cell1 snakeHead = #bluePlayer ]
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest>>testHeadPositions
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		grid: 	a Grid
		cell1: 	a BlankCell
		cell2: 	nil
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestCase)>>performTest
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


GridTest(TestCase)>>runCaseManaged
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T18:33:30.611107+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T18:33:30.611107+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(GridTest>>#testHeadPositions)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(GridTest>>#testHeadPositions nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. GridTest}
		classIndex: 	1
		classesSelected: 	a Set(BlankCellTest GridTest)
		failedList: 	an Array(GridTest>>#testHeadPositions)
		failedSelected: 	GridTest>>#testHeadPositions
		errorList: 	an Array(BlankCellTest>>#testCellSnakeHead)
		errorSelected: 	nil
		lastUpdate: 	3675083608
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
GridTest(TestAsserter)>>assert:
GridTest(TestAsserter)>>should:
GridTest>>testHeadPositions
GridTest(TestCase)>>performTest
[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
BlockClosure>>ensure:
GridTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GridTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
BlockClosure>>ensure:
GridTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
16 June 2017 6:34:03.207107 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

GridTest(TestAsserter)>>assert:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestAsserter)>>should:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBlock: 	[ cell1 snakeHead at: #bluePlayer ]
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest>>testHeadPositions
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		grid: 	a Grid
		cell1: 	a BlankCell
		cell2: 	nil
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestCase)>>performTest
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


GridTest(TestCase)>>runCaseManaged
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T18:34:03.193107+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T18:34:03.193107+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(GridTest>>#testHeadPositions)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(GridTest>>#testHeadPositions nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. GridTest}
		classIndex: 	1
		classesSelected: 	a Set(BlankCellTest GridTest)
		failedList: 	an Array(GridTest>>#testHeadPositions)
		failedSelected: 	GridTest>>#testHeadPositions
		errorList: 	an Array(BlankCellTest>>#testCellSnakeHead)
		errorSelected: 	nil
		lastUpdate: 	3675083641
		result: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 6 passes, 0 skipped, 0 expected failures, 1 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
GridTest(TestAsserter)>>assert:
GridTest(TestAsserter)>>should:
GridTest>>testHeadPositions
GridTest(TestCase)>>performTest
[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
BlockClosure>>ensure:
GridTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GridTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
BlockClosure>>ensure:
GridTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
16 June 2017 6:38:23.768107 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

GridTest(TestAsserter)>>assert:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestAsserter)>>should:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBlock: 	[ cell1 snakeHead at: #bluePlayer ]
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest>>testHeadPositions
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		grid: 	a Grid
		cell1: 	a BlankCell
		cell2: 	nil
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestCase)>>performTest
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


GridTest(TestCase)>>runCaseManaged
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T18:38:23.755107+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-16T18:38:23.755107+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(GridTest>>#testHeadPositions)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(GridTest>>#testHeadPositions nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. GridTest}
		classIndex: 	1
		classesSelected: 	a Set(BlankCellTest GridTest)
		failedList: 	an Array(GridTest>>#testHeadPositions)
		failedSelected: 	GridTest>>#testHeadPositions
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3675083901
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
GridTest(TestAsserter)>>assert:
GridTest(TestAsserter)>>should:
GridTest>>testHeadPositions
GridTest(TestCase)>>performTest
[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
BlockClosure>>ensure:
GridTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GridTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
BlockClosure>>ensure:
GridTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

16 June 2017 6:41:45.953107 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	5
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	5
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@316)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(610906112) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@316)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@316)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(610906112) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@316)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@316)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(610906112) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@316)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@316)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(610906112) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@316)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(560@478) corner: (576@494)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(560@478) mouseOver 15504221 nil]
		targetOffset: 	(299@187)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 15504221 560 478 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(560@478) corner: (576@494)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(560@478) mouseOver 15504221 nil]
		targetOffset: 	(299@187)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 15504221 560 478 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	1907807
		lastStepMessage: 	nil
		lastCycleTime: 	1907828
		alarms: 	a Heap()
		lastAlarmTime: 	1907807
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T18:09:57.749107+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T18:09:57.749107+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T18:09:57.749107+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T18:09:57.749107+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T18:09:57.749107+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-16T18:09:57.749107+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

17 June 2017 2:09:08.828846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	5
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	5
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@316)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(610906112) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@316)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@316)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(610906112) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@316)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@316)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(610906112) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@316)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@316)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(610906112) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@316)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(560@478) corner: (576@494)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(560@478) mouseOver 15504221 nil]
		targetOffset: 	(299@187)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 15504221 560 478 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(560@478) corner: (576@494)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(560@478) mouseOver 15504221 nil]
		targetOffset: 	(299@187)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 15504221 560 478 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1288@730)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1288@730)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1288@730)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	1907807
		lastStepMessage: 	nil
		lastCycleTime: 	1907828
		alarms: 	a Heap()
		lastAlarmTime: 	1907807
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1288@730)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1288@730)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1288@730)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	true
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	true
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	true
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	true
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	true
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	true
		snapshotResult: 	true
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #x
17 June 2017 2:13:38.136846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

SmallInteger(Object)>>doesNotUnderstand: #x
	Receiver: 20
	Arguments and temporary variables: 
		aMessage: 	x
		exception: 	MessageNotUnderstood: SmallInteger>>x
		resumeValue: 	nil
	Receiver's instance variables: 
20

Grid class>>newOfSize:
	Receiver: Grid
	Arguments and temporary variables: 
		xy: 	20
		model: 	a Grid
	Receiver's instance variables: 
		superclass: 	Object
		methodDict: 	a MethodDictionary(#at:->Grid>>#at: #at:put:->Grid>>#at:put: #blueH...etc...
		format: 	65544
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#Grid
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Snake_Game_Model
		traitComposition: 	{}
		localSelectors: 	nil


GridTest>>testHeadPositions
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		grid: 	nil
		cell1: 	nil
		cell2: 	nil
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestCase)>>performTest
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


GridTest(TestCase)>>runCaseManaged
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:13:38.100846+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GridTest>>#testHeadPositions)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:13:38.100846+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GridTest>>#testHeadPositions)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(GridTest>>#testHeadPositions)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(GridTest>>#testHeadPositions nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. GridTest}
		classIndex: 	1
		classesSelected: 	a Set(BlankCellTest GridTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(GridTest>>#testHeadPositions)
		errorSelected: 	GridTest>>#testHeadPositions
		lastUpdate: 	3675154416
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 7 passes, 0 skipped, 0 expected failures, 0 failures, 1 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #x
Grid class>>newOfSize:
GridTest>>testHeadPositions
GridTest(TestCase)>>performTest
[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
BlockClosure>>ensure:
GridTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GridTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
BlockClosure>>ensure:
GridTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
17 June 2017 2:14:15.159846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

GridTest(TestAsserter)>>assert:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestAsserter)>>should:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBlock: 	[ cell1 snakeHead at: #bluePlayer ]
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest>>testHeadPositions
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		grid: 	a Grid
		cell1: 	a BlankCell
		cell2: 	nil
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestCase)>>performTest
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


GridTest(TestCase)>>runCaseManaged
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:14:15.147846+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:14:15.147846+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(GridTest>>#testHeadPositions)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(GridTest>>#testHeadPositions nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. GridTest}
		classIndex: 	1
		classesSelected: 	a Set(BlankCellTest GridTest)
		failedList: 	an Array(GridTest>>#testHeadPositions)
		failedSelected: 	GridTest>>#testHeadPositions
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3675154453
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
GridTest(TestAsserter)>>assert:
GridTest(TestAsserter)>>should:
GridTest>>testHeadPositions
GridTest(TestCase)>>performTest
[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
BlockClosure>>ensure:
GridTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GridTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
BlockClosure>>ensure:
GridTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Error: only integers should be used as indices
17 June 2017 2:18:14.796846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

ByteSymbol(Object)>>error:
	Receiver: #redPlayer
	Arguments and temporary variables: 
		aString: 	'only integers should be used as indices'
	Receiver's instance variables: 
#redPlayer

ByteSymbol(Object)>>errorNonIntegerIndex
	Receiver: #redPlayer
	Arguments and temporary variables: 

	Receiver's instance variables: 
#redPlayer

ByteSymbol(Object)>>at:
	Receiver: #redPlayer
	Arguments and temporary variables: 
		index: 	#bluePlayer
	Receiver's instance variables: 
#redPlayer

ByteSymbol>>at:
	Receiver: #redPlayer
	Arguments and temporary variables: 
		index: 	#bluePlayer
	Receiver's instance variables: 
#redPlayer

[ cell1 snakeHead at: #bluePlayer ] in GridTest>>testHeadPositions
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		grid: 	a Grid
		cell1: 	a BlankCell
		cell2: 	nil
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestAsserter)>>should:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBlock: 	[ cell1 snakeHead at: #bluePlayer ]
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest>>testHeadPositions
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		grid: 	a Grid
		cell1: 	a BlankCell
		cell2: 	nil
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestCase)>>performTest
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


GridTest(TestCase)>>runCaseManaged
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:18:14.782846+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GridTest>>#testHeadPositions)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:18:14.782846+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(GridTest>>#testHeadPositions)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(GridTest>>#testHeadPositions)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(GridTest>>#testHeadPositions nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0



--- The full stack ---
ByteSymbol(Object)>>error:
ByteSymbol(Object)>>errorNonIntegerIndex
ByteSymbol(Object)>>at:
ByteSymbol>>at:
[ cell1 snakeHead at: #bluePlayer ] in GridTest>>testHeadPositions
GridTest(TestAsserter)>>should:
GridTest>>testHeadPositions
GridTest(TestCase)>>performTest
[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
BlockClosure>>ensure:
GridTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GridTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
BlockClosure>>ensure:
GridTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
17 June 2017 2:20:30.943846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

GridTest(TestAsserter)>>assert:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestAsserter)>>should:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBlock: 	[ cell1 snakeHead at: #bluePlayer ]
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest>>testHeadPositions
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		grid: 	a Grid
		cell1: 	a BlankCell
		cell2: 	nil
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestCase)>>performTest
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


GridTest(TestCase)>>runCaseManaged
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:20:30.929846+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:20:30.929846+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(GridTest>>#testHeadPositions)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(GridTest>>#testHeadPositions nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. GridTest}
		classIndex: 	1
		classesSelected: 	a Set(BlankCellTest GridTest)
		failedList: 	an Array(GridTest>>#testHeadPositions)
		failedSelected: 	GridTest>>#testHeadPositions
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3675154829
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
GridTest(TestAsserter)>>assert:
GridTest(TestAsserter)>>should:
GridTest>>testHeadPositions
GridTest(TestCase)>>performTest
[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
BlockClosure>>ensure:
GridTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GridTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
BlockClosure>>ensure:
GridTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
17 June 2017 2:21:01.730846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

GridTest(TestAsserter)>>assert:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestAsserter)>>should:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBlock: 	[ cell1 snakeHead at: #bluePlayer ]
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest>>testHeadPositions
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		grid: 	a Grid
		cell1: 	a BlankCell
		cell2: 	nil
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestCase)>>performTest
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


GridTest(TestCase)>>runCaseManaged
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:21:01.718846+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:21:01.718846+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(GridTest>>#testHeadPositions)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(GridTest>>#testHeadPositions nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. GridTest}
		classIndex: 	1
		classesSelected: 	a Set(BlankCellTest GridTest)
		failedList: 	an Array(GridTest>>#testHeadPositions)
		failedSelected: 	GridTest>>#testHeadPositions
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3675154860
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
GridTest(TestAsserter)>>assert:
GridTest(TestAsserter)>>should:
GridTest>>testHeadPositions
GridTest(TestCase)>>performTest
[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
BlockClosure>>ensure:
GridTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GridTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
BlockClosure>>ensure:
GridTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
17 June 2017 2:21:11.906846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

GridTest(TestAsserter)>>assert:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestAsserter)>>should:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBlock: 	[ cell1 snakeHead at: #bluePlayer ]
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest>>testHeadPositions
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		grid: 	a Grid
		cell1: 	a BlankCell
		cell2: 	nil
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestCase)>>performTest
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


GridTest(TestCase)>>runCaseManaged
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:21:11.891846+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:21:11.891846+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(GridTest>>#testHeadPositions)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(GridTest>>#testHeadPositions nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. GridTest}
		classIndex: 	1
		classesSelected: 	a Set(BlankCellTest GridTest)
		failedList: 	an Array(GridTest>>#testHeadPositions)
		failedSelected: 	GridTest>>#testHeadPositions
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3675154860
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
GridTest(TestAsserter)>>assert:
GridTest(TestAsserter)>>should:
GridTest>>testHeadPositions
GridTest(TestCase)>>performTest
[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
BlockClosure>>ensure:
GridTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GridTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
BlockClosure>>ensure:
GridTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
17 June 2017 2:21:27.439846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

GridTest(TestAsserter)>>assert:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestAsserter)>>should:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBlock: 	[ cell1 snakeHead at: #bluePlayer ]
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest>>testHeadPositions
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		grid: 	a Grid
		cell1: 	a BlankCell
		cell2: 	nil
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestCase)>>performTest
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


GridTest(TestCase)>>runCaseManaged
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:21:27.424846+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:21:27.424846+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(GridTest>>#testHeadPositions)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(GridTest>>#testHeadPositions nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. GridTest}
		classIndex: 	1
		classesSelected: 	a Set(BlankCellTest GridTest)
		failedList: 	an Array(GridTest>>#testHeadPositions)
		failedSelected: 	GridTest>>#testHeadPositions
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3675154860
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
GridTest(TestAsserter)>>assert:
GridTest(TestAsserter)>>should:
GridTest>>testHeadPositions
GridTest(TestCase)>>performTest
[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
BlockClosure>>ensure:
GridTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GridTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
BlockClosure>>ensure:
GridTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
TestFailure: Assertion failed
17 June 2017 2:22:21.153846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

GridTest(TestAsserter)>>assert:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestAsserter)>>should:
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		aBlock: 	[ cell1 snakeHead at: #bluePlayer ]
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest>>testHeadPositions
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		grid: 	a Grid
		cell1: 	a BlankCell
		cell2: 	nil
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


GridTest(TestCase)>>performTest
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


GridTest(TestCase)>>runCase
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	GridTest>>#testHeadPositions
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


GridTest(TestCase)>>runCaseManaged
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:22:21.139846+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:22:21.139846+02:00
		failures: 	a Set(GridTest>>#testHeadPositions)
		errors: 	an OrderedCollection()
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	GridTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


GridTest(TestCase)>>debug
	Receiver: GridTest>>#testHeadPositions
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testHeadPositions
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	GridTest>>#testHeadPositions
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(GridTest>>#testHeadPositions)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(GridTest>>#testHeadPositions nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(GridTest>>#testHeadPositions)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. GridTest}
		classIndex: 	1
		classesSelected: 	a Set(BlankCellTest GridTest)
		failedList: 	an Array(GridTest>>#testHeadPositions)
		failedSelected: 	GridTest>>#testHeadPositions
		errorList: 	#()
		errorSelected: 	nil
		lastUpdate: 	3675154939
		result: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	8 run, 7 passes, 0 skipped, 0 expected failures, 1 failures, 0 error...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
GridTest(TestAsserter)>>assert:
GridTest(TestAsserter)>>should:
GridTest>>testHeadPositions
GridTest(TestCase)>>performTest
[ self setUp.
self performTest ] in GridTest(TestCase)>>runCase
BlockClosure>>ensure:
GridTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
GridTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in GridTest(TestCase)>>debug
BlockClosure>>ensure:
GridTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>failedSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

17 June 2017 2:29:20.307846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	1
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	1
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(556175616) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(556175616) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(556175616) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(556175616) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(6@204) corner: (22@220)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(6@204) mouseOver 2109258 nil]
		targetOffset: 	(26.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2109258 85 221 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(6@204) corner: (22@220)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456)
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(6@204) mouseOver 2109258 nil]
		targetOffset: 	(26.0@10.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 2109258 85 221 0 0 1 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	1211383
		lastStepMessage: 	nil
		lastCycleTime: 	1211403
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(474527232)))
		lastAlarmTime: 	1211383
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #'@-'
17 June 2017 2:43:54.784846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

SmallInteger(Object)>>doesNotUnderstand: #'@-'
	Receiver: 0
	Arguments and temporary variables: 
		aMessage: 	@- 1
		exception: 	MessageNotUnderstood: SmallInteger>>@-
		resumeValue: 	nil
	Receiver's instance variables: 
0

North class>>vector
	Receiver: North
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Directions
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#North
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Snake_Game_Model
		traitComposition: 	{}
		localSelectors: 	nil


[ dir vector = (0 @ -1) ] in DirectionTest>>testDirectionSelection
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 
		dir: 	North
	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


DirectionTest(TestAsserter)>>should:
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 
		aBlock: 	[ dir vector = (0 @ -1) ]
	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


DirectionTest>>testDirectionSelection
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 
		dir: 	North
	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


DirectionTest(TestCase)>>performTest
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


[ self setUp.
self performTest ] in DirectionTest(TestCase)>>runCase
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	DirectionTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


DirectionTest(TestCase)>>runCase
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	DirectionTest>>#testDirectionSelection
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	DirectionTest>>#testDirectionSelection
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	DirectionTest>>#testDirectionSelection
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	DirectionTest>>#testDirectionSelection
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	DirectionTest>>#testDirectionSelection
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	DirectionTest>>#testDirectionSelection
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	DirectionTest>>#testDirectionSelection
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


DirectionTest(TestCase)>>runCaseManaged
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:43:54.753846+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(DirectionTest>>#testDirectionSelection)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:43:54.753846+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(DirectionTest>>#testDirectionSelection)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in DirectionTest(TestCase)>>debug
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	DirectionTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


DirectionTest(TestCase)>>debug
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(DirectionTest>>#testDirectionSelection)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(DirectionTest>>#testDirectionSelection)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(DirectionTest>>#testDirectionSelection nil nil nil nil nil nil ...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(DirectionTest>>#testDirectionSelection)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(DirectionTest>>#testDirectionSelection)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. DirectionTest. GridTest}
		classIndex: 	2
		classesSelected: 	a Set(BlankCellTest GridTest DirectionTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(DirectionTest>>#testDirectionSelection)
		errorSelected: 	DirectionTest>>#testDirectionSelection
		lastUpdate: 	3675156226
		result: 	9 run, 8 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #'@-'
North class>>vector
[ dir vector = (0 @ -1) ] in DirectionTest>>testDirectionSelection
DirectionTest(TestAsserter)>>should:
DirectionTest>>testDirectionSelection
DirectionTest(TestCase)>>performTest
[ self setUp.
self performTest ] in DirectionTest(TestCase)>>runCase
BlockClosure>>ensure:
DirectionTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
DirectionTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in DirectionTest(TestCase)>>debug
BlockClosure>>ensure:
DirectionTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #'@-'
17 June 2017 2:44:02.684846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

SmallInteger(Object)>>doesNotUnderstand: #'@-'
	Receiver: 0
	Arguments and temporary variables: 
		aMessage: 	@- 1
		exception: 	MessageNotUnderstood: SmallInteger>>@-
		resumeValue: 	nil
	Receiver's instance variables: 
0

North class>>vector
	Receiver: North
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	Directions
		methodDict: 	a MethodDictionary()
		format: 	0
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#North
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Snake_Game_Model
		traitComposition: 	{}
		localSelectors: 	nil


[ dir vector = (0 @ -1) ] in DirectionTest>>testDirectionSelection
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 
		dir: 	North
	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


DirectionTest(TestAsserter)>>should:
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 
		aBlock: 	[ dir vector = (0 @ -1) ]
	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


DirectionTest>>testDirectionSelection
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 
		dir: 	North
	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


DirectionTest(TestCase)>>performTest
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


[ self setUp.
self performTest ] in DirectionTest(TestCase)>>runCase
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	DirectionTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


DirectionTest(TestCase)>>runCase
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	DirectionTest>>#testDirectionSelection
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	DirectionTest>>#testDirectionSelection
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	DirectionTest>>#testDirectionSelection
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	DirectionTest>>#testDirectionSelection
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	DirectionTest>>#testDirectionSelection
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	DirectionTest>>#testDirectionSelection
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	DirectionTest>>#testDirectionSelection
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


DirectionTest(TestCase)>>runCaseManaged
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:44:02.670846+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(DirectionTest>>#testDirectionSelection)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T14:44:02.670846+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(DirectionTest>>#testDirectionSelection)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in DirectionTest(TestCase)>>debug
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	DirectionTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


DirectionTest(TestCase)>>debug
	Receiver: DirectionTest>>#testDirectionSelection
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testDirectionSelection
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	DirectionTest>>#testDirectionSelection
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(DirectionTest>>#testDirectionSelection)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(DirectionTest>>#testDirectionSelection)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(DirectionTest>>#testDirectionSelection nil nil nil nil nil nil ...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(DirectionTest>>#testDirectionSelection)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(DirectionTest>>#testDirectionSelection)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. DirectionTest. GridTest}
		classIndex: 	2
		classesSelected: 	a Set(BlankCellTest GridTest DirectionTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(DirectionTest>>#testDirectionSelection)
		errorSelected: 	DirectionTest>>#testDirectionSelection
		lastUpdate: 	3675156226
		result: 	9 run, 8 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #'@-'
North class>>vector
[ dir vector = (0 @ -1) ] in DirectionTest>>testDirectionSelection
DirectionTest(TestAsserter)>>should:
DirectionTest>>testDirectionSelection
DirectionTest(TestCase)>>performTest
[ self setUp.
self performTest ] in DirectionTest(TestCase)>>runCase
BlockClosure>>ensure:
DirectionTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
DirectionTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in DirectionTest(TestCase)>>debug
BlockClosure>>ensure:
DirectionTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

17 June 2017 3:23:57.440846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	5
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	5
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(861377792) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(861377792) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(861377792) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@88)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(861377792) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@88)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(567@317) corner: (583@333)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(567@317) mouseOver CTRL 5425652 nil]
		targetOffset: 	(37.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 5425652 567 317 0 2 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(567@317) corner: (583@333)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(567@317) mouseOver CTRL 5425652 nil]
		targetOffset: 	(37.0@15.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 5425652 567 317 0 2 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	4488467
		lastStepMessage: 	nil
		lastCycleTime: 	4488487
		alarms: 	a Heap()
		lastAlarmTime: 	4488467
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

17 June 2017 3:27:51.840846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	5
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	5
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@126)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(684042240) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@126)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@126)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(684042240) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@126)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@126)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(684042240) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@126)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@126)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(684042240) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@126)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(636@348) corner: (652@364)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(636@348) mouseOver 5653429 nil]
		targetOffset: 	(376@57)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 5653429 636 348 0 0 2 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(636@348) corner: (652@364)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(636@348) mouseOver 5653429 nil]
		targetOffset: 	(376@57)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	true
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 5653429 636 348 0 0 2 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	4722947
		lastStepMessage: 	nil
		lastCycleTime: 	4722968
		alarms: 	a Heap()
		lastAlarmTime: 	4722947
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a Nautilus...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Grid did not understand #at
17 June 2017 3:34:51.045846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Grid(Object)>>doesNotUnderstand: #at
	Receiver: a Grid
	Arguments and temporary variables: 
		aMessage: 	at
		exception: 	MessageNotUnderstood: Grid>>at
		resumeValue: 	nil
	Receiver's instance variables: 
		cells: 	a Dictionary(size 900)
		started: 	false
		rows: 	30
		columns: 	30
		redCells: 	nil
		redHead: 	a Cell
		blueCells: 	nil
		blueHead: 	a Cell


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 dept...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: 2...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form extent: 25 @ 25 depth...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@202)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(444751104) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(93701120))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	5142521
		lastStepMessage: 	nil
		lastCycleTime: 	5142541
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	5142521
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	5142521
		lastStepMessage: 	nil
		lastCycleTime: 	5142541
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	5142521
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	5142521
		lastStepMessage: 	nil
		lastCycleTime: 	5142541
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	5142521
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Grid(Object)>>doesNotUnderstand: #at
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Grid did not understand #at
17 June 2017 3:35:10.561846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Grid(Object)>>doesNotUnderstand: #at
	Receiver: a Grid
	Arguments and temporary variables: 
		aMessage: 	at
		exception: 	MessageNotUnderstood: Grid>>at
		resumeValue: 	nil
	Receiver's instance variables: 
		cells: 	a Dictionary(size 900)
		started: 	false
		rows: 	30
		columns: 	30
		redCells: 	nil
		redHead: 	a Cell
		blueCells: 	nil
		blueHead: 	a Cell


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 dept...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: 2...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form extent: 25 @ 25 depth...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@221)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(813777152) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(904056832))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	5162046
		lastStepMessage: 	nil
		lastCycleTime: 	5162066
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	5162046
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	5162046
		lastStepMessage: 	nil
		lastCycleTime: 	5162066
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	5162046
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	5162046
		lastStepMessage: 	nil
		lastCycleTime: 	5162066
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	5162046
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Grid(Object)>>doesNotUnderstand: #at
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Grid did not understand #at
17 June 2017 3:35:28.401846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Grid(Object)>>doesNotUnderstand: #at
	Receiver: a Grid
	Arguments and temporary variables: 
		aMessage: 	at
		exception: 	MessageNotUnderstood: Grid>>at
		resumeValue: 	nil
	Receiver's instance variables: 
		cells: 	a Dictionary(size 900)
		started: 	false
		rows: 	30
		columns: 	30
		redCells: 	nil
		redHead: 	a Cell
		blueCells: 	nil
		blueHead: 	a Cell


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 dept...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: 2...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form extent: 25 @ 25 depth...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@202)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(684736768) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(667847936))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	5179883
		lastStepMessage: 	nil
		lastCycleTime: 	5179903
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	5179883
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	5179883
		lastStepMessage: 	nil
		lastCycleTime: 	5179903
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	5179883
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	5179883
		lastStepMessage: 	nil
		lastCycleTime: 	5179903
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	5179883
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Grid(Object)>>doesNotUnderstand: #at
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cell did not understand #grid:
17 June 2017 3:35:39.200846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Cell(Object)>>doesNotUnderstand: #grid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	grid: a Grid
		exception: 	MessageNotUnderstood: Cell>>grid:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 dept...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: 2...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form extent: 25 @ 25 depth...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@202)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(684736768) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(197090304))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	5190683
		lastStepMessage: 	nil
		lastCycleTime: 	5190703
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	5190683
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	5190683
		lastStepMessage: 	nil
		lastCycleTime: 	5190703
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	5190683
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	5190683
		lastStepMessage: 	nil
		lastCycleTime: 	5190703
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	5190683
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Cell(Object)>>doesNotUnderstand: #grid:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

17 June 2017 3:36:11.166846 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a GLMRubricSmalltalkTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a GLMRubricSmalltalkTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	4
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	4
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@202)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(684736768) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (580@202)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHoverHighlightSegmentMorph(644831232))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@202)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(684736768) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (580@202)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHoverHighlightSegmentMorph(644831232))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@202)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(684736768) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (580@202)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHoverHighlightSegmentMorph(644831232))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@202)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(684736768) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (580@202)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHoverHighlightSegmentMorph(644831232))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(710488064)
	Receiver's instance variables: 
		bounds: 	(545@323) corner: (561@339)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(545@323) mouseOver SHIFT CTRL 6159605 nil]
		targetOffset: 	(157.0@184.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6159605 542 323 0 3 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(545@323) corner: (561@339)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(545@323) mouseOver SHIFT CTRL 6159605 nil]
		targetOffset: 	(157.0@184.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6159605 542 323 0 3 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	5222228
		lastStepMessage: 	nil
		lastCycleTime: 	5222248
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	5222228
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T14:09:08.709846+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

17 June 2017 3:36:27.307668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a GLMRubricSmalltalkTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a GLMRubricSmalltalkTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	4
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	4
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@202)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(684736768) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (580@202)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHoverHighlightSegmentMorph(644831232))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@202)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(684736768) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (580@202)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHoverHighlightSegmentMorph(644831232))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@202)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(684736768) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (580@202)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHoverHighlightSegmentMorph(644831232))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@202)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(684736768) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (580@202)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHoverHighlightSegmentMorph(644831232))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(710488064)
	Receiver's instance variables: 
		bounds: 	(545@323) corner: (561@339)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(545@323) mouseOver SHIFT CTRL 6159605 nil]
		targetOffset: 	(157.0@184.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6159605 542 323 0 3 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(545@323) corner: (561@339)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(545@323) mouseOver SHIFT CTRL 6159605 nil]
		targetOffset: 	(157.0@184.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 6159605 542 323 0 3 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1288@730)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1288@730)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1288@730)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	5222228
		lastStepMessage: 	nil
		lastCycleTime: 	5222248
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	5222228
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1288@730)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1288@730)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1288@730)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	true
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	true
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	true
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	true
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	true
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	true
		snapshotResult: 	true
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cell did not understand #grid:
17 June 2017 3:37:45.749668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Cell(Object)>>doesNotUnderstand: #grid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	grid: a Grid
		exception: 	MessageNotUnderstood: Cell>>grid:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 dept...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: 2...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form extent: 25 @ 25 depth...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@240)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(574295296) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(318203904))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	78552
		lastStepMessage: 	nil
		lastCycleTime: 	78573
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	78552
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	78552
		lastStepMessage: 	nil
		lastCycleTime: 	78573
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	78552
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	78552
		lastStepMessage: 	nil
		lastCycleTime: 	78573
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	78552
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	Transcript


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Cell(Object)>>doesNotUnderstand: #grid:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cell did not understand #grid:
17 June 2017 3:40:27.340668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Cell(Object)>>doesNotUnderstand: #grid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	grid: a Grid
		exception: 	MessageNotUnderstood: Cell>>grid:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 dept...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: 2...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form extent: 25 @ 25 depth...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@240)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(574295296) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(345754368))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	240137
		lastStepMessage: 	nil
		lastCycleTime: 	240158
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	240137
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	240137
		lastStepMessage: 	nil
		lastCycleTime: 	240158
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	240137
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	240137
		lastStepMessage: 	nil
		lastCycleTime: 	240158
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	240137
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Cell(Object)>>doesNotUnderstand: #grid:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cell did not understand #grid:
17 June 2017 3:40:46.682668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Cell(Object)>>doesNotUnderstand: #grid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	grid: a Grid
		exception: 	MessageNotUnderstood: Cell>>grid:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 dept...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: 2...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form extent: 25 @ 25 depth...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@240)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(574295296) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(595847680))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	259485
		lastStepMessage: 	nil
		lastCycleTime: 	259505
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	259485
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	259485
		lastStepMessage: 	nil
		lastCycleTime: 	259505
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	259485
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	259485
		lastStepMessage: 	nil
		lastCycleTime: 	259505
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	259485
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Cell(Object)>>doesNotUnderstand: #grid:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cell did not understand #grid:
17 June 2017 3:43:34.671668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Cell(Object)>>doesNotUnderstand: #grid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	grid: a Grid
		exception: 	MessageNotUnderstood: Cell>>grid:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 dept...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: 2...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form extent: 25 @ 25 depth...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@240)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(574295296) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(573839104))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	427482
		lastStepMessage: 	nil
		lastCycleTime: 	427502
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	427482
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	427482
		lastStepMessage: 	nil
		lastCycleTime: 	427502
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	427482
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	427482
		lastStepMessage: 	nil
		lastCycleTime: 	427502
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	427482
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Cell(Object)>>doesNotUnderstand: #grid:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cell did not understand #grid:
17 June 2017 3:43:54.296668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Cell(Object)>>doesNotUnderstand: #grid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	grid: a Grid
		exception: 	MessageNotUnderstood: Cell>>grid:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


Message>>sentTo:
	Receiver: grid: a Grid
	Arguments and temporary variables: 
		receiver: 	a Cell
	Receiver's instance variables: 
		selector: 	#grid:
		args: 	an Array(a Grid)
		lookupClass: 	Cell


Cell(Object)>>doesNotUnderstand: #grid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	grid: a Grid
		exception: 	MessageNotUnderstood: Cell>>grid:
		resumeValue: 	MessageNotUnderstood: Cell>>grid:
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 dept...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: 2...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form extent: 25 @ 25 depth...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@240)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(574295296) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (580@240)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(573839104))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	447111
		lastStepMessage: 	nil
		lastCycleTime: 	447131
		alarms: 	a Heap()
		lastAlarmTime: 	447111
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	447111
		lastStepMessage: 	nil
		lastCycleTime: 	447131
		alarms: 	a Heap()
		lastAlarmTime: 	447111
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	447111
		lastStepMessage: 	nil
		lastCycleTime: 	447131
		alarms: 	a Heap()
		lastAlarmTime: 	447111
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Cell(Object)>>doesNotUnderstand: #grid:
Message>>sentTo:
Cell(Object)>>doesNotUnderstand: #grid:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cell did not understand #grid:
17 June 2017 3:44:04.868668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Cell(Object)>>doesNotUnderstand: #grid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	grid: a Grid
		exception: 	MessageNotUnderstood: Cell>>grid:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


Message>>sentTo:
	Receiver: grid: a Grid
	Arguments and temporary variables: 
		receiver: 	a Cell
	Receiver's instance variables: 
		selector: 	#grid:
		args: 	an Array(a Grid)
		lookupClass: 	Cell


Cell(Object)>>doesNotUnderstand: #grid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	grid: a Grid
		exception: 	MessageNotUnderstood: Cell>>grid:
		resumeValue: 	MessageNotUnderstood: Cell>>grid:
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


Message>>sentTo:
	Receiver: grid: a Grid
	Arguments and temporary variables: 
		receiver: 	a Cell
	Receiver's instance variables: 
		selector: 	#grid:
		args: 	an Array(a Grid)
		lookupClass: 	Cell


Cell(Object)>>doesNotUnderstand: #grid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	grid: a Grid
		exception: 	MessageNotUnderstood: Cell>>grid:
		resumeValue: 	MessageNotUnderstood: Cell>>grid:
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 dept...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: 2...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form extent: 25 @ 25 depth...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@240)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(574295296) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (580@240)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(573839104))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	457681
		lastStepMessage: 	nil
		lastCycleTime: 	457703
		alarms: 	a Heap()
		lastAlarmTime: 	457681
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	457681
		lastStepMessage: 	nil
		lastCycleTime: 	457703
		alarms: 	a Heap()
		lastAlarmTime: 	457681
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	457681
		lastStepMessage: 	nil
		lastCycleTime: 	457703
		alarms: 	a Heap()
		lastAlarmTime: 	457681
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Cell(Object)>>doesNotUnderstand: #grid:
Message>>sentTo:
Cell(Object)>>doesNotUnderstand: #grid:
Message>>sentTo:
Cell(Object)>>doesNotUnderstand: #grid:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cell did not understand #grid:
17 June 2017 3:47:03.122668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Cell(Object)>>doesNotUnderstand: #grid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	grid: a Grid
		exception: 	MessageNotUnderstood: Cell>>grid:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


RenderTest>>testDraw
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 
		grid: 	a Grid
		form: 	Form(25x25x32)
		cellLoc: 	(1@1)
		cell: 	a Cell
		rendererClass: 	Cell
		renderer: 	a Cell
	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


RenderTest(TestCase)>>performTest
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


RenderTest(TestCase)>>runCaseManaged
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T15:47:03.086668+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testDraw)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T15:47:03.086668+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testDraw)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testDraw)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(RenderTest>>#testDraw)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(RenderTest>>#testDraw nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testDraw)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testDraw)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. DirectionTest. GridTest. RenderTest}
		classIndex: 	4
		classesSelected: 	a Set(BlankCellTest GridTest DirectionTest RenderTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(RenderTest>>#testDraw)
		errorSelected: 	RenderTest>>#testDraw
		lastUpdate: 	3675160021
		result: 	11 run, 10 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	11 run, 10 passes, 0 skipped, 0 expected failures, 0 failures, 1 err...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. DirectionTest. GridTest. RenderTest}
		classIndex: 	4
		classesSelected: 	a Set(BlankCellTest GridTest DirectionTest RenderTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(RenderTest>>#testDraw)
		errorSelected: 	RenderTest>>#testDraw
		lastUpdate: 	3675160021
		result: 	11 run, 10 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0



--- The full stack ---
Cell(Object)>>doesNotUnderstand: #grid:
RenderTest>>testDraw
RenderTest(TestCase)>>performTest
[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
BlockClosure>>ensure:
RenderTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RenderTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RenderTest(TestCase)>>debug
BlockClosure>>ensure:
RenderTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cell did not understand #grid:
17 June 2017 3:47:14.094668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Cell(Object)>>doesNotUnderstand: #grid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	grid: a Grid
		exception: 	MessageNotUnderstood: Cell>>grid:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


RenderTest>>testDraw
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 
		grid: 	a Grid
		form: 	Form(25x25x32)
		cellLoc: 	(1@1)
		cell: 	a Cell
		rendererClass: 	Cell
		renderer: 	a Cell
	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


RenderTest(TestCase)>>performTest
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


RenderTest(TestCase)>>runCaseManaged
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T15:47:14.077668+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testDraw)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T15:47:14.077668+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testDraw)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testDraw)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(RenderTest>>#testDraw)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(RenderTest>>#testDraw nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testDraw)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testDraw)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. DirectionTest. GridTest. RenderTest}
		classIndex: 	4
		classesSelected: 	a Set(BlankCellTest GridTest DirectionTest RenderTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(RenderTest>>#testDraw)
		errorSelected: 	RenderTest>>#testDraw
		lastUpdate: 	3675160021
		result: 	11 run, 10 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	11 run, 10 passes, 0 skipped, 0 expected failures, 0 failures, 1 err...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. DirectionTest. GridTest. RenderTest}
		classIndex: 	4
		classesSelected: 	a Set(BlankCellTest GridTest DirectionTest RenderTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(RenderTest>>#testDraw)
		errorSelected: 	RenderTest>>#testDraw
		lastUpdate: 	3675160021
		result: 	11 run, 10 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0



--- The full stack ---
Cell(Object)>>doesNotUnderstand: #grid:
RenderTest>>testDraw
RenderTest(TestCase)>>performTest
[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
BlockClosure>>ensure:
RenderTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RenderTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RenderTest(TestCase)>>debug
BlockClosure>>ensure:
RenderTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cell did not understand #grid:
17 June 2017 3:47:38.374668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Cell(Object)>>doesNotUnderstand: #grid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	grid: a Grid
		exception: 	MessageNotUnderstood: Cell>>grid:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


RenderTest>>testDraw
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 
		grid: 	a Grid
		form: 	Form(25x25x32)
		cellLoc: 	(1@1)
		cell: 	a Cell
		rendererClass: 	Cell
		renderer: 	a Cell
	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


RenderTest(TestCase)>>performTest
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


RenderTest(TestCase)>>runCaseManaged
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T15:47:38.358668+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testDraw)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T15:47:38.358668+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testDraw)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testDraw)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(RenderTest>>#testDraw)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(RenderTest>>#testDraw nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testDraw)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testDraw)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. DirectionTest. GridTest. RenderTest}
		classIndex: 	4
		classesSelected: 	a Set(BlankCellTest GridTest DirectionTest RenderTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(RenderTest>>#testDraw)
		errorSelected: 	RenderTest>>#testDraw
		lastUpdate: 	3675160021
		result: 	11 run, 10 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	11 run, 10 passes, 0 skipped, 0 expected failures, 0 failures, 1 err...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. DirectionTest. GridTest. RenderTest}
		classIndex: 	4
		classesSelected: 	a Set(BlankCellTest GridTest DirectionTest RenderTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(RenderTest>>#testDraw)
		errorSelected: 	RenderTest>>#testDraw
		lastUpdate: 	3675160021
		result: 	11 run, 10 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0



--- The full stack ---
Cell(Object)>>doesNotUnderstand: #grid:
RenderTest>>testDraw
RenderTest(TestCase)>>performTest
[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
BlockClosure>>ensure:
RenderTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RenderTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RenderTest(TestCase)>>debug
BlockClosure>>ensure:
RenderTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cell did not understand #cellGrid:
17 June 2017 3:49:56.872668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Cell(Object)>>doesNotUnderstand: #cellGrid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	cellGrid: a Grid
		exception: 	MessageNotUnderstood: Cell>>cellGrid:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


RenderTest>>testDraw
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 
		grid: 	a Grid
		form: 	Form(25x25x32)
		cellLoc: 	(1@1)
		cell: 	a Cell
		rendererClass: 	Cell
		renderer: 	a Cell
	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


RenderTest(TestCase)>>performTest
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


RenderTest(TestCase)>>runCaseManaged
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T15:49:56.857668+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testDraw)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T15:49:56.857668+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testDraw)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testDraw)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(RenderTest>>#testDraw)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(RenderTest>>#testDraw nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testDraw)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testDraw)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. DirectionTest. GridTest. RenderTest}
		classIndex: 	4
		classesSelected: 	a Set(BlankCellTest GridTest DirectionTest RenderTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(RenderTest>>#testDraw)
		errorSelected: 	RenderTest>>#testDraw
		lastUpdate: 	3675160195
		result: 	11 run, 10 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	11 run, 10 passes, 0 skipped, 0 expected failures, 0 failures, 1 err...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. DirectionTest. GridTest. RenderTest}
		classIndex: 	4
		classesSelected: 	a Set(BlankCellTest GridTest DirectionTest RenderTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(RenderTest>>#testDraw)
		errorSelected: 	RenderTest>>#testDraw
		lastUpdate: 	3675160195
		result: 	11 run, 10 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0



--- The full stack ---
Cell(Object)>>doesNotUnderstand: #cellGrid:
RenderTest>>testDraw
RenderTest(TestCase)>>performTest
[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
BlockClosure>>ensure:
RenderTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RenderTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RenderTest(TestCase)>>debug
BlockClosure>>ensure:
RenderTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cell did not understand #cellGrid:
17 June 2017 3:54:15.621668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Cell(Object)>>doesNotUnderstand: #cellGrid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	cellGrid: a Grid
		exception: 	MessageNotUnderstood: Cell>>cellGrid:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 dept...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: 2...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form extent: 25 @ 25 depth...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (580@240)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(574295296) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(3942400))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(33881088))(a SearchMorph...etc...
		lastStepTime: 	1068426
		lastStepMessage: 	nil
		lastCycleTime: 	1068447
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	1068426
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(33881088))(a SearchMorph...etc...
		lastStepTime: 	1068426
		lastStepMessage: 	nil
		lastCycleTime: 	1068447
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	1068426
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(33881088))(a SearchMorph...etc...
		lastStepTime: 	1068426
		lastStepMessage: 	nil
		lastCycleTime: 	1068447
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	1068426
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(950354432) a TaskbarMorph(804941056) a GLMSyste...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Cell(Object)>>doesNotUnderstand: #cellGrid:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cell did not understand #cellForm:
17 June 2017 3:58:05.000668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Cell(Object)>>doesNotUnderstand: #cellForm:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	cellForm: Form(25x25x32)
		exception: 	MessageNotUnderstood: Cell>>cellForm:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


RenderTest>>testDraw
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 
		grid: 	a Grid
		form: 	Form(25x25x32)
		cellLoc: 	(1@1)
		cell: 	a Cell
		rendererClass: 	Cell
		renderer: 	a Cell
	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


RenderTest(TestCase)>>performTest
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testDraw
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


RenderTest(TestCase)>>runCaseManaged
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T15:58:04.983668+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testDraw)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		timeStamp: 	2017-06-17T15:58:04.983668+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testDraw)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testDraw
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testDraw
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	RenderTest>>#testDraw
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testDraw)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(RenderTest>>#testDraw)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(RenderTest>>#testDraw nil nil nil nil nil nil nil nil nil)
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testDraw)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testDraw)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. DirectionTest. GridTest. RenderTest}
		classIndex: 	4
		classesSelected: 	a Set(BlankCellTest GridTest DirectionTest RenderTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(RenderTest>>#testDraw)
		errorSelected: 	RenderTest>>#testDraw
		lastUpdate: 	3675160683
		result: 	11 run, 10 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	11 run, 10 passes, 0 skipped, 0 expected failures, 0 failures, 1 err...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aBlock: 	[ :aSuite | aSuite debug ]
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. DirectionTest. GridTest. RenderTest}
		classIndex: 	4
		classesSelected: 	a Set(BlankCellTest GridTest DirectionTest RenderTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(RenderTest>>#testDraw)
		errorSelected: 	RenderTest>>#testDraw
		lastUpdate: 	3675160683
		result: 	11 run, 10 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0



--- The full stack ---
Cell(Object)>>doesNotUnderstand: #cellForm:
RenderTest>>testDraw
RenderTest(TestCase)>>performTest
[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
BlockClosure>>ensure:
RenderTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RenderTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RenderTest(TestCase)>>debug
BlockClosure>>ensure:
RenderTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

17 June 2017 4:02:10.716668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a GLMRubricSmalltalkTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a GLMRubricSmalltalkTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	4
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	4
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (635@202)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(574295296) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (635@202)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (635@202)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(574295296) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (635@202)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (635@202)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(574295296) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (635@202)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (635@202)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(574295296) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (635@202)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(710488064)
	Receiver's instance variables: 
		bounds: 	(862@397) corner: (878@413)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(862@397) mouseOver 7717634 nil]
		targetOffset: 	(236.0@138.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7717634 862 397 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(862@397) corner: (878@413)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(862@397) mouseOver 7717634 nil]
		targetOffset: 	(236.0@138.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7717634 862 397 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	1543023
		lastStepMessage: 	nil
		lastCycleTime: 	1543044
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	1543023
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Debug
17 June 2017 4:05:52.101668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

[ self schedule.
"It is critical that the following has no suspension point so that
	the test and the wait primitive are atomic. In addition, if the delay
	is no longer being waited on while entering the way we know that it 
	is expired because the delay has already fired."
beingWaitedOn
	ifTrue: [ delaySemaphore wait ]
	ifFalse: [ expired := true ] ] in DelayWaitTimeout>>wait
	Receiver: a DelayWaitTimeout(30000 msecs)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		delaySemaphore: 	a Semaphore()
		beingWaitedOn: 	false
		millisecondDelayDuration: 	30000
		scheduler: 	a DelaySpinScheduler
		schedulerResumptionTime: 	3675161182059668
		process: 	a Process in DelaySpinScheduler>>unschedule:
		expired: 	false



--- The full stack ---
[ self schedule.
"It is critical that the following has no suspension point so that
	the test and the wait primitive are atomic. In addition, if the delay
	is no longer being waited on while entering the way we know that it 
	is expired because the delay has already fired."
beingWaitedOn
	ifTrue: [ delaySemaphore wait ]
	ifFalse: [ expired := true ] ] in DelayWaitTimeout>>wait
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

17 June 2017 4:06:02.680668 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a GLMRubricSmalltalkTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a GLMRubricSmalltalkTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	4
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	4
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (635@221)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(574295296) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (635@221)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (635@221)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(574295296) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (635@221)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (635@221)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(574295296) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (635@221)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (635@221)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(574295296) a RubCursor(100333286...etc...
		fullBounds: 	(0@0) corner: (635@221)
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(710488064)
	Receiver's instance variables: 
		bounds: 	(823@597) corner: (839@613)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@597) mouseOver SHIFT CTRL 7951292 nil]
		targetOffset: 	(340.0@515.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7951292 828 602 0 3 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(823@597) corner: (839@613)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	nil
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(823@597) mouseOver SHIFT CTRL 7951292 nil]
		targetOffset: 	(340.0@515.0)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7951292 828 602 0 3 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	1774730
		lastStepMessage: 	nil
		lastCycleTime: 	1774751
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	1774730
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-17T15:36:27.192668+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Point did not understand #@
18 June 2017 2:35:17.47111 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Point(Object)>>doesNotUnderstand: #@
	Receiver: (0@0)
	Arguments and temporary variables: 
		aMessage: 	@ (0@0)
		exception: 	MessageNotUnderstood: Point>>@
		resumeValue: 	nil
	Receiver's instance variables: 
		x: 	0
		y: 	0


CellRenderer>>gridFormOffset
	Receiver: a CellRenderer
	Arguments and temporary variables: 
		diff: 	(25@25)
		countX: 	0
		countY: 	0
		offset: 	nil
	Receiver's instance variables: 
		position: 	(1@1)
		cellGrid: 	a Grid
		cellForm: 	Form(750x750x32)


RenderTest>>testCellOffsets
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 
		grid: 	a Grid
		form: 	Form(750x750x32)
		cellLoc: 	(1@1)
		renderer: 	a CellRenderer
		offset: 	nil
	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


RenderTest(TestCase)>>performTest
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


RenderTest(TestCase)>>runCaseManaged
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		timeStamp: 	2017-06-18T14:35:17.42911+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testCellOffsets)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		timeStamp: 	2017-06-18T14:35:17.42911+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testCellOffsets)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testCellOffsets)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(RenderTest>>#testCellOffsets)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(RenderTest>>#testCellOffsets nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testCellOffsets)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testCellOffsets)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. DirectionTest. GridTest. RenderTest}
		classIndex: 	0
		classesSelected: 	a Set(BlankCellTest GridTest DirectionTest RenderTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(RenderTest>>#testCellOffsets)
		errorSelected: 	RenderTest>>#testCellOffsets
		lastUpdate: 	3675242101
		result: 	12 run, 11 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	12 run, 11 passes, 0 skipped, 0 expected failures, 0 failures, 1 err...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
Point(Object)>>doesNotUnderstand: #@
CellRenderer>>gridFormOffset
RenderTest>>testCellOffsets
RenderTest(TestCase)>>performTest
[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
BlockClosure>>ensure:
RenderTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.THERE_BE_DRAGONS_HERE
Instance of Point did not understand #@
18 June 2017 2:35:30.33111 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Point(Object)>>doesNotUnderstand: #@
	Receiver: (0@0)
	Arguments and temporary variables: 
		aMessage: 	@ (0@0)
		exception: 	MessageNotUnderstood: Point>>@
		resumeValue: 	nil
	Receiver's instance variables: 
		x: 	0
		y: 	0


CellRenderer>>gridFormOffset
	Receiver: a CellRenderer
	Arguments and temporary variables: 
		diff: 	(25@25)
		countX: 	0
		countY: 	0
		offset: 	nil
	Receiver's instance variables: 
		position: 	(1@1)
		cellGrid: 	a Grid
		cellForm: 	Form(750x750x32)


RenderTest>>testCellOffsets
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 
		grid: 	a Grid
		form: 	Form(750x750x32)
		cellLoc: 	(1@1)
		renderer: 	a CellRenderer
		offset: 	nil
	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


RenderTest(TestCase)>>performTest
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


RenderTest(TestCase)>>runCaseManaged
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		timeStamp: 	2017-06-18T14:35:30.31411+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testCellOffsets)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		timeStamp: 	2017-06-18T14:35:30.31411+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testCellOffsets)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testCellOffsets)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(RenderTest>>#testCellOffsets)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(RenderTest>>#testCellOffsets nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testCellOffsets)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testCellOffsets)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. DirectionTest. GridTest. RenderTest}
		classIndex: 	0
		classesSelected: 	a Set(BlankCellTest GridTest DirectionTest RenderTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(RenderTest>>#testCellOffsets)
		errorSelected: 	RenderTest>>#testCellOffsets
		lastUpdate: 	3675242101
		result: 	12 run, 11 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	12 run, 11 passes, 0 skipped, 0 expected failures, 0 failures, 1 err...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
Point(Object)>>doesNotUnderstand: #@
CellRenderer>>gridFormOffset
RenderTest>>testCellOffsets
RenderTest(TestCase)>>performTest
[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
BlockClosure>>ensure:
RenderTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
THERE_BE_DRAGONS_HERE
Instance of Point did not understand #@
18 June 2017 2:35:54.43911 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Point(Object)>>doesNotUnderstand: #@
	Receiver: (0@0)
	Arguments and temporary variables: 
		aMessage: 	@ (0@0)
		exception: 	MessageNotUnderstood: Point>>@
		resumeValue: 	nil
	Receiver's instance variables: 
		x: 	0
		y: 	0


CellRenderer>>gridFormOffset
	Receiver: a CellRenderer
	Arguments and temporary variables: 
		diff: 	(25@25)
		countX: 	0
		countY: 	0
		offset: 	nil
	Receiver's instance variables: 
		position: 	(1@1)
		cellGrid: 	a Grid
		cellForm: 	Form(750x750x32)


RenderTest>>testCellOffsets
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 
		grid: 	a Grid
		form: 	Form(750x750x32)
		cellLoc: 	(1@1)
		renderer: 	a CellRenderer
		offset: 	nil
	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


RenderTest(TestCase)>>performTest
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ self setUp.
self performTest ]
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown.
self cleanUpInstanceVariables ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>runCase
		startpc: 	57
		numArgs: 	0


RenderTest(TestCase)>>runCase
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ aTestCase runCase ]
	Arguments and temporary variables: 
		exception: 	Halt
		handlerAction: 	[ :halt | 
"if test was halted we should resume all background f...etc...
	Receiver's instance variables: 
		outerContext: 	[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was ...etc...
		startpc: 	63
		numArgs: 	0


[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>on:do:
	Receiver: [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume a...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :err | 
"error here means that test is failed. So we should ch...etc...
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCaseSafelly:
		startpc: 	58
		numArgs: 	0


TestExecutionEnvironment>>runTestCaseSafelly:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ensure:
	Receiver: [ self runTestCaseSafelly: aTestCase ]
	Arguments and temporary variables: 
		aBlock: 	[ testCompleted := true.
watchDogSemaphore signal ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted...etc...
		startpc: 	61
		numArgs: 	0


[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


BlockClosure>>ifCurtailed:
	Receiver: [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemap...etc...
	Arguments and temporary variables: 
		aBlock: 	[ forkedProcesses removeAll.
failedProcesses removeAll ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	TestExecutionEnvironment>>runTestCase:
		startpc: 	56
		numArgs: 	0


TestExecutionEnvironment>>runTestCase:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


BlockClosure>>ensure:
	Receiver: [ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ]
	Arguments and temporary variables: 
		aBlock: 	[ self value: current.
anExecutionEnvironment deactivated ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	CurrentExecutionEnvironment class>>activate:for:
		startpc: 	55
		numArgs: 	0


CurrentExecutionEnvironment class>>activate:for:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		anExecutionEnvironment: 	a TestExecutionEnvironment
		aBlock: 	[ testEnv runTestCase: aTestCase ]
		current: 	a DefaultExecutionEnvironment
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
	Receiver: a TestExecutionEnvironment
	Arguments and temporary variables: 
		aBlock: 	[ testEnv runTestCase: aTestCase ]
	Receiver's instance variables: 
		watchDogProcess: 	a Process in [ self schedule.
"It is critical that the followi...etc...
		watchDogSemaphore: 	a Semaphore(a Process in [ self schedule.
"It is critical th...etc...
		testCase: 	RenderTest>>#testCellOffsets
		maxTimeForTest: 	0:00:01:00
		forkedProcesses: 	a WeakSet(a Process in [ delaySemaphore wait ] in Delay>>wait)...etc...
		failedProcesses: 	an OrderedIdentityDictionary()
		testCompleted: 	false


DefaultExecutionEnvironment>>runTestCase:
	Receiver: a DefaultExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
		testEnv: 	a TestExecutionEnvironment
	Receiver's instance variables: 
a DefaultExecutionEnvironment

CurrentExecutionEnvironment class>>runTestCase:
	Receiver: CurrentExecutionEnvironment
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		superclass: 	ProcessLocalVariable
		methodDict: 	a MethodDictionary(#default->CurrentExecutionEnvironment>>#default ...etc...
		format: 	65537
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#CurrentExecutionEnvironment
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Kernel-Processes'
		traitComposition: 	{}
		localSelectors: 	nil
		soleInstance: 	a CurrentExecutionEnvironment


RenderTest(TestCase)>>runCaseManaged
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 

	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		timeStamp: 	2017-06-18T14:35:54.42311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testCellOffsets)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


BlockClosure>>on:do:
	Receiver: [ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCas...etc...
	Arguments and temporary variables: 
		exception: 	an ExceptionSet
		handlerAction: 	[ :ex | 
ex sunitAnnounce: aTestCase toResult: self.
ex pass ]
	Receiver's instance variables: 
		outerContext: 	TestResult>>runCaseForDebug:
		startpc: 	74
		numArgs: 	0


TestResult>>runCaseForDebug:
	Receiver: 1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, 0 unexpected passes...etc...
	Arguments and temporary variables: 
		aTestCase: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		timeStamp: 	2017-06-18T14:35:54.42311+02:00
		failures: 	a Set()
		errors: 	an OrderedCollection(RenderTest>>#testCellOffsets)
		passed: 	an OrderedCollection()
		skipped: 	an OrderedCollection()


[ result runCaseForDebug: self ] in RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


BlockClosure>>ensure:
	Receiver: [ result runCaseForDebug: self ]
	Arguments and temporary variables: 
		aBlock: 	[ self classForTestResource resetResources: self resources.
result upda...etc...
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	RenderTest(TestCase)>>debug
		startpc: 	50
		numArgs: 	0


RenderTest(TestCase)>>debug
	Receiver: RenderTest>>#testCellOffsets
	Arguments and temporary variables: 
		result: 	1 run, 0 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors, ...etc...
	Receiver's instance variables: 
		testSelector: 	#testCellOffsets
		expectedFails: 	#()


[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 
		each: 	RenderTest>>#testCellOffsets
	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testCellOffsets)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


OrderedCollection>>do:
	Receiver: an OrderedCollection(RenderTest>>#testCellOffsets)
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
each debug.
self announceTest: each.
self changed: each ]
		index: 	1
	Receiver's instance variables: 
		array: 	an Array(RenderTest>>#testCellOffsets nil nil nil nil nil nil nil nil ni...etc...
		firstIndex: 	1
		lastIndex: 	1


[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testCellOffsets)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


BlockClosure>>ensure:
	Receiver: [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each...etc...
	Arguments and temporary variables: 
		aBlock: 	[ self tearDown ]
		complete: 	nil
		returnValue: 	nil
	Receiver's instance variables: 
		outerContext: 	TestSuite>>debug
		startpc: 	48
		numArgs: 	0


TestSuite>>debug
	Receiver: a TestSuite
	Arguments and temporary variables: 

	Receiver's instance variables: 
		dependents: 	nil
		announceur: 	nil
		tests: 	an OrderedCollection(RenderTest>>#testCellOffsets)
		resources: 	an OrderedCollection()
		name: 	nil
		announcer: 	an Announcer


[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
	Receiver: a TestRunner
	Arguments and temporary variables: 
		aTestSuite: 	a TestSuite
		aSuite: 	a TestSuite
	Receiver's instance variables: 
		dependents: 	a DependentsArray(a SystemWindow(66267136) a SearchMorph(206166272)...etc...
		announceur: 	nil
		classes: 	{BlankCellTest. DirectionTest. GridTest. RenderTest}
		classIndex: 	0
		classesSelected: 	a Set(BlankCellTest GridTest DirectionTest RenderTest)
		failedList: 	#()
		failedSelected: 	nil
		errorList: 	an Array(RenderTest>>#testCellOffsets)
		errorSelected: 	RenderTest>>#testCellOffsets
		lastUpdate: 	3675242152
		result: 	12 run, 11 passes, 0 skipped, 0 expected failures, 0 failures, 1 errors...etc...
		previousRun: 	nil
		classPattern: 	nil
		testAnnouncementBlock: 	[ :announcement | self updateStatus: true ]
		packages: 	#(#Snake_Game_Test)
		packagesSelected: 	a Set(#Snake_Game_Test)
		packagePattern: 	a RxMatcher
		packageIndex: 	0


BlockClosure>>cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		anArg: 	a TestSuite
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1


BlockClosure>>cull:cull:
	Receiver: [ :aSuite | aSuite debug ]
	Arguments and temporary variables: 
		firstArg: 	a TestSuite
		secondArg: 	12 run, 11 passes, 0 skipped, 0 expected failures, 0 failures, 1 err...etc...
	Receiver's instance variables: 
		outerContext: 	TestRunner>>debugSuite:
		startpc: 	27
		numArgs: 	1



--- The full stack ---
Point(Object)>>doesNotUnderstand: #@
CellRenderer>>gridFormOffset
RenderTest>>testCellOffsets
RenderTest(TestCase)>>performTest
[ self setUp.
self performTest ] in RenderTest(TestCase)>>runCase
BlockClosure>>ensure:
RenderTest(TestCase)>>runCase
[ aTestCase runCase ] in [ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
[ [ aTestCase runCase ]
	on: Halt
	do: [ :halt | 
		"if test was halted we should resume all background failures 
			to debug all of them together with test process"
		failedProcesses keysDo: #resume.
		halt pass ] ] in TestExecutionEnvironment>>runTestCaseSafelly:
BlockClosure>>on:do:
TestExecutionEnvironment>>runTestCaseSafelly:
[ self runTestCaseSafelly: aTestCase ] in [ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ensure:
[ [ self runTestCaseSafelly: aTestCase ]
	ensure: [ testCompleted := true.
		watchDogSemaphore signal ].	"signal that test case completes"
self checkForkedProcesses ] in TestExecutionEnvironment>>runTestCase:
BlockClosure>>ifCurtailed:
TestExecutionEnvironment>>runTestCase:
[ testEnv runTestCase: aTestCase ] in DefaultExecutionEnvironment>>runTestCase:
[ self value: anExecutionEnvironment.
anExecutionEnvironment activated.
aBlock value ] in CurrentExecutionEnvironment class>>activate:for:
BlockClosure>>ensure:
CurrentExecutionEnvironment class>>activate:for:
TestExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment>>runTestCase:
CurrentExecutionEnvironment class>>runTestCase:
RenderTest(TestCase)>>runCaseManaged
[ aTestCase announce: TestCaseStarted withResult: self.
aTestCase runCaseManaged.
aTestCase announce: TestCaseEnded withResult: self.
self addPass: aTestCase ] in TestResult>>runCaseForDebug:
BlockClosure>>on:do:
TestResult>>runCaseForDebug:
[ result runCaseForDebug: self ] in RenderTest(TestCase)>>debug
BlockClosure>>ensure:
RenderTest(TestCase)>>debug
[ :each | 
each debug.
self announceTest: each.
self changed: each ] in [ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
OrderedCollection>>do:
[ self tests
	do: [ :each | 
		each debug.
		self announceTest: each.
		self changed: each ] ] in TestSuite>>debug
BlockClosure>>ensure:
TestSuite>>debug
[ :aSuite | aSuite debug ] in TestRunner>>debugSuite:
BlockClosure>>cull:
BlockClosure>>cull:cull:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ aBlock cull: aTestSuite cull: result ] in TestRunner>>executeSuite:as:
BlockClosure>>ensure:
TestRunner>>executeSuite:as:
TestRunner>>debugSuite:
TestRunner>>debug:
TestRunner>>errorSelected:
PluggableListMorph>>changeModelSelection:
PluggableListMorph>>mouseUpOnSingle:
PluggableListMorph>>mouseUp:
PluggableListMorph(Morph)>>handleMouseUp:
MouseButtonEvent>>sentTo:
PluggableListMorph(Morph)>>handleEvent:
MorphicEventDispatcher>>dispatchDefault:with:
MorphicEventDispatcher>>handleMouseUp:
MouseButtonEvent>>sentTo:
[ ^ anEvent sentTo: self ] in MorphicEventDispatcher>>dispatchEvent:with:
BlockClosure>>ensure:
MorphicEventDispatcher>>dispatchEvent:with:
PluggableListMorph(Morph)>>processEvent:using:
PluggableListMorph(Morph)>>processEvent:
PluggableListMorph>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendMouseEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #x
18 June 2017 2:57:08.75711 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

SmallInteger(Object)>>doesNotUnderstand: #x
	Receiver: 0
	Arguments and temporary variables: 
		aMessage: 	x
		exception: 	MessageNotUnderstood: SmallInteger>>x
		resumeValue: 	nil
	Receiver's instance variables: 
0

Point>><
	Receiver: (12@12)
	Arguments and temporary variables: 
		aPoint: 	0
	Receiver's instance variables: 
		x: 	12
		y: 	12


GrafPort(BitBlt)>>drawLoopX:Y:
	Receiver: a GrafPort
	Arguments and temporary variables: 
		xDelta: 	0
		yDelta: 	(25@25)
		dx: 	0
		dy: 	(1@1)
		px: 	(25@25)
		py: 	0
		P: 	(12@12)
		i: 	1
	Receiver's instance variables: 
		destForm: 	Form(750x750x32)
		sourceForm: 	nil
		halftoneForm: 	a Bitmap of length 1
		combinationRule: 	3
		destX: 	0
		destY: 	(1@1)
		width: 	1
		height: 	1
		sourceX: 	nil
		sourceY: 	nil
		clipX: 	0
		clipY: 	0
		clipWidth: 	750
		clipHeight: 	750
		colorMap: 	nil
		alpha: 	nil
		fillPattern: 	Color white
		lastFont: 	nil
		lastFontForegroundColor: 	nil
		lastFontBackgroundColor: 	nil


GrafPort(BitBlt)>>drawFrom:to:withFirstPoint:
	Receiver: a GrafPort
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		destForm: 	Form(750x750x32)
		sourceForm: 	nil
		halftoneForm: 	a Bitmap of length 1
		combinationRule: 	3
		destX: 	0
		destY: 	(1@1)
		width: 	1
		height: 	1
		sourceX: 	nil
		sourceY: 	nil
		clipX: 	0
		clipY: 	0
		clipWidth: 	750
		clipHeight: 	750
		colorMap: 	nil
		alpha: 	nil
		fillPattern: 	Color white
		lastFont: 	nil
		lastFontForegroundColor: 	nil
		lastFontBackgroundColor: 	nil


GrafPort(BitBlt)>>drawFrom:to:
	Receiver: a GrafPort
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		destForm: 	Form(750x750x32)
		sourceForm: 	nil
		halftoneForm: 	a Bitmap of length 1
		combinationRule: 	3
		destX: 	0
		destY: 	(1@1)
		width: 	1
		height: 	1
		sourceX: 	nil
		sourceY: 	nil
		clipX: 	0
		clipY: 	0
		clipWidth: 	750
		clipHeight: 	750
		colorMap: 	nil
		alpha: 	nil
		fillPattern: 	Color white
		lastFont: 	nil
		lastFontForegroundColor: 	nil
		lastFontBackgroundColor: 	nil


FormCanvas>>line:to:width:color:
	Receiver: a FormCanvas on: Form(750x750x32)
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		origin: 	(0@0)
		clipRect: 	(0@0) corner: (10000@10000)
		form: 	Form(750x750x32)
		port: 	a GrafPort


CellRenderer>>renderLeftBorder
	Receiver: a CellRenderer
	Arguments and temporary variables: 
		diff: 	(25@25)
		offset: 	(0@0)
		x1: 	0
		y1: 	0
		x2: 	0
		y2: 	(25@25)
	Receiver's instance variables: 
		position: 	(1@1)
		cellGrid: 	a Grid
		cellForm: 	Form(750x750x32)


CellRenderer>>renderBorder
	Receiver: a CellRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		position: 	(1@1)
		cellGrid: 	a Grid
		cellForm: 	Form(750x750x32)


CellRenderer>>render
	Receiver: a CellRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		position: 	(1@1)
		cellGrid: 	a Grid
		cellForm: 	Form(750x750x32)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: (SnakeGame...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: (...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: (Snake...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form
		extent: (SnakeGame ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (653@164)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(811626240) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(924622080))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	2170083
		lastStepMessage: 	nil
		lastCycleTime: 	2170104
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	2170083
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	2170083
		lastStepMessage: 	nil
		lastCycleTime: 	2170104
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	2170083
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	2170083
		lastStepMessage: 	nil
		lastCycleTime: 	2170104
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	2170083
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #x
Point>><
GrafPort(BitBlt)>>drawLoopX:Y:
GrafPort(BitBlt)>>drawFrom:to:withFirstPoint:
GrafPort(BitBlt)>>drawFrom:to:
FormCanvas>>line:to:width:color:
CellRenderer>>renderLeftBorder
CellRenderer>>renderBorder
CellRenderer>>render
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #x
18 June 2017 2:59:20.24111 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

SmallInteger(Object)>>doesNotUnderstand: #x
	Receiver: 0
	Arguments and temporary variables: 
		aMessage: 	x
		exception: 	MessageNotUnderstood: SmallInteger>>x
		resumeValue: 	nil
	Receiver's instance variables: 
0

Point>><
	Receiver: (12@12)
	Arguments and temporary variables: 
		aPoint: 	0
	Receiver's instance variables: 
		x: 	12
		y: 	12


GrafPort(BitBlt)>>drawLoopX:Y:
	Receiver: a GrafPort
	Arguments and temporary variables: 
		xDelta: 	0
		yDelta: 	(25@25)
		dx: 	0
		dy: 	(1@1)
		px: 	(25@25)
		py: 	0
		P: 	(12@12)
		i: 	1
	Receiver's instance variables: 
		destForm: 	Form(750x750x32)
		sourceForm: 	nil
		halftoneForm: 	a Bitmap of length 1
		combinationRule: 	3
		destX: 	0
		destY: 	(1@1)
		width: 	1
		height: 	1
		sourceX: 	nil
		sourceY: 	nil
		clipX: 	0
		clipY: 	0
		clipWidth: 	750
		clipHeight: 	750
		colorMap: 	nil
		alpha: 	nil
		fillPattern: 	Color white
		lastFont: 	nil
		lastFontForegroundColor: 	nil
		lastFontBackgroundColor: 	nil


GrafPort(BitBlt)>>drawFrom:to:withFirstPoint:
	Receiver: a GrafPort
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		destForm: 	Form(750x750x32)
		sourceForm: 	nil
		halftoneForm: 	a Bitmap of length 1
		combinationRule: 	3
		destX: 	0
		destY: 	(1@1)
		width: 	1
		height: 	1
		sourceX: 	nil
		sourceY: 	nil
		clipX: 	0
		clipY: 	0
		clipWidth: 	750
		clipHeight: 	750
		colorMap: 	nil
		alpha: 	nil
		fillPattern: 	Color white
		lastFont: 	nil
		lastFontForegroundColor: 	nil
		lastFontBackgroundColor: 	nil


GrafPort(BitBlt)>>drawFrom:to:
	Receiver: a GrafPort
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		destForm: 	Form(750x750x32)
		sourceForm: 	nil
		halftoneForm: 	a Bitmap of length 1
		combinationRule: 	3
		destX: 	0
		destY: 	(1@1)
		width: 	1
		height: 	1
		sourceX: 	nil
		sourceY: 	nil
		clipX: 	0
		clipY: 	0
		clipWidth: 	750
		clipHeight: 	750
		colorMap: 	nil
		alpha: 	nil
		fillPattern: 	Color white
		lastFont: 	nil
		lastFontForegroundColor: 	nil
		lastFontBackgroundColor: 	nil


FormCanvas>>line:to:width:color:
	Receiver: a FormCanvas on: Form(750x750x32)
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		origin: 	(0@0)
		clipRect: 	(0@0) corner: (10000@10000)
		form: 	Form(750x750x32)
		port: 	a GrafPort


CellRenderer>>renderLeftBorder
	Receiver: a CellRenderer
	Arguments and temporary variables: 
		diff: 	(25@25)
		offset: 	(0@0)
		x1: 	0
		y1: 	0
		x2: 	0
		y2: 	(25@25)
	Receiver's instance variables: 
		position: 	(1@1)
		cellGrid: 	a Grid
		cellForm: 	Form(750x750x32)


CellRenderer>>renderBorder
	Receiver: a CellRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		position: 	(1@1)
		cellGrid: 	a Grid
		cellForm: 	Form(750x750x32)


CellRenderer>>render
	Receiver: a CellRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		position: 	(1@1)
		cellGrid: 	a Grid
		cellForm: 	Form(750x750x32)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: (SnakeGame...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: (...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: (Snake...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form
		extent: (SnakeGame ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (653@164)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(811626240) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(28608512))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	2301571
		lastStepMessage: 	nil
		lastCycleTime: 	2301592
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	2301571
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	2301571
		lastStepMessage: 	nil
		lastCycleTime: 	2301592
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	2301571
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	2301571
		lastStepMessage: 	nil
		lastCycleTime: 	2301592
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	2301571
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #x
Point>><
GrafPort(BitBlt)>>drawLoopX:Y:
GrafPort(BitBlt)>>drawFrom:to:withFirstPoint:
GrafPort(BitBlt)>>drawFrom:to:
FormCanvas>>line:to:width:color:
CellRenderer>>renderLeftBorder
CellRenderer>>renderBorder
CellRenderer>>render
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SmallInteger did not understand #x
18 June 2017 3:02:45.60111 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

SmallInteger(Object)>>doesNotUnderstand: #x
	Receiver: 0
	Arguments and temporary variables: 
		aMessage: 	x
		exception: 	MessageNotUnderstood: SmallInteger>>x
		resumeValue: 	nil
	Receiver's instance variables: 
0

Point>><
	Receiver: (12@12)
	Arguments and temporary variables: 
		aPoint: 	0
	Receiver's instance variables: 
		x: 	12
		y: 	12


GrafPort(BitBlt)>>drawLoopX:Y:
	Receiver: a GrafPort
	Arguments and temporary variables: 
		xDelta: 	0
		yDelta: 	(25@25)
		dx: 	0
		dy: 	(1@1)
		px: 	(25@25)
		py: 	0
		P: 	(12@12)
		i: 	1
	Receiver's instance variables: 
		destForm: 	Form(750x750x32)
		sourceForm: 	nil
		halftoneForm: 	a Bitmap of length 1
		combinationRule: 	3
		destX: 	0
		destY: 	(1@1)
		width: 	1
		height: 	1
		sourceX: 	nil
		sourceY: 	nil
		clipX: 	0
		clipY: 	0
		clipWidth: 	750
		clipHeight: 	750
		colorMap: 	nil
		alpha: 	nil
		fillPattern: 	Color white
		lastFont: 	nil
		lastFontForegroundColor: 	nil
		lastFontBackgroundColor: 	nil


GrafPort(BitBlt)>>drawFrom:to:withFirstPoint:
	Receiver: a GrafPort
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		destForm: 	Form(750x750x32)
		sourceForm: 	nil
		halftoneForm: 	a Bitmap of length 1
		combinationRule: 	3
		destX: 	0
		destY: 	(1@1)
		width: 	1
		height: 	1
		sourceX: 	nil
		sourceY: 	nil
		clipX: 	0
		clipY: 	0
		clipWidth: 	750
		clipHeight: 	750
		colorMap: 	nil
		alpha: 	nil
		fillPattern: 	Color white
		lastFont: 	nil
		lastFontForegroundColor: 	nil
		lastFontBackgroundColor: 	nil


GrafPort(BitBlt)>>drawFrom:to:
	Receiver: a GrafPort
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		destForm: 	Form(750x750x32)
		sourceForm: 	nil
		halftoneForm: 	a Bitmap of length 1
		combinationRule: 	3
		destX: 	0
		destY: 	(1@1)
		width: 	1
		height: 	1
		sourceX: 	nil
		sourceY: 	nil
		clipX: 	0
		clipY: 	0
		clipWidth: 	750
		clipHeight: 	750
		colorMap: 	nil
		alpha: 	nil
		fillPattern: 	Color white
		lastFont: 	nil
		lastFontForegroundColor: 	nil
		lastFontBackgroundColor: 	nil


FormCanvas>>line:to:width:color:
	Receiver: a FormCanvas on: Form(750x750x32)
	Arguments and temporary variables: 
<<error during printing>
	Receiver's instance variables: 
		origin: 	(0@0)
		clipRect: 	(0@0) corner: (10000@10000)
		form: 	Form(750x750x32)
		port: 	a GrafPort


CellRenderer>>renderLeftBorder
	Receiver: a CellRenderer
	Arguments and temporary variables: 
		diff: 	(25@25)
		offset: 	(0@0)
		x1: 	0
		y1: 	0
		x2: 	0
		y2: 	(25@25)
	Receiver's instance variables: 
		position: 	(1@1)
		cellGrid: 	a Grid
		cellForm: 	Form(750x750x32)


CellRenderer>>renderBorder
	Receiver: a CellRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		position: 	(1@1)
		cellGrid: 	a Grid
		cellForm: 	Form(750x750x32)


CellRenderer>>render
	Receiver: a CellRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		position: 	(1@1)
		cellGrid: 	a Grid
		cellForm: 	Form(750x750x32)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: (SnakeGame...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: (...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: (Snake...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form
		extent: (SnakeGame ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (653@164)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(811626240) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(900944896))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	2506929
		lastStepMessage: 	nil
		lastCycleTime: 	2506951
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	2506929
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	2506929
		lastStepMessage: 	nil
		lastCycleTime: 	2506951
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	2506929
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	2506929
		lastStepMessage: 	nil
		lastCycleTime: 	2506951
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	2506929
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
SmallInteger(Object)>>doesNotUnderstand: #x
Point>><
GrafPort(BitBlt)>>drawLoopX:Y:
GrafPort(BitBlt)>>drawFrom:to:withFirstPoint:
GrafPort(BitBlt)>>drawFrom:to:
FormCanvas>>line:to:width:color:
CellRenderer>>renderLeftBorder
CellRenderer>>renderBorder
CellRenderer>>render
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of LineMorph did not understand #displayOn:
18 June 2017 3:12:32.87511 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

LineMorph(Object)>>doesNotUnderstand: #displayOn:
	Receiver: a LineMorph(56698368)
	Arguments and temporary variables: 
		aMessage: 	displayOn: Form(750x750x32)
		exception: 	MessageNotUnderstood: LineMorph>>displayOn:
		resumeValue: 	nil
	Receiver's instance variables: 
		bounds: 	(-1@ -1) corner: (1@1)
		owner: 	nil
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color black
		extension: 	a MorphExtension (524506624)
		borderWidth: 	1
		borderColor: 	Color white
		vertices: 	{(0@0). (0@0)}
		closed: 	false
		filledForm: 	nil
		arrows: 	#none
		arrowForms: 	#()
		smoothCurve: 	false
		curveState: 	nil
		borderDashSpec: 	nil
		handles: 	nil
		borderForm: 	nil


CellRenderer>>renderTopBorder
	Receiver: a CellRenderer
	Arguments and temporary variables: 
		line: 	a LineMorph(56698368)
		diff: 	(25@25)
		offset: 	(0@0)
		x1: 	0
		y1: 	0
		x2: 	25
		y2: 	0
	Receiver's instance variables: 
		position: 	(1@1)
		cellGrid: 	a Grid
		cellForm: 	Form(750x750x32)


CellRenderer>>renderBorder
	Receiver: a CellRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		position: 	(1@1)
		cellGrid: 	a Grid
		cellForm: 	Form(750x750x32)


CellRenderer>>render
	Receiver: a CellRenderer
	Arguments and temporary variables: 

	Receiver's instance variables: 
		position: 	(1@1)
		cellGrid: 	a Grid
		cellForm: 	Form(750x750x32)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: (SnakeGame...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: (...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: (Snake...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form
		extent: (SnakeGame ...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (653@164)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(811626240) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(113597184))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	3094205
		lastStepMessage: 	nil
		lastCycleTime: 	3094227
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	3094205
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	3094205
		lastStepMessage: 	nil
		lastCycleTime: 	3094227
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	3094205
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a DropListMorph(172104448))(a DropList...etc...
		lastStepTime: 	3094205
		lastStepMessage: 	nil
		lastCycleTime: 	3094227
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	3094205
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
LineMorph(Object)>>doesNotUnderstand: #displayOn:
CellRenderer>>renderTopBorder
CellRenderer>>renderBorder
CellRenderer>>render
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SnakeGame class did not understand #area
18 June 2017 3:29:48.05511 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

SnakeGame class(Object)>>doesNotUnderstand: #area
	Receiver: SnakeGame
	Arguments and temporary variables: 
		aMessage: 	area
		exception: 	MessageNotUnderstood: SnakeGame class>>area
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Morph
		methodDict: 	a MethodDictionary(#area->SnakeGame>>#area #clear->SnakeGame>>#clea...etc...
		format: 	65544
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SnakeGame
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Snake_Game_Graphics
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
canvas := SnakeGame area.

"for...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
canvas := SnakeGame ar...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
canvas := SnakeGame area.

...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (653@183)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(811626240) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(168426240))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a LineMorph(411681536))(a LineMorph(41...etc...
		lastStepTime: 	4129389
		lastStepMessage: 	nil
		lastCycleTime: 	4129410
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	4129389
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a LineMorph(411681536))(a LineMorph(41...etc...
		lastStepTime: 	4129389
		lastStepMessage: 	nil
		lastCycleTime: 	4129410
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	4129389
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a LineMorph(411681536))(a LineMorph(41...etc...
		lastStepTime: 	4129389
		lastStepMessage: 	nil
		lastCycleTime: 	4129410
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	4129389
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
SnakeGame class(Object)>>doesNotUnderstand: #area
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of SnakeGame class did not understand #area
18 June 2017 3:29:55.65411 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

SnakeGame class(Object)>>doesNotUnderstand: #area
	Receiver: SnakeGame
	Arguments and temporary variables: 
		aMessage: 	area
		exception: 	MessageNotUnderstood: SnakeGame class>>area
		resumeValue: 	nil
	Receiver's instance variables: 
		superclass: 	Morph
		methodDict: 	a MethodDictionary(#area->SnakeGame>>#area #clear->SnakeGame>>#clea...etc...
		format: 	65544
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	nil
		name: 	#SnakeGame
		classPool: 	a Dictionary()
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#Snake_Game_Graphics
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
canvas := SnakeGame area.

"for...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
canvas := SnakeGame ar...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
canvas := SnakeGame area.

...etc...
	Receiver's instance variables: 
		ast: 	<<error during printing>>

RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (653@183)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(811626240) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(949128704))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	4136987
		lastStepMessage: 	nil
		lastCycleTime: 	4137008
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	4136987
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	4136987
		lastStepMessage: 	nil
		lastCycleTime: 	4137008
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	4136987
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a SearchMorph(365783552))(a SearchMorp...etc...
		lastStepTime: 	4136987
		lastStepMessage: 	nil
		lastCycleTime: 	4137008
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	4136987
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
SnakeGame class(Object)>>doesNotUnderstand: #area
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE
Instance of Cell did not understand #grid:
18 June 2017 3:31:06.69211 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Cell(Object)>>doesNotUnderstand: #grid:
	Receiver: a Cell
	Arguments and temporary variables: 
		aMessage: 	grid: a Grid
		exception: 	MessageNotUnderstood: Cell>>grid:
		resumeValue: 	nil
	Receiver's instance variables: 
		snakeActive: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		snakeHead: 	a Dictionary(#bluePlayer->false #redPlayer->false )
		previousSegment: 	nil
		artifact: 	a Dictionary(#type->#none )
		position: 	(1@1)


UndefinedObject>>DoIt
	Receiver: nil
	Arguments and temporary variables: 

	Receiver's instance variables: 
nil

OpalCompiler>>evaluate
	Receiver: an OpalCompiler
	Arguments and temporary variables: 
		value: 	nil
		selectedSource: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 dept...etc...
		itsSelection: 	a Text for 'grid := Grid newOfSize: 30@30.
form := Form extent: 2...etc...
		itsSelectionString: 	'grid := Grid newOfSize: 30@30.
form := Form extent: 25@25 ...etc...
	Receiver's instance variables: 
		ast: 	DoIt
	grid := Grid newOfSize: 30 @ 30.
	form := Form extent: 25 @ 25 depth...etc...
		source: 	a ReadStream
		context: 	nil
		receiver: 	nil
		compilationContext: 	a CompilationContext
		compilationContextClass: 	nil


RubSmalltalkEditor>>evaluate:andDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aStream: 	a ReadStream
		aBlock: 	[ :result | aBlock value: result ]
		result: 	nil
		rcvr: 	nil
		ctxt: 	nil
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


RubSmalltalkEditor>>highlightEvaluateAndDo:
	Receiver: a RubSmalltalkEditor
	Arguments and temporary variables: 
		aBlock: 	[ :result | text selection: result ]
	Receiver's instance variables: 
		defaultKeymappingIndex: 	an IdentityDictionary(#command->#(#noop: #cursorHome: #...etc...
		textArea: 	a RubEditingArea(710488064)
		selectorChooser: 	nil
		notificationStrategy: 	a GLMPopperNotificationStrategy


[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


RubEditingArea(RubAbstractTextArea)>>handleEdit:
	Receiver: a RubEditingArea(710488064)
	Arguments and temporary variables: 
		editBlock: 	[ textMorph textArea editor highlightEvaluateAndDo: ann action.
text...etc...
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (653@240)
		owner: 	a TransformWithLayoutMorph(93293824)
		submorphs: 	an Array(a RubPrimarySelectionMorph(972065024) a RubCursor(100333286...etc...
		fullBounds: 	nil
		color: 	Color transparent
		extension: 	a MorphExtension (126692608) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a GLMRubricSmalltalkTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(327312384)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	nil
		editingMode: 	a RubSmalltalkScriptingMode
		cursor: 	a RubCursor(1003332864)
		segments: 	an OrderedCollection(a RubHighlightSegmentMorph(517426176))
		getMenuPolicy: 	nil
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
	Receiver: a GLMMorphicPharoScriptRenderer
	Arguments and temporary variables: 
		ann: 	a GLMHighlightAndEvaluate
	Receiver's instance variables: 
		renderer: 	a GLMMorphicRenderer
		textMorph: 	a RubScrolledTextMorph(363100416)
		textModel: 	a GLMRubricSmalltalkTextModel


WorldState>>runStepMethodsIn:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
		queue: 	WaitfreeQueue with 0 items
		nextInQueue: 	[ textMorph textArea
	handleEdit: [ textMorph textArea editor high...etc...
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a LineMorph(684106240))(a LineMorph(68...etc...
		lastStepTime: 	4208024
		lastStepMessage: 	nil
		lastCycleTime: 	4208046
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	4208024
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>runStepMethods
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldState>>doOneCycleNowFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a LineMorph(684106240))(a LineMorph(68...etc...
		lastStepTime: 	4208024
		lastStepMessage: 	nil
		lastCycleTime: 	4208046
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	4208024
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldState>>doOneCycleFor:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aWorld: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	a FormCanvas on: DisplayScreen(1304x746x32)
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a LineMorph(684106240))(a LineMorph(68...etc...
		lastStepTime: 	4208024
		lastStepMessage: 	nil
		lastCycleTime: 	4208046
		alarms: 	a Heap(MorphicAlarm(#hideShow -> a RubCursor(1003332864)))
		lastAlarmTime: 	4208024
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>doOneCycle
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a GLMSystem...etc...
		fullBounds: 	(0@0) corner: (1304@746)
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>doOneCycle
	Receiver: WorldMorph
	Arguments and temporary variables: 

	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
	Receiver: a MorphicUIManager
	Arguments and temporary variables: 

	Receiver's instance variables: 
		interactiveParser: 	nil
		activeTranscript: 	nil


[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
	Receiver: [ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		outerContext: 	MorphicUIManager>>spawnNewProcess
		startpc: 	65
		numArgs: 	0



--- The full stack ---
Cell(Object)>>doesNotUnderstand: #grid:
UndefinedObject>>DoIt
OpalCompiler>>evaluate
RubSmalltalkEditor>>evaluate:andDo:
RubSmalltalkEditor>>highlightEvaluateAndDo:
[ textMorph textArea editor highlightEvaluateAndDo: ann action.
textMorph shoutStyler style: textMorph text ] in [ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
RubEditingArea(RubAbstractTextArea)>>handleEdit:
[ textMorph textArea
	handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.
		textMorph shoutStyler style: textMorph text ] ] in GLMMorphicPharoScriptRenderer(GLMMorphicPharoCodeRenderer)>>actOnHighlightAndEvaluate:
WorldState>>runStepMethodsIn:
WorldMorph>>runStepMethods
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

18 June 2017 4:18:24.28211 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	5
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	5
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@278)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(646432000) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@278)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@278)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(646432000) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@278)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@278)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(646432000) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@278)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@278)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(646432000) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@278)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(683@415.0) corner: (699@431.0)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(683@415) mouseOver 7733359 nil]
		targetOffset: 	(422@124)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7733359 683 415 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(683@415.0) corner: (699@431.0)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(683@415) mouseOver 7733359 nil]
		targetOffset: 	(422@124)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7733359 683 415 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a NautilusW...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1304@746)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a LineMorph(150157824))(a LineMorph(15...etc...
		lastStepTime: 	7045115
		lastStepMessage: 	nil
		lastCycleTime: 	7045136
		alarms: 	a Heap()
		lastAlarmTime: 	7045115
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1304@746)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a NautilusW...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1304@746)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a NautilusW...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	false
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-18T14:20:58.70111+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-18T14:20:58.70111+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-18T14:20:58.70111+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-18T14:20:58.70111+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-18T14:20:58.70111+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	false
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self managedServers do: [ :each ...etc...
		id: 	nil
		creationTime: 	2017-06-18T14:20:58.70111+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	false
		snapshotResult: 	false
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

20 June 2017 4:38:22.230511 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	5
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	5
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@278)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(646432000) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@278)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@278)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(646432000) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@278)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@278)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(646432000) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@278)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@278)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(646432000) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@278)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(683@415.0) corner: (699@431.0)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(683@415) mouseOver 7733359 nil]
		targetOffset: 	(422@124)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7733359 683 415 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(683@415.0) corner: (699@431.0)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(683@415) mouseOver 7733359 nil]
		targetOffset: 	(422@124)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7733359 683 415 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1288@730)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1288@730)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a NautilusW...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1288@730)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a LineMorph(150157824))(a LineMorph(15...etc...
		lastStepTime: 	7045115
		lastStepMessage: 	nil
		lastCycleTime: 	7045136
		alarms: 	a Heap()
		lastAlarmTime: 	7045115
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1288@730)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1288@730)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a NautilusW...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1288@730)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a NautilusW...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	true
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	true
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	true
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-20T16:38:22.094511+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-20T16:38:22.094511+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-20T16:38:22.094511+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-20T16:38:22.094511+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	true
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-20T16:38:22.094511+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	true
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-20T16:38:22.094511+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	true
		snapshotResult: 	true
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

THERE_BE_DRAGONS_HERE

21 June 2017 6:58:15.996953 pm

VM: Win32 - IX86 - 6.1 - CoInterpreter VMMaker.oscog-eem.2231 uuid: de62947a-7f40-4977-a232-e06a3a80c939 May 31 2017
StackToRegisterMappingCogit VMMaker.oscog-eem.2227 uuid: 7ea146b4-39ce-4de7-afa3-a76ed1d1da35 May 31 2017
VM: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $ Date: Tue May 30 19:41:27 2017 -0700 $ Plugins: 201705310241 https://github.com/OpenSmalltalk/opensmalltalk-vm.git $

Image: Pharo6.0 [Latest update: #60499]

Process>>terminate
	Receiver: a Process in Process>>terminate
	Arguments and temporary variables: 
		ctxt: 	nil
		unwindBlock: 	nil
		oldList: 	nil
	Receiver's instance variables: 
		nextLink: 	nil
		suspendedContext: 	Process>>terminate
		priority: 	40
		myList: 	nil
		name: 	nil
		env: 	a WeakArray(nil nil nil nil nil nil a DefaultExecutionEnvironment nil nil ...etc...
		effectiveProcess: 	nil
		terminating: 	true


NECController>>stopCompletionDelay
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


NECController>>closeMenu
	Receiver: a NECController
	Arguments and temporary variables: 

	Receiver's instance variables: 
		model: 	a RubScrolledTextModel
		menuMorph: 	nil
		editor: 	a RubSmalltalkEditor
		context: 	nil
		inverseMapping: 	a Dictionary($"->$" $'->$' $)->$( $]->$[ $}->${ )
		completionDelay: 	a Process in Process>>terminate


MessageSend>>value
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg: 	a MorphLostFocus
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


MessageSend>>cull:cull:
	Receiver: MessageSend(#closeMenu -> a NECController)
	Arguments and temporary variables: 
		arg1: 	a MorphLostFocus
		arg2: 	an Announcer
	Receiver's instance variables: 
		receiver: 	a NECController
		selector: 	#closeMenu
		arguments: 	#()


[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


BlockClosure>>on:do:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | 
| copy onDoCtx process handler bottom thisCtx |
onDoCtx...etc...
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


BlockClosure>>on:fork:
	Receiver: [ action cull: anAnnouncement cull: announcer ]
	Arguments and temporary variables: 
		exception: 	UnhandledError
		handlerAction: 	[ :ex | ex pass ]
	Receiver's instance variables: 
		outerContext: 	AnnouncementSubscription>>deliver:
		startpc: 	47
		numArgs: 	0


AnnouncementSubscription>>deliver:
	Receiver: an AnnouncementSubscription
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		announcer: 	an Announcer
		announcementClass: 	MorphLostFocus
		subscriber: 	a NECController
		action: 	MessageSend(#closeMenu -> a NECController)


[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		index: 	5
		subscription: 	an AnnouncementSubscription
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


BlockClosure>>ifCurtailed:
	Receiver: [ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ]
	Arguments and temporary variables: 
		aBlock: 	[ self deliver: anAnnouncement to: subs startingAt: index + 1 ]
		complete: 	nil
		result: 	nil
	Receiver's instance variables: 
		outerContext: 	SubscriptionRegistry>>deliver:to:startingAt:
		startpc: 	54
		numArgs: 	0


SubscriptionRegistry>>deliver:to:startingAt:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
		startIndex: 	1
		subscription: 	an AnnouncementSubscription
		index: 	5
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:to:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		subs: 	an Array(an AnnouncementSubscription an AnnouncementSubscription an Annou...etc...
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


SubscriptionRegistry>>deliver:
	Receiver: a SubscriptionRegistry
	Arguments and temporary variables: 
		interestedSubscriptions: 	an Array(an AnnouncementSubscription an AnnouncementSu...etc...
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		subscriptions: 	an IdentitySet(an AnnouncementSubscription an AnnouncementSubscr...etc...
		monitor: 	a Semaphore()


Announcer>>announce:
	Receiver: an Announcer
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		registry: 	a SubscriptionRegistry


RubEditingArea(Morph)>>doAnnounce:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		anAnnouncement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@278)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(646432000) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@278)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>announceKeyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
		announcement: 	a MorphLostFocus
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@278)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(646432000) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@278)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(Morph)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		gotFocus: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@278)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(646432000) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@278)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
	Receiver: a RubEditingArea(516162304)
	Arguments and temporary variables: 
		aBoolean: 	false
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1010@278)
		owner: 	a TransformWithLayoutMorph(380722688)
		submorphs: 	an Array(a RubPrimarySelectionMorph(646432000) a RubCursor(474527232...etc...
		fullBounds: 	(0@0) corner: (1010@278)
		color: 	Color transparent
		extension: 	a MorphExtension (280036096) [other:  (announcer -> an Announcer) (k...etc...
		model: 	a RubScrolledTextModel
		paragraph: 	a RubShoutStylerDecorator
		editor: 	a RubSmalltalkEditor
		scrollPane: 	a RubTextScrollPane(381914880)
		editingState: 	a RubEditingState
		textStyle: 	a TextStyle Source Code Pro
		textColor: 	Color white
		margins: 	(6@6) corner: (6@6)
		readOnly: 	false
		menuAllowed: 	true
		editingMode: 	a RubSmalltalkCodeMode
		cursor: 	a RubCursor(474527232)
		segments: 	an OrderedCollection()
		getMenuPolicy: 	a RubPluggableGetMenuPolicy
		mouseDownPoint: 	nil
		wrapped: 	true
		editorClass: 	RubSmalltalkEditor


HandMorph>>newKeyboardFocus:
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 
		aMorphOrNil: 	nil
		oldFocus: 	a RubEditingArea(516162304)
	Receiver's instance variables: 
		bounds: 	(683@415.0) corner: (699@431.0)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(683@415) mouseOver 7733359 nil]
		targetOffset: 	(422@124)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7733359 683 415 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


HandMorph>>releaseKeyboardFocus
	Receiver: a HandMorph(58125568)
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(683@415.0) corner: (699@431.0)
		owner: 	a WorldMorph(562956288) [world]
		submorphs: 	#()
		fullBounds: 	nil
		color: 	Color blue
		extension: 	a MorphExtension (501075456) [other:  (kmDispatcher -> a KMDispatche...etc...
		mouseFocus: 	nil
		keyboardFocus: 	nil
		eventListeners: 	nil
		mouseListeners: 	nil
		keyboardListeners: 	nil
		mouseClickState: 	a MouseClickState[#firstClickUp]
		mouseOverHandler: 	a MouseOverHandler
		lastMouseEvent: 	[(683@415) mouseOver 7733359 nil]
		targetOffset: 	(422@124)
		damageRecorder: 	a DamageRecorder
		cacheCanvas: 	nil
		cachedCanvasHasHoles: 	false
		temporaryCursor: 	nil
		temporaryCursorOffset: 	nil
		hardwareCursor: 	nil
		hasChanged: 	true
		savedPatch: 	nil
		lastEventBuffer: 	#(1 7733359 683 415 0 0 0 1)
		lastKeyScanCode: 	83
		combinedChar: 	nil
		eventSource: 	nil
		lastSystemEvent: 	nil
		captureBlock: 	nil
		recentModifiers: 	3


[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1288@730)
		hand: 	a HandMorph(58125568)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1288@730)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a NautilusW...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


Array(SequenceableCollection)>>do:
	Receiver: an Array(a HandMorph(58125568))
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
		index: 	1
	Receiver's instance variables: 
an Array(a HandMorph(58125568))

WorldState>>handsDo:
	Receiver: a WorldState
	Arguments and temporary variables: 
		aBlock: 	[ :hand | hand releaseKeyboardFocus ]
	Receiver's instance variables: 
		hands: 	an Array(a HandMorph(58125568))
		viewBox: 	(0@0) corner: (1288@730)
		canvas: 	nil
		damageRecorder: 	a DamageRecorder
		stepList: 	a Heap(StepMessage(#stepAt: -> a LineMorph(150157824))(a LineMorph(15...etc...
		lastStepTime: 	7045115
		lastStepMessage: 	nil
		lastCycleTime: 	7045136
		alarms: 	a Heap()
		lastAlarmTime: 	7045115
		menuBuilder: 	a PragmaMenuBuilder ( nil ) 
		activeHand: 	a HandMorph(58125568)


WorldMorph>>viewBox:
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 
		newViewBox: 	(0@0) corner: (1288@730)
	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1288@730)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a NautilusW...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
	Receiver: a WorldMorph(562956288) [world]
	Arguments and temporary variables: 

	Receiver's instance variables: 
		bounds: 	(0@0) corner: (1288@730)
		owner: 	nil
		submorphs: 	an Array(a MenuMorph(47225344) a TaskbarMorph(804941056) a NautilusW...etc...
		fullBounds: 	nil
		color: 	(Color r: 0.295 g: 0.295 b: 0.295 alpha: 1.0)
		extension: 	a MorphExtension (240806656) [other:  (dragEnabled -> true) (dropEna...etc...
		borderWidth: 	0
		borderColor: 	(Color r: 0.861 g: 1.0 b: 0.722 alpha: 1.0)
		backgroundMorph: 	nil
		worldState: 	a WorldState
		griddingOn: 	nil
		osWindow: 	nil
		session: 	nil


WorldMorph class>>startUp
	Receiver: WorldMorph
	Arguments and temporary variables: 
		world: 	a WorldMorph(562956288) [world]
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


WorldMorph class(Behavior)>>startUp:
	Receiver: WorldMorph
	Arguments and temporary variables: 
		resuming: 	true
	Receiver's instance variables: 
		superclass: 	PasteUpMorph
		methodDict: 	a MethodDictionary(#acceptDroppingMorph:event:->WorldMorph>>#accept...etc...
		format: 	65549
		layout: 	a FixedLayout
		instanceVariables: 	nil
		organization: 	a ClassOrganization
		subclasses: 	{AthensWorldMorph. OSWindowWorldMorph}
		name: 	#WorldMorph
		classPool: 	a Dictionary(#ExtraWorldList->#() )
		sharedPools: 	an OrderedCollection()
		environment: 	a SystemDictionary(lots of globals)
		category: 	#'Morphic-Core-Worlds'
		traitComposition: 	{}
		localSelectors: 	nil
		announcer: 	nil


ClassSessionHandler>>startup:
	Receiver: a ClassSessionHandler(WorldMorph)
	Arguments and temporary variables: 
		isImageStarting: 	true
	Receiver's instance variables: 
		registeredClassName: 	#WorldMorph


[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	true
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-21T18:58:15.868953+02:00


[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-21T18:58:15.868953+02:00


BlockClosure>>on:do:
	Receiver: [ aBlock value: each ]
	Arguments and temporary variables: 
		exception: 	Exception
		handlerAction: 	[ :error | self errorHandler handleError: error ]
	Receiver's instance variables: 
		outerContext: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | ...etc...
		startpc: 	41
		numArgs: 	0


[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
		each: 	a ClassSessionHandler(WorldMorph)
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-21T18:58:15.868953+02:00


Array(SequenceableCollection)>>do:
	Receiver: an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...
	Arguments and temporary variables: 
		aBlock: 	[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self e...etc...
		index: 	49
	Receiver's instance variables: 
an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(SmallInteger) a Cla...etc...

WorkingSession>>runList:do:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		aList: 	an Array(a ClassSessionHandler(GlobalIdentifier) a ClassSessionHandler(S...etc...
		aBlock: 	[ :each | each startup: isImageStarting ]
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-21T18:58:15.868953+02:00


WorkingSession>>runStartup:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	true
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-21T18:58:15.868953+02:00


WorkingSession>>start:
	Receiver: a WorkingSession
	Arguments and temporary variables: 
		isImageStarting: 	true
	Receiver's instance variables: 
		manager: 	a SessionManager
		deferredStartupActions: 	an OrderedCollection([ self new activate ] [ self manag...etc...
		id: 	nil
		creationTime: 	2017-06-21T18:58:15.868953+02:00


SessionManager>>snapshot:andQuit:
	Receiver: a SessionManager
	Arguments and temporary variables: 
		save: 	true
		quit: 	false
		isImageStarting: 	true
		snapshotResult: 	true
	Receiver's instance variables: 
		currentSession: 	a WorkingSession
		categories: 	an OrderedCollection(a SessionCategory(System) a SessionCategory(Ne...etc...
		guiCategory: 	a SessionCategory(Graphical User Interface)
		toolsCategory: 	a SessionCategory(Tools)
		networkCategory: 	a SessionCategory(Network)
		systemCategory: 	a SessionCategory(System)
		userCategory: 	a SessionCategory(User)



--- The full stack ---
Process>>terminate
NECController>>stopCompletionDelay
NECController>>closeMenu
MessageSend>>value
MessageSend>>cull:
MessageSend>>cull:cull:
[ action cull: anAnnouncement cull: announcer ] in AnnouncementSubscription>>deliver:
BlockClosure>>on:do:
BlockClosure>>on:fork:
AnnouncementSubscription>>deliver:
[ "Ensure delivery to remaining announcements" subscription deliver: anAnnouncement ] in SubscriptionRegistry>>deliver:to:startingAt:
BlockClosure>>ifCurtailed:
SubscriptionRegistry>>deliver:to:startingAt:
SubscriptionRegistry>>deliver:to:
SubscriptionRegistry>>deliver:
Announcer>>announce:
RubEditingArea(Morph)>>doAnnounce:
RubEditingArea(Morph)>>announceKeyboardFocusChange:
RubEditingArea(Morph)>>keyboardFocusChange:
RubEditingArea(RubAbstractTextArea)>>keyboardFocusChange:
HandMorph>>newKeyboardFocus:
HandMorph>>releaseKeyboardFocus
[ :hand | hand releaseKeyboardFocus ] in WorldMorph>>viewBox:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldMorph>>viewBox:
WorldMorph(PasteUpMorph)>>restoreMorphicDisplay
WorldMorph class>>startUp
WorldMorph class(Behavior)>>startUp:
ClassSessionHandler>>startup:
[ :each | each startup: isImageStarting ] in WorkingSession>>runStartup:
[ aBlock value: each ] in [ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
BlockClosure>>on:do:
[ :each | 
[ aBlock value: each ]
	on: Exception
	do: [ :error | self errorHandler handleError: error ] ] in WorkingSession>>runList:do:
Array(SequenceableCollection)>>do:
WorkingSession>>runList:do:
WorkingSession>>runStartup:
WorkingSession>>start:
SessionManager>>snapshot:andQuit:
 - - - - - - - - - - - - - - -  
			- - - - - - - - - - - - - - - - - -
[ ^ SessionManager default snapshot: save andQuit: quit ] in SmalltalkImage>>snapshot:andQuit:
CurrentExecutionEnvironment class>>activate:for:
DefaultExecutionEnvironment(ExecutionEnvironment)>>beActiveDuring:
DefaultExecutionEnvironment class>>beActiveDuring:
SmalltalkImage>>snapshot:andQuit:
[ (Smalltalk snapshot: true andQuit: false)
	ifFalse: [ UIManager default inform: 'Image saved' ] ] in ToolShortcutsCategory>>saveImage
BlockClosure>>cull:
BlockClosure>>cull:cull:
BlockClosure>>cull:cull:cull:
KMCategoryBinding>>completeMatch:buffer:
[ :l | l completeMatch: self buffer: aBuffer ] in KMKeymap>>notifyCompleteMatchTo:buffer:
Array(SequenceableCollection)>>do:
KMKeymap>>notifyCompleteMatchTo:buffer:
KMKeymap>>onMatchWith:notify:andDo:
[ :entry | entry onMatchWith: anEventBuffer notify: aMatchListener andDo: aBlock ] in ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
Set>>do:
ToolShortcutsCategory(KMCategory)>>onMatchWith:notify:andDo:
KMCategoryBinding>>verifyMatchWith:notifying:thenDoing:
[ :aTarget | 
"nice hack to stop in the first listener"
aTarget
	verifyMatchWith: anEventBuffer
	notifying: self
	thenDoing: [ ^ self ] ] in KMDispatcher>>dispatch:inCategories:
OrderedCollection>>do:
KMDispatcher>>dispatch:inCategories:
KmGlobalDispatcher>>dispatch:
[ :targetToDispatch | 
targetToDispatch dispatch: KMBuffer uniqueInstance buffer copy.
aKeyboardEvent wasHandled
	ifTrue: [ ^ self ] ] in KMDispatchChain>>dispatch:
KMDispatchChain>>do:
KMDispatchChain>>dispatch:
KMDispatcher>>dispatchKeystroke:
RubEditingArea(Morph)>>dispatchKeystrokeForEvent:
RubEditingArea(RubAbstractTextArea)>>handleKeystroke:
KeyboardEvent>>sentTo:
RubEditingArea(Morph)>>handleEvent:
RubEditingArea(Morph)>>handleFocusEvent:
[ ActiveHand := self.
ActiveEvent := anEvent.
result := focusHolder
	handleFocusEvent: (anEvent transformedBy: (focusHolder transformedFrom: self)) ] in HandMorph>>sendFocusEvent:to:clear:
BlockClosure>>on:do:
WorldMorph(PasteUpMorph)>>becomeActiveDuring:
HandMorph>>sendFocusEvent:to:clear:
HandMorph>>sendEvent:focus:clear:
HandMorph>>sendKeyboardEvent:
HandMorph>>handleEvent:
HandMorph>>processEventsFromQueue:
HandMorph>>processEvents
[ :h | 
self activeHand: h.
h processEvents.
self activeHand: nil ] in WorldState>>doOneCycleNowFor:
Array(SequenceableCollection)>>do:
WorldState>>handsDo:
WorldState>>doOneCycleNowFor:
WorldState>>doOneCycleFor:
WorldMorph>>doOneCycle
WorldMorph class>>doOneCycle
[ [ WorldMorph doOneCycle.
Processor yield.
false ] whileFalse: [  ] ] in MorphicUIManager>>spawnNewProcess
[ self value.
Processor terminateActive ] in BlockClosure>>newProcess
-------------------------------------------------------------------------------

